<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Weasel.DICOM.Classes API documentation</title>
<meta name="description" content="The medical image classes are defined in this module: â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Weasel.DICOM.Classes</code></h1>
</header>
<section id="section-intro">
<p>The medical image classes are defined in this module:</p>
<pre><code>- ImagesList
- SeriesList
- StudyList
- SubjectList
- Project
- Subject
- Study
- Series
- Image
</code></pre>
<p>The functions and attributes that compose these classes make use of functions defined in <code>ReadDICOM_Image.py</code>, <code>SaveDICOM_Image.py</code>, <code>DeveloperTools.py</code>, <code>CoreModules.TreeView.py</code> and <code>CoreModules.WeaselXMLReader.py</code>. There are also some applications of the API module using the global Weasel variable.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The medical image classes are defined in this module:

    - ImagesList
    - SeriesList
    - StudyList
    - SubjectList
    - Project
    - Subject
    - Study
    - Series
    - Image

The functions and attributes that compose these classes make use of functions defined in `ReadDICOM_Image.py`, `SaveDICOM_Image.py`, `DeveloperTools.py`, `CoreModules.TreeView.py` and `CoreModules.WeaselXMLReader.py`. There are also some applications of the API module using the global Weasel variable.
&#34;&#34;&#34;

import os
import datetime
import numpy as np
import random
import pydicom
import nibabel as nib
import pandas as pd
import copy
from ast import literal_eval # Convert strings to their actual content. Eg. &#34;[a, b]&#34; becomes the actual list [a, b]
from DICOM.DeveloperTools import (PixelArrayDICOMTools, GenericDICOMTools)
import DICOM.ReadDICOM_Image as ReadDICOM_Image
import DICOM.SaveDICOM_Image as SaveDICOM_Image

import logging
logger = logging.getLogger(__name__)

class ListOfDicomObjects(list):
    &#34;&#34;&#34;
    A superclass for managing Lists of Subjects, Studies, Series or Images. 
    &#34;&#34;&#34;
    def delete(self):
        &#34;&#34;&#34;
        Deletes all items in the list
        &#34;&#34;&#34;
        for item in self:
            item.delete()

    def display(self):
        &#34;&#34;&#34;
        Displays all items in the list.
        &#34;&#34;&#34;
        for item in self:
            item.objWeasel.display(item)


class ImagesList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of objects of class Image. 
    &#34;&#34;&#34;
    @property
    def label(self):
        &#34;&#34;&#34;
        Returns a list of names of the list of images.
        &#34;&#34;&#34;
        listNames = [image.label for image in self]
        return listNames

    @property
    def paths(self):
        &#34;&#34;&#34;
        Returns a list of file paths of the list of images.
        &#34;&#34;&#34;
        listPaths = [image.path for image in self]
        return listPaths

    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of images.
        &#34;&#34;&#34;
        copy = []
        for image in self:
            copy.append(image.copy())
        return ImagesList(copy)
        
    def merge(self, series_number=None,series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of images into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, series_id=series_number, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)

    def new_parent(self, suffix=&#34;_Suffix&#34;):
        &#34;&#34;&#34;
        Creates a new parent series from the images in the list.
        &#34;&#34;&#34;
        return self[0].newSeriesFrom(self, suffix=suffix)

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique series to which the images belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for image in self:
            series = image.parent
            listIndividualAttributes = [series.subjectID, series.studyID, series.seriesID,
                                        series.images, series.studyUID, series.seriesUID, series.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            series = Series(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3], listAtt[4], listAtt[5], listAtt[6])
            parentsList.append(series)
        return SeriesList(parentsList)


    def display(self):
        &#34;&#34;&#34;
        Displays all images as a series.
        &#34;&#34;&#34;
        self[0].objWeasel.display(self)


    def sort(self, *argv, reverse=False):
        &#34;&#34;&#34;
        Sort the list of images by the given DICOM tags.
        &#34;&#34;&#34;
        tuple_to_sort = []
        list_to_sort = []
        list_to_sort.append(self)
        for tag in argv:
            if len(self.get_value(tag)) &gt; 0:
                attributeList = self.get_value(tag)
                list_to_sort.append(attributeList)
        for index, _ in enumerate(self):
            individual_tuple = []
            for individual_list in list_to_sort:
                individual_tuple.append(individual_list[index])
            tuple_to_sort.append(tuple(individual_tuple))
        tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
        list_sorted_images = []
        for individual in tuple_sorted:
            list_sorted_images.append(individual[0])
        self = ImagesList(list_sorted_images)
        return self

    def where(self, tag, condition, target):
        list_images = []
        for image in self:
            value = image[tag]
            if condition == &#34;==&#34;:
                statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
                if eval(statement) == True:
                    list_images.append(image)
            else:
                statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
                if eval(literal_eval(statement)) == True:
                    list_images.append(image)
        self = ImagesList(list_images)
        return self

    def get_value(self, tag):
        &#34;&#34;&#34;
        Returns a list of values of the given DICOM tag in the list of images
        &#34;&#34;&#34;
        attributes_list = []
        for image in self:
            attributes_list.append(image.get_value(tag))
        return attributes_list

    def set_value(self, tag, value):
        &#34;&#34;&#34;
        Set the variable &#34;value&#34; to the given DICOM tag in the list of images
        &#34;&#34;&#34;
        if isinstance(value, list) and len(self) == len(value):
            for index, image in enumerate(self):
                image.set_value(tag, value[index])
        else:
            for image in self:
                image.set_value(tag, value)
    
    def __getitem__(self, tag):
        if isinstance(tag, int):
            for index, image in enumerate(self):
                if index == tag:
                    return image
        else:
            return self.get_value(tag)

    def __setitem__(self, tag, value):
        if isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
            dicom_tag = tag.split(&#39; &#39;)[0]
            logical_operator = tag.split(&#39; &#39;)[1]
            target_value = tag.split(&#39; &#39;)[2]
            listImages = self.where(dicom_tag, logical_operator, target_value)
            listImages.set_value(dicom_tag, value)
        elif isinstance(tag, str):
            self.set_value(tag, value)
        elif isinstance(tag, int) and isinstance(value, Image):
            newList = []
            for index, image in enumerate(self):
                if index == tag:
                    newList.append(value)
                else:
                    newList.append(image)
            self = newList
            #self[tag] = value
        elif isinstance(tag, list) and isinstance(value, list):
            for index, dicom_tag in enumerate(tag):
                self.set_value(dicom_tag, value[index])


class SeriesList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Series. 
    &#34;&#34;&#34;  
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of series.
        &#34;&#34;&#34;
        copy = []
        for series in self:
            copy.append(series.copy())
        return SeriesList(copy)

    def merge(self, series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)  

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique studies to which the series belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for series in self:
            study = series.parent
            listIndividualAttributes = [study.subjectID, study.studyID, study.studyUID, study.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            study = Study(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3])
            parentsList.append(study)
        return StudyList(parentsList)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of images where each list refers to the various images of a series.
        &#34;&#34;&#34;
        childrenList = []
        for series in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(series.children)
        return childrenList


class StudyList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Study. 
    &#34;&#34;&#34;
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of studies.
        &#34;&#34;&#34;
        copy = []
        for study in self:
            copy.append(study.copy())
        return StudyList(copy)

    def merge(self, study_name=&#39;MergedStudies&#39;, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, newStudyName=study_name, overwrite=overwrite, progress_bar=progress_bar)

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique subjects to which the studies belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for study in self:
            subject = study.parent
            listIndividualAttributes = [subject.subjectID, subject.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            subject = Subject(self[0].objWeasel, listAtt[0], listAtt[1])
            parentsList.append(subject)
        return SubjectList(parentsList)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of series where each list refers to the various series of a study.
        &#34;&#34;&#34;
        childrenList = []
        for study in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(study.children)
        return childrenList


class SubjectList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Subject. 
    &#34;&#34;&#34;
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of subjects.
        &#34;&#34;&#34;
        copy = []
        for subject in self:
            copy.append(subject.copy())
        return SubjectList(copy)

    def merge(self, subject_name=&#39;MergedSubjects&#39;, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, newSubjectName=subject_name, overwrite=overwrite, progress_bar=progress_bar)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of series where each list refers to the various series of a study.
        &#34;&#34;&#34;
        childrenList = []
        for subject in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(subject.subject)
        return childrenList

class Project:
    &#34;&#34;&#34;This class is the top-level of the TreeView hierarchy. It bundles all scans opened in the Weasel GUI.

        Parameters
        ----------
        objWeasel : the Weasel global variable
    &#34;&#34;&#34;
    def __init__(self, objWeasel):
        self.objWeasel = objWeasel
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Project.children called&#34;)
        try:
            children = []
            rootXML = self.objWeasel.objXMLReader.root
            for subjectXML in rootXML:
                subjectID = subjectXML.attrib[&#39;id&#39;]
                subject = Subject(self.objWeasel, subjectID)
                children.append(subject)
            return SubjectList(children)
        except Exception as e:
            print(&#39;Error in Project.children: &#39; + str(e))
            logger.exception(&#39;Error in Project.children: &#39; + str(e))
    
    @property
    def number_children(self):
        return len(self.children)


class Subject:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;PatientID&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Subject() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;suffix&#39;)
    def __init__(self, objWeasel, subjectID, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.suffix = &#39;&#39; if suffix is None else suffix

    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)
    
    @property
    def children(self):
        logger.info(&#34;Subject.children called&#34;)
        try:
            children = []
            subjectXML = self.objWeasel.objXMLReader.getSubject(self.subjectID)
            if subjectXML:
                for studyXML in subjectXML:
                    studyID = studyXML.attrib[&#39;id&#39;]
                    study = Study(self.objWeasel, self.subjectID, studyID)
                    children.append(study)
            return StudyList(children)
        except Exception as e:
            print(&#39;Error in Subject.children: &#39; + str(e))
            logger.exception(&#39;Error in Subject.children: &#39; + str(e))

    @property
    def parent(self):
        logger.info(&#34;Subject.parent called&#34;)
        try:
            return Project(self.objWeasel)
        except Exception as e:
            print(&#39;Error in Subject.parent: &#39; + str(e))
            logger.exception(&#39;Error in Subject.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)
    
    @property
    def label(self):
        logger.info(&#34;Subject.label called&#34;)
        try:
            return self.subjectID
        except Exception as e:
            print(&#39;Error in Subject.label: &#39; + str(e))
            logger.exception(&#39;Error in Subject.label: &#39; + str(e))
    
    @property
    def all_images(self):
        logger.info(&#34;Subject.all_images called&#34;)
        try:
            listImages = []
            for study in self.children:
                listImages.extend(study.all_images)
            return ImagesList(listImages)
        except Exception as e:
            print(&#39;Error in Subject.all_images: &#39; + str(e))
            logger.exception(&#39;Error in Subject.all_images: &#39; + str(e))
    
    def new(self, suffix=&#34;_Copy&#34;, subjectID=None):
        logger.info(&#34;Subject.new called&#34;)
        try:
            if subjectID is None:
                subjectID = self.subjectID + suffix
            return Subject(self.objWeasel, subjectID)
        except Exception as e:
            print(&#39;Error in Subject.new: &#39; + str(e))
            logger.exception(&#39;Error in Subject.new: &#39; + str(e))

    def copy(self, suffix=&#34;_Copy&#34;, output_dir=None):
        logger.info(&#34;Subject.copy called&#34;)
        try:
            newSubjectID = self.subjectID + suffix
            for study in self.children:
                study.copy(suffix=&#39;&#39;, newSubjectID=newSubjectID, output_dir=output_dir)
            return Subject(self.objWeasel, newSubjectID)
        except Exception as e:
            print(&#39;Error in Subject.copy: &#39; + str(e))
            logger.exception(&#39;Error in Subject.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Subject.delete called&#34;)
        try:
            for study in self.children:
                study.delete()
            self.subjectID = &#39;&#39;
            #interfaceDICOMXMLFile.removeSubjectinXMLFile(self.objWeasel, self.subjectID)
        except Exception as e:
            print(&#39;Error in Subject.delete: &#39; + str(e))
            logger.exception(&#39;Error in Subject.delete: &#39; + str(e))

    def add(self, study):
        logger.info(&#34;Subject.add called&#34;)
        try:
            study.subjectID = self.subjectID
            study[&#34;PatientID&#34;] = study.subjectID
            #interfaceDICOMXMLFile.insertNewStudyInXMLFile(self, study.subjectID, study.studyID, study.suffix)
        except Exception as e:
            print(&#39;Error in Subject.add: &#39; + str(e))
            logger.exception(&#39;Error in Subject.add: &#39; + str(e))

    @staticmethod
    def merge(listSubjects, newSubjectName=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False, output_dir=None):
        logger.info(&#34;Subject.merge called&#34;)
        try:
            if newSubjectName:
                outputSubject = Subject(listSubjects[0].objWeasel, newSubjectName)
            else:
                outputSubject = listSubjects[0].new(suffix=suffix)
            # Setup Progress Bar
            progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listSubjects)) + &#34; Subjects&#34;
            if progress_bar == True: 
                listSubjects[0].objWeasel.progress_bar(
                    msg = (&#34;&lt;H4&gt;Merging {} Subjects&lt;/H4&gt;&#34;).format(len(listSubjects)),
                    index = 0, max = len(listSubjects))
            # Add new subject (outputSubject) to XML
            for index, subject in enumerate(listSubjects):
                # Increment progress bar
                subjMsg = &#34;Merging subject &#34; + subject.subjectID
                if progress_bar == True: 
                    listSubjects[0].objWeasel.progress_bar(
                        msg = (&#34;&lt;H4&gt;&#34; + subjMsg + &#34;&lt;/H4&gt;&#34;),
                        index = index+1, max = len(listSubjects))
                # Overwrite or not?
                if overwrite == False:
                    for study in subject.children:
                        # Create a copy of the study into the new subject
                        studyMsg = &#34;, study &#34; + study.studyID
                        if progress_bar == True: 
                            listSubjects[0].objWeasel.progress_bar(
                                msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                                index = index+1, max = len(listSubjects))
                        study.copy(suffix=suffix, newSubjectID=outputSubject.subjectID, output_dir=output_dir)
                else:
                    for study in subject.children:
                        studyMsg = &#34;, study &#34; + study.studyID
                        if progress_bar == True: 
                            listSubjects[0].objWeasel.progress_bar(
                                msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                                index = index+1, max = len(listSubjects))
                        seriesPathsList = []
                        for series in study.children:
                            series.Item(&#39;PatientID&#39;, outputSubject.subjectID)
                            seriesPathsList.append(series.images)
                        outputSubject.objWeasel.objXMLReader.insertNewStudyInXMLFile(
                                    outputSubject.subjectID, study.studyID, suffix, seriesList=seriesPathsList) # Need new Study name situation
                        # Add study to new subject in the XML
                    subject.objWeasel.objXMLReader.removeSubjectFromXMLFile(subject.subjectID)
            return outputSubject
        except Exception as e:
            print(&#39;Error in Subject.merge: &#39; + str(e))
            logger.exception(&#39;Error in Subject.merge: &#39; + str(e))

    def get_value(self, tag):
        logger.info(&#34;Subject.get_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                studyOutputValuesList = []
                for study in self.children:
                    studyOutputValuesList.append(study.get_value(tag)) # extend will allow long single list, while append creates list of lists
                return studyOutputValuesList
            else:
                return []
        except Exception as e:
            print(&#39;Error in Subject.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Subject.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Subject.set_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                for study in self.children:
                    study.set_value(tag, newValue)
        except Exception as e:
            print(&#39;Error in Subject.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Subject.set_value: &#39; + str(e))
    
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)


class Study:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;StudyInstanceUID&#34;, &#34;StudyDescription&#34;, &#34;StudyDate&#34; and &#34;StudyTime&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        studyUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;StudyInstanceUID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Study() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;studyUID&#39;, &#39;suffix&#39;)
    def __init__(self, objWeasel, subjectID, studyID, studyUID=None, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.studyUID = self.StudyUID if studyUID is None else studyUID
        self.suffix = &#39;&#39; if suffix is None else suffix
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Study.children called&#34;)
        try:
            children = []
            studyXML = self.objWeasel.objXMLReader.getStudy(self.subjectID, self.studyID)
            if studyXML:
                for seriesXML in studyXML:
                    seriesID = seriesXML.attrib[&#39;id&#39;]
                    images = []
                    for imageXML in seriesXML:
                        images.append(imageXML.find(&#39;name&#39;).text)
                    series = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, listPaths=images)
                    children.append(series)
            return SeriesList(children)
        except Exception as e:
            print(&#39;Error in Study.children: &#39; + str(e))
            logger.exception(&#39;Error in Study.children: &#39; + str(e))
    
    @property
    def parent(self):
        logger.info(&#34;Study.parent called&#34;)
        try:
            return Subject(self.objWeasel, self.subjectID)
        except Exception as e:
            print(&#39;Error in Study.parent: &#39; + str(e))
            logger.exception(&#39;Error in Study.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)

    @property
    def label(self):
        logger.info(&#34;Study.label called&#34;)
        try:
            return self.studyID
        except Exception as e:
            print(&#39;Error in Study.label: &#39; + str(e))
            logger.exception(&#39;Error in Study.label: &#39; + str(e))

    @property
    def all_images(self):
        logger.info(&#34;Study.all_images called&#34;)
        try:
            listImages = []
            for series in self.children:
                listImages.extend(series.children)
            return ImagesList(listImages)
        except Exception as e:
            print(&#39;Error in Study.all_images: &#39; + str(e))
            logger.exception(&#39;Error in Study.all_images: &#39; + str(e))

    def new(self, suffix=&#34;_Copy&#34;, studyID=None):
        logger.info(&#34;Study.new called&#34;)
        try:
            if studyID is None:
                studyID = self.studyID + suffix
            else:
                dt = datetime.datetime.now()
                time = dt.strftime(&#39;%H%M%S&#39;)
                date = dt.strftime(&#39;%Y%m%d&#39;)
                studyID = date + &#34;_&#34; + time + &#34;_&#34; + studyID + suffix
            prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
            study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
            return Study(self.objWeasel, self.subjectID, studyID, studyUID=study_uid, suffix=suffix)
        except Exception as e:
            print(&#39;Error in Study.new: &#39; + str(e))
            logger.exception(&#39;Error in Study.new: &#39; + str(e))

    def copy(self, suffix=&#34;_Copy&#34;, newSubjectID=None, output_dir=None):
        logger.info(&#34;Study.copy called&#34;)
        try:
            if newSubjectID:
                prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
                study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
                newStudyInstance = Study(self.objWeasel, newSubjectID, self.studyID + suffix, studyUID=study_uid, suffix=suffix)
            else:
                newStudyInstance = self.new(suffix=suffix)
            seriesPathsList = []
            for series in self.children:
                copiedSeries = series.copy(suffix=suffix, series_id=series.seriesID.split(&#39;_&#39;, 1)[0], series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=newStudyInstance.studyUID,
                                           study_name=newStudyInstance.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=newSubjectID, output_dir=output_dir)
                seriesPathsList.append(copiedSeries.images)
            #interfaceDICOMXMLFile.insertNewStudyInXMLFile(newStudyInstance.objWeasel, newStudyInstance.subjectID, newStudyInstance.studyID, suffix, seriesList=seriesPathsList)
            return newStudyInstance
        except Exception as e:
            print(&#39;Error in Study.copy: &#39; + str(e))
            logger.exception(&#39;Error in Study.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Study.delete called&#34;)
        try:
            for series in self.children:
                series.delete()
            #interfaceDICOMXMLFile.removeOneStudyFromSubject(self.objWeasel, self.subjectID, self.studyID)
            self.subjectID = self.studyID = &#39;&#39;
        except Exception as e:
            print(&#39;Error in Study.delete: &#39; + str(e))
            logger.exception(&#39;Error in Study.delete: &#39; + str(e))
    
    def add(self, series):
        logger.info(&#34;Study.add called&#34;)
        try:
            series[&#34;PatientID&#34;] = self.subjectID
            series[&#34;StudyDate&#34;] = self.studyID.split(&#34;_&#34;)[0]
            series[&#34;StudyTime&#34;] = self.studyID.split(&#34;_&#34;)[1]
            series[&#34;StudyDescription&#34;] = &#34;&#34;.join(self.studyID.split(&#34;_&#34;)[2:])
            series[&#34;StudyInstanceUID&#34;] = self.studyUID
            # Need to adapt the series to the new Study
            seriesNewID, seriesNewUID = GenericDICOMTools.generateSeriesIDs(self.objWeasel, series.images, studyUID=self.studyUID)
            series[&#34;SeriesNumber&#34;] = seriesNewID
            series[&#34;SeriesInstanceUID&#34;] = seriesNewUID
        except Exception as e:
            print(&#39;Error in Study.add: &#39; + str(e))
            logger.exception(&#39;Error in Study.add: &#39; + str(e))

    @staticmethod
    def merge(listStudies, newStudyName=None, suffix=&#39;_Merged&#39;, overwrite=False, output_dir=None, progress_bar=True):
        logger.info(&#34;Study.merge called&#34;)
        try:
            if newStudyName:
                prefixUID = &#39;.&#39;.join(listStudies[0].studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
                study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
                newStudyID = listStudies[0].studyID.split(&#39;_&#39;)[0] + &#34;_&#34; + listStudies[0].studyID.split(&#39;_&#39;)[1] + &#34;_&#34; + newStudyName
                outputStudy = Study(listStudies[0].objWeasel, listStudies[0].subjectID, newStudyID, studyUID=study_uid)
            else:
                outputStudy = listStudies[0].new(suffix=suffix)
            # Set up Progress Bar
            progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listStudies)) + &#34; Studies&#34;
            if progress_bar == True: 
                listStudies[0].objWeasel.progress_bar(
                    msg = (&#34;&lt;H4&gt;Merging {} Studies&lt;/H4&gt;&#34;).format(len(listStudies)),
                    index = 0, max = len(listStudies))
            # Add new study (outputStudy) to XML
            seriesPathsList = []
            if overwrite == False:
                for index, study in enumerate(listStudies):
                    if progress_bar == True: 
                        listStudies[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listStudies))
                    seriesNumber = 1
                    for series in study.children:
                        copiedSeries = series.copy(suffix=suffix, series_id=seriesNumber, series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=outputStudy.studyUID,
                                                   study_name=outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=outputStudy.subjectID, output_dir=output_dir)
                        seriesPathsList.append(copiedSeries.images)
                        seriesNumber += 1
            else:
                seriesNumber = 1
                for index, study in enumerate(listStudies):
                    if progress_bar == True: 
                        listStudies[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listStudies))
                    for series in study.children:
                        series.Item(&#39;PatientID&#39;, outputStudy.subjectID)
                        series.Item(&#39;StudyInstanceUID&#39;, outputStudy.studyUID)
                        series.Item(&#39;StudyDescription&#39;, outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1])
                        series.Item(&#39;SeriesNumber&#39;, seriesNumber)
                        # Generate new series uid based on outputStudy.studyUID
                        _, new_series_uid = GenericDICOMTools.generateSeriesIDs(series.objWeasel, series.images, seriesNumber=seriesNumber, studyUID=outputStudy.studyUID)
                        series.Item(&#39;SeriesInstanceUID&#39;, new_series_uid)
                        seriesPathsList.append(series.images)
                        seriesNumber += 1
                    study.objWeasel.objXMLReader.removeOneStudyFromSubject(study.subjectID, study.studyID)
            outputStudy.objWeasel.objXMLReader.insertNewStudyInXMLFile(outputStudy.subjectID, outputStudy.studyID, suffix, seriesList=seriesPathsList)
            return outputStudy
        except Exception as e:
            print(&#39;Error in Study.merge: &#39; + str(e))
            logger.exception(&#39;Error in Study.merge: &#39; + str(e))

    @property
    def StudyUID(self):
        if len(self.children) &gt; 0:
            return self.children[0].studyUID
        else:
            return pydicom.uid.generate_uid(prefix=None)
    
    def get_value(self, tag):
        logger.info(&#34;Study.get_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                seriesOutputValuesList = []
                for series in self.children:
                    seriesOutputValuesList.append(series.get_value(tag)) # extend will allow long single list, while append creates list of lists.
                return seriesOutputValuesList
            else:
                return []
        except Exception as e:
            print(&#39;Error in Study.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Study.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Study.set_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                for series in self.children:
                    series.set_value(tag, newValue)
        except Exception as e:
            print(&#39;Error in Study.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Study.set_value: &#39; + str(e))

    
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)


class Series:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;StudyInstanceUID&#34;, &#34;StudyDescription&#34;, &#34;StudyDate&#34; and &#34;StudyTime&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        seriesID : string
            This is the name or identification of the series, which is stored in the &#34;SeriesDescription&#34; DICOM tag.
        listPaths : list(string) (optional)
            This is a list containing the file paths of the DICOM files that belong to the Series() instance created.
            This class creates the list based on the Weasel GUI TreeView selection if it&#39;s not given.
        studyUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;StudyInstanceUID&#34; DICOM tag.
        seriesUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;SeriesInstanceUID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Series() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;seriesID&#39;, &#39;studyUID&#39;, &#39;seriesUID&#39;, 
                 &#39;images&#39;, &#39;suffix&#39;, &#39;referencePathsList&#39;)
    def __init__(self, objWeasel, subjectID, studyID, seriesID, listPaths=None, studyUID=None, seriesUID=None, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.seriesID = seriesID
        self.images = [] if listPaths is None else listPaths
        self.studyUID = self.StudyUID if studyUID is None else studyUID
        self.seriesUID = self.SeriesUID if seriesUID is None else seriesUID
        self.suffix = &#39;&#39; if suffix is None else suffix
        self.referencePathsList = []
        # This is to deal with Enhanced MRI
        #if self.PydicomList and len(self.images) == 1:
        #    self.indices = list(np.arange(len(self.PydicomList[0].PerFrameFunctionalGroupsSequence))) if hasattr(self.PydicomList[0], &#39;PerFrameFunctionalGroupsSequence&#39;) else []
        #else:
        #    self.indices = []
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Series.children called&#34;)
        try:
            children = []
            if len(self.images) &gt; 1:
                for imagePath in self.images:
                    image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
                    children.append(image)
            else:
                seriesXML = self.objWeasel.objXMLReader.getSeries(self.subjectID, self.studyID, self.seriesID)
                for imageXML in seriesXML:
                    image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imageXML.find(&#39;name&#39;).text)
                    children.append(image)
            return ImagesList(children)
        except Exception as e:
            print(&#39;Error in Series.children: &#39; + str(e))
            logger.exception(&#39;Error in Series.children: &#39; + str(e))
    
    @property
    def parent(self):
        logger.info(&#34;Series.parent called&#34;)
        try:
            return Study(self.objWeasel, self.subjectID, self.studyID, studyUID=self.studyUID)
        except Exception as e:
            print(&#39;Error in Series.parent: &#39; + str(e))
            logger.exception(&#39;Error in Series.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)

    @property
    def label(self):
        logger.info(&#34;Series.label called&#34;)
        try:
            return self.seriesID
        except Exception as e:
            print(&#39;Error in Series.label: &#39; + str(e))
            logger.exception(&#39;Error in Series.label: &#39; + str(e))
    
    def new(self, suffix=&#34;_Copy&#34;, series_id=None, series_name=None, series_uid=None):
        logger.info(&#34;Series.new called&#34;)
        try:
            if series_id is None:
                series_id, _ = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images)
            if series_name is None:
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1] + suffix
            if series_uid is None:
                _, series_uid = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images, seriesNumber=series_id)
            seriesID = str(series_id) + &#39;_&#39; + series_name
            newSeries = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, seriesUID=series_uid, suffix=suffix)
            newSeries.referencePathsList = self.images
            return newSeries
        except Exception as e:
            print(&#39;Error in Series.new: &#39; + str(e))
            logger.exception(&#39;Error in Series.new: &#39; + str(e))
    
    def copy(self, suffix=&#34;_Copy&#34;, newSeries=True, series_id=None, series_name=None, series_uid=None, study_uid=None, study_name=None, patient_id=None, output_dir=None):
        logger.info(&#34;Series.copy called&#34;)
        try:
            if newSeries == True:
                newPathsList, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name,
                                                                        study_uid=study_uid, study_name=study_name, patient_id=patient_id, suffix=suffix, output_dir=output_dir)
                return Series(self.objWeasel, self.subjectID, self.studyID, newSeriesID, listPaths=newPathsList, suffix=suffix)
            else:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = self.seriesUID
                suffix = self.suffix
                newPathsList, _ = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name, study_uid=study_uid,
                                                              study_name=study_name, patient_id=patient_id,suffix=suffix, output_dir=output_dir) # StudyID in InterfaceXML
                for newCopiedImagePath in newPathsList:
                    newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, newCopiedImagePath)
                    self.add(newImage)
        except Exception as e:
            print(&#39;Error in Series.copy: &#39; + str(e))
            logger.exception(&#39;Error in Series.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Series.delete called&#34;)
        try:
            GenericDICOMTools.deleteDICOM(self.objWeasel, self.images)
            self.images = self.referencePathsList = []
            #self.children = self.indices = []
            #self.number_children = 0
            self.subjectID = self.studyID = self.seriesID = self.seriesUID = &#39;&#39;
        except Exception as e:
            print(&#39;Error in Series.delete: &#39; + str(e))
            logger.exception(&#39;Error in Series.delete: &#39; + str(e))

    def add(self, Image):
        logger.info(&#34;Series.add called&#34;)
        try:
            self.images.append(Image.path)
            # Might need XML functions
            #self.children.append(Image)
            #self.number_children = len(self.children)
        except Exception as e:
            print(&#39;Error in Series.add: &#39; + str(e))
            logger.exception(&#39;Error in Series.add: &#39; + str(e))

    def remove(self, all_images=False, Image=None):
        logger.info(&#34;Series.remove called&#34;)
        try:
            if all_images == True:
                self.images = []
                # Might need XML functions
                #self.children = []
                #self.number_children = 0
            elif Image is not None:
                self.images.remove(Image.path)
                # Might need XML functions
                #self.children.remove(Image)
                #self.number_children = len(self.children)
        except Exception as e:
            print(&#39;Error in Series.remove: &#39; + str(e))
            logger.exception(&#39;Error in Series.remove: &#39; + str(e))

    def write(self, pixelArray, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
        logger.info(&#34;Series.write called&#34;)
        try:
            if isinstance(value_range, list):
                pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
            else:
                list_values = np.unique(pixelArray).flatten()
                list_values = [x for x in list_values if np.isnan(x) == False]
                if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                    upper_value = list_values[-2]
                else:
                    upper_value = None
                if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                    lower_value = list_values[1]
                else:
                    lower_value = None
                pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
            if self.images:
                PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.images)
            else:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                inputReference = self.referencePathsList[0] if len(self.referencePathsList)==1 else self.referencePathsList
                outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, inputReference, self.suffix, series_id=series_id, series_name=series_name, series_uid=self.seriesUID, output_dir=output_dir, parametric_map=parametric_map, colourmap=colourmap)
                self.images = outputPath
                if self[&#34;WindowWidth&#34;] and self[&#34;WindowCenter&#34;] and isinstance(value_range, list):
                    width = value_range[1] - value_range[0]
                    center = value_range[0] + (width/2)
                    self[&#34;WindowWidth&#34;] = width
                    self[&#34;WindowCenter&#34;] = center
        except Exception as e:
            print(&#39;Error in Series.write: &#39; + str(e))
            logger.exception(&#39;Error in Series.write: &#39; + str(e))
    
    def read(self):
        return self.PydicomList

    def save(self, PydicomList):
        newSubjectID = self.subjectID
        newStudyID = self.studyID
        newSeriesID = self.seriesID
        for index, dataset in enumerate(PydicomList):
            changeXML = False
            if dataset.SeriesDescription != self.PydicomList[index].SeriesDescription or dataset.SeriesNumber != self.PydicomList[index].SeriesNumber:
                changeXML = True
                newSeriesID = str(dataset.SeriesNumber) + &#34;_&#34; + str(dataset.SeriesDescription)
            if dataset.StudyDate != self.PydicomList[index].StudyDate or dataset.StudyTime != self.PydicomList[index].StudyTime or dataset.StudyDescription != self.PydicomList[index].StudyDescription:
                changeXML = True
                newStudyID = str(dataset.StudyDate) + &#34;_&#34; + str(dataset.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(dataset.StudyDescription)
            if dataset.PatientID != self.PydicomList[index].PatientID:
                changeXML = True
                newSubjectID = str(dataset.PatientID)
            SaveDICOM_Image.saveDicomToFile(dataset, output_path=self.images[index])
            if changeXML == True:
                self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
        # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
        self.subjectID = newSubjectID
        self.studyID = newStudyID
        self.seriesID = newSeriesID

    @staticmethod
    def merge(listSeries, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
        logger.info(&#34;Series.merge called&#34;)
        try:
            outputSeries = listSeries[0].new(suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)
            pathsList = [image for series in listSeries for image in series.images]
            outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, pathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
            outputSeries.images = outputPathList
            outputSeries.referencePathsList = outputPathList
            return outputSeries
        except Exception as e:
            print(&#39;Error in Series.merge: &#39; + str(e))
            logger.exception(&#39;Error in Series.merge: &#39; + str(e))
    
    # Deprecated but might be useful in the future
    #def sort(self, tagDescription, *argv):
    #    if self.Item(tagDescription) or self.Tag(tagDescription):
    #        imagePathList, _, _, indicesSorted = ReadDICOM_Image.sortSequenceByTag(self.images, tagDescription)
    #        self.images = imagePathList
    #        #if self.Multiframe: self.indices = sorted(set(indicesSorted) &amp; set(self.indices), key=indicesSorted.index)
    #    for tag in argv:
    #        if self.Item(tag) or self.Tag(tag):
    #            imagePathList, _, _, indicesSorted = ReadDICOM_Image.sortSequenceByTag(self.images, tag)
    #            self.images = imagePathList
    #            #if self.Multiframe: self.indices = sorted(set(indicesSorted) &amp; set(self.indices), key=indicesSorted.index)
    
    def sort(self, *argv, reverse=False):
        logger.info(&#34;Series.sort called&#34;)
        try:
            tuple_to_sort = []
            list_to_sort = [self.images]
            for tag in argv:
                if len(self.get_value(tag)) &gt; 0:
                    list_to_sort.append(self.get_value(tag))
            for index in range(len(self.images)):
                individual_tuple = [individual_list[index] for individual_list in list_to_sort]
                tuple_to_sort.append(tuple(individual_tuple))
            tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
            list_sorted_images = [individual[0] for individual in tuple_sorted]
            self.images = list_sorted_images
            return self
        except Exception as e:
            print(&#39;Error in Series.sort: &#39; + str(e))
            logger.exception(&#39;Error in Series.sort: &#39; + str(e))
    
    def where(self, tag, condition, target):
        logger.info(&#34;Series.where called&#34;)
        try:
            list_images = []
            list_paths = []
            for image in self.children:
                value = image[tag]
                if condition == &#34;==&#34;:
                    statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
                    if eval(statement) == True:
                        list_images.append(image)
                        list_paths.append(image.path)
                else:
                    statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
                    if eval(literal_eval(statement)) == True:
                        list_images.append(image)
                        list_paths.append(image.path)
            self.images = list_paths
            return self
        except Exception as e:
            print(&#39;Error in Series.where: &#39; + str(e))
            logger.exception(&#39;Error in Series.where: &#39; + str(e))

    def display(self):
        self.objWeasel.display(self)

    def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
        logger.info(&#34;Series.plot called&#34;)
        try:
            for imagePath in self.images:
                image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
                image.plot(xlabel, ylabel)
        except Exception as e:
            print(&#39;Error in Series.plot: &#39; + str(e))
            logger.exception(&#39;Error in Series.plot: &#39; + str(e))

    def Metadata(self):
        logger.info(&#34;Series.Metadata called&#34;)
        try:
            self.objWeasel.displayMetadata(self.images)
        except Exception as e:
            print(&#39;Error in Series.Metadata: &#39; + str(e))
            logger.exception(&#39;Error in Series.Metadata: &#39; + str(e))

    @property
    def SeriesUID(self):
        if not self.images:
            self.seriesUID = None
        elif os.path.exists(self.images[0]):
            self.seriesUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;SeriesInstanceUID&#39;)
        else:
            self.seriesUID = None
        return self.seriesUID

    @property
    def StudyUID(self):
        if not self.images:
            self.studyUID = None
        elif os.path.exists(self.images[0]):
            self.studyUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;StudyInstanceUID&#39;)
        else:
            self.studyUID = None
        return self.studyUID

    @property
    def Magnitude(self):
        logger.info(&#34;Series.Magnitude called&#34;)
        try:
            dicomList = self.PydicomList
            magnitudeSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            magnitudeSeries.remove(all_images=True)
            magnitudeSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                flagMagnitude, _, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagMagnitude, list) and flagMagnitude:
                #    if len(flagMagnitude) &gt; 1 and len(self.images) == 1:
                #        magnitudeSeries.indices = flagMagnitude
                #    magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagMagnitude == True:
                    magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return magnitudeSeries
        except Exception as e:
            print(&#39;Error in Series.Magnitude: &#39; + str(e))
            logger.exception(&#39;Error in Series.Magnitude: &#39; + str(e))

    @property
    def Phase(self):
        logger.info(&#34;Series.Phase called&#34;)
        try:
            dicomList = self.PydicomList
            phaseSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            phaseSeries.remove(all_images=True)
            phaseSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, flagPhase, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagPhase, list) and flagPhase:
                #    if len(flagPhase) &gt; 1 and len(self.images) == 1:
                #        phaseSeries.indices = flagPhase
                #    phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagPhase == True:
                    phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return phaseSeries
        except Exception as e:
            print(&#39;Error in Series.Phase: &#39; + str(e))
            logger.exception(&#39;Error in Series.Phase: &#39; + str(e))

    @property
    def Real(self):
        logger.info(&#34;Series.Real called&#34;)
        try:
            dicomList = self.PydicomList
            realSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            realSeries.remove(all_images=True)
            realSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, _, flagReal, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagReal, list) and flagReal:
                #    if len(flagReal) &gt; 1 and len(self.images) == 1:
                #        realSeries.indices = flagReal
                #    realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagReal:
                    realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return realSeries
        except Exception as e:
            print(&#39;Error in Series.Real: &#39; + str(e))
            logger.exception(&#39;Error in Series.Real: &#39; + str(e))

    @property
    def Imaginary(self):
        logger.info(&#34;Series.Imaginary called&#34;)
        try:
            dicomList = self.PydicomList
            imaginarySeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            imaginarySeries.remove(all_images=True)
            imaginarySeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, _, _, flagImaginary, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagImaginary, list) and flagImaginary:
                #    if len(flagImaginary) &gt; 1 and len(self.images) == 1:
                #        imaginarySeries.indices = flagImaginary
                #    imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagImaginary:
                    imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return imaginarySeries
        except Exception as e:
            print(&#39;Error in Series.Imaginary: &#39; + str(e))
            logger.exception(&#39;Error in Series.Imaginary: &#39; + str(e))

    @property
    def PixelArray(self):
        logger.info(&#34;Series.PixelArray called&#34;)
        try:
            pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.images)
            return pixelArray
        except Exception as e:
            print(&#39;Error in Series.PixelArray: &#39; + str(e))
            logger.exception(&#39;Error in Series.PixelArray: &#39; + str(e))
        
    def load_mask(self, maskInstance):
        &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
        logger.info(&#34;Series.Mask called&#34;)
        try:
            dataset = maskInstance.PydicomList
            mask_array = maskInstance.PixelArray
            mask_array[mask_array != 0] = 1
            mask_output = []
            if isinstance(maskInstance, Image):
                for dicomFile in self.images:
                    dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                    tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                    affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                    if affine_results:
                        coords = zip(*affine_results)
                        tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                    mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
                return np.nan_to_num(mask_output)
            elif isinstance(maskInstance, Series):
                listImages = self.images
                listMaskImages = maskInstance.images
                for dicomFile in listImages:
                    dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                    tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                    for maskFile in listMaskImages:
                        dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                        mask_array = ReadDICOM_Image.getPixelArray(dataset)
                        mask_array[mask_array != 0] = 1
                        affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                        if affine_results:
                            coords = zip(*affine_results)
                            tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                    mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
                return np.nan_to_num(mask_output)
        except Exception as e:
            print(&#39;Error in Series.Mask: &#39; + str(e))
            logger.exception(&#39;Error in Series.Mask: &#39; + str(e))
    
    def write_mask(self, mask_array, label=None):
        logger.info(&#34;Series.write_mask called&#34;)
        try:
            if label is not None:
                self.suffix = &#34;_&#34; + label
            self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
        except Exception as e:
            print(&#39;Error in Series.write_mask: &#39; + str(e))
            logger.exception(&#39;Error in Series.write_mask: &#39; + str(e))

    @property
    def Affine(self):
        logger.info(&#34;Series.Affine called&#34;)
        try:
            return ReadDICOM_Image.returnAffineArray(self.images[0])
        except Exception as e:
            print(&#39;Error in Series.Affine: &#39; + str(e))
            logger.exception(&#39;Error in Series.Affine: &#39; + str(e))

    @property
    def ListAffines(self):
        logger.info(&#34;Series.ListAffines called&#34;)
        try:
            return [ReadDICOM_Image.returnAffineArray(image) for image in self.images]
        except Exception as e:
            print(&#39;Error in Series.ListAffines: &#39; + str(e))
            logger.exception(&#39;Error in Series.ListAffines: &#39; + str(e))
    
    @property
    def ROIindices(self):
        logger.info(&#34;Series.ROIindices called&#34;)
        try:
            tempImage = self.PixelArray
            tempImage[tempImage != 0] = 1
            return np.transpose(np.where(tempImage == 1))
        except Exception as e:
            print(&#39;Error in Series.ROIindices: &#39; + str(e))
            logger.exception(&#39;Error in Series.ROIindices: &#39; + str(e))
    
    def get_value(self, tag):
        logger.info(&#34;Series.get_value called&#34;)
        try:
            if self.images:
                if isinstance(tag, list):
                    outputValuesList = []
                    for ind_tag in tag:
                        if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                        outputValuesList.append(ReadDICOM_Image.getSeriesTagValues(self.images, ind_tag)[0])
                    return outputValuesList
                elif isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
                    dicom_tag = tag.split(&#39; &#39;)[0]
                    if (dicom_tag == &#34;SliceLocation&#34; or dicom_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): dicom_tag = (0x2001, 0x100a)
                    logical_operator = tag.split(&#39; &#39;)[1]
                    target_value = tag.split(&#39; &#39;)[2]
                    series_to_return = copy.copy(self)
                    series_to_return.where(dicom_tag, logical_operator, target_value)
                    list_of_images = series_to_return.children
                    return list_of_images
                elif isinstance(tag, int):
                    return self.children[tag]
                else:
                    if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
                    return ReadDICOM_Image.getSeriesTagValues(self.images, tag)[0]
            else:
                return []
        except Exception as e:
            print(&#39;Error in Series.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Series.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Series.set_value called&#34;)
        try:
            if self.images:
                comparisonDicom = self.PydicomList
                oldSubjectID = self.subjectID
                oldStudyID = self.studyID
                oldSeriesID = self.seriesID
                if isinstance(tag, list) and isinstance(newValue, list):
                    for index, ind_tag in enumerate(tag):
                        self.set_value(ind_tag, newValue[index])
                        #GenericDICOMTools.editDICOMTag(self.images, ind_tag, newValue[index])
                elif isinstance(newValue, list):
                    for value in newValue:
                        GenericDICOMTools.editDICOMTag(self.images, tag, value)
                else:
                    GenericDICOMTools.editDICOMTag(self.images, tag, newValue)
                newDicomList = self.PydicomList
                # Consider the case where other XML fields are changed
                for index, dataset in enumerate(comparisonDicom):
                    changeXML = False
                    if dataset.SeriesDescription != newDicomList[index].SeriesDescription or dataset.SeriesNumber != newDicomList[index].SeriesNumber:
                        changeXML = True
                        newSeriesID = str(newDicomList[index].SeriesNumber) + &#34;_&#34; + str(newDicomList[index].SeriesDescription)
                        self.seriesID = newSeriesID
                    else:
                        newSeriesID = oldSeriesID
                    if dataset.StudyDate != newDicomList[index].StudyDate or dataset.StudyTime != newDicomList[index].StudyTime or dataset.StudyDescription != newDicomList[index].StudyDescription:
                        changeXML = True
                        newStudyID = str(newDicomList[index].StudyDate) + &#34;_&#34; + str(newDicomList[index].StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(newDicomList[index].StudyDescription)
                        self.studyID = newStudyID
                    else:
                        newStudyID = oldStudyID
                    if dataset.PatientID != newDicomList[index].PatientID:
                        changeXML = True
                        newSubjectID = str(newDicomList[index].PatientID)
                        self.subjectID = newSubjectID
                    else:
                        newSubjectID = oldSubjectID
                    if changeXML == True:
                        self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
        except Exception as e:
            print(&#39;Error in Series.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Series.set_value: &#39; + str(e))

    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        if isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
            listImages = self.get_value(tag)
            dicom_tag = tag.split(&#39; &#39;)[0]
            listImages.set_value(dicom_tag, value)
        elif isinstance(tag, int) and isinstance(value, Image):
            self.images[tag] = value.path
        else:
            self.set_value(tag, value)

    # Remove this function in the future - Careful with Subject.merge and Study.merge implications!
    def Item(self, tagDescription, newValue=None):
        if self.images:
            if newValue:
                GenericDICOMTools.editDICOMTag(self.images, tagDescription, newValue)
                if (tagDescription == &#39;SeriesDescription&#39;) or (tagDescription == &#39;SequenceName&#39;) or (tagDescription == &#39;ProtocolName&#39;):
                    self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_name=newValue)
                elif tagDescription == &#39;SeriesNumber&#39;:
                    self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_id=newValue)
            itemList, _ = ReadDICOM_Image.getSeriesTagValues(self.images, tagDescription)
            #if self.Multiframe: 
            #    tempList = [itemList[index] for index in self.indices]
            #    itemList = tempList
            #    del tempList
        else:
            itemList = []
        return itemList
    
    @property
    def PydicomList(self):
        if self.images:
            return PixelArrayDICOMTools.getDICOMobject(self.images)
        else:
            return []
    
    #@property
    #def Multiframe(self):
    #    if self.indices:
    #        return True
    #    else:
    #        return False

    def export_as_nifti(self, directory=None, filename=None):
        logger.info(&#34;Series.export_as_nifti called&#34;)
        try:
            if directory is None: directory=os.path.dirname(self.images[0])
            if filename is None: filename=self.seriesID
            dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomList[0])
            niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), self.Affine)
            # The transpose is necessary in this case to be in line with the rest of Weasel. The rot90() can be a bit questionable, so this should be tested in as much data as possible.
            niftiObj.header.extensions.append(dicomHeader)
            nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
        except Exception as e:
            print(&#39;Error in Series.export_as_nifti: &#39; + str(e))
            logger.exception(&#39;Error in Series.export_as_nifti: &#39; + str(e))
    
    def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
        logger.info(&#34;Series.export_as_csv called&#34;)
        try:
            if directory is None: directory = os.path.dirname(self.images[0])
            if self.number_children == 1:
                self.children[0].export_as_csv(directory=directory, filename=filename, columnHeaders=columnHeaders)
            else:
                table = self.PixelArray
                image_counter = 0
                for slice_image in table:
                    if filename is None:
                        one_filename = os.path.join(directory, self.seriesID + &#39;_&#39; + str(image_counter).zfill(6) + &#39;.csv&#39;)
                    else:
                        one_filename = os.path.join(directory, filename + &#39;_&#39; + str(image_counter).zfill(6) +&#39;.csv&#39;)
                    if columnHeaders is None:
                        one_columHeaders = []
                        counter = 0
                        for _ in slice_image:
                            counter += 1
                            one_columHeaders.append(&#34;Column&#34; + str(counter))
                    df = pd.DataFrame(np.transpose(slice_image), columns=one_columHeaders)
                    df.to_csv(one_filename, index=False)
                    image_counter += 1
        except Exception as e:
            print(&#39;Error in Series.export_as_csv: &#39; + str(e))
            logger.exception(&#39;Error in Series.export_as_csv: &#39; + str(e))


class Image:
    &#34;&#34;&#34;This class corresponds to 1 DICOM file that belongs to its parent Subject, Study and Series.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        seriesID : string
            This is the name or identification of the series, which is stored in the &#34;SeriesDescription&#34; DICOM tag.
        path : string
            This is the file path to the DICOM file represented in this Image() class.
        suffix : string (optional)
            This is the text to append to subjectID if a new Image() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;seriesID&#39;, &#39;path&#39;, &#39;seriesUID&#39;,
                 &#39;studyUID&#39;, &#39;suffix&#39;, &#39;referencePath&#39;)
    def __init__(self, objWeasel, subjectID, studyID, seriesID, path, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.seriesID = seriesID
        self.path = path
        self.seriesUID = self.SeriesUID
        self.studyUID = self.StudyUID
        self.suffix = &#39;&#39; if suffix is None else suffix
        self.referencePath = &#39;&#39;

    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def parent(self):
        logger.info(&#34;Image.parent called&#34;)
        try:
            temp_series = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, studyUID=self.studyUID, seriesUID=self.seriesUID)
            paths = []
            images_of_series = temp_series.children
            for image in images_of_series:
                paths.append(image.path)
            del temp_series, images_of_series
            return Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=paths, studyUID=self.studyUID, seriesUID=self.seriesUID)
        except Exception as e:
            print(&#39;Error in Image.parent: &#39; + str(e))
            logger.exception(&#39;Error in Image.parent: &#39; + str(e))
    
    @staticmethod
    def newSeriesFrom(listImages, suffix=&#39;_Copy&#39;, series_id=None, series_name=None, series_uid=None):
        logger.info(&#34;Image.newSeriesFrom called&#34;)
        try:
            pathsList = [image.path for image in listImages]
            if series_id is None:
                series_id, _ = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList)
            if series_name is None:
                series_name = listImages[0].seriesID.split(&#39;_&#39;, 1)[1] + suffix
            if series_uid is None:
                _, series_uid = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList, seriesNumber=series_id)
            seriesID = str(series_id) + &#39;_&#39; + series_name
            newSeries = Series(listImages[0].objWeasel, listImages[0].subjectID, listImages[0].studyID, seriesID, seriesUID=series_uid, suffix=suffix)
            newSeries.referencePathsList = pathsList
            return newSeries
        except Exception as e:
            print(&#39;Error in Image.newSeriesFrom: &#39; + str(e))
            logger.exception(&#39;Error in Image.newSeriesFrom: &#39; + str(e))
        
    @property
    def label(self):
        logger.info(&#34;Image.label called&#34;)
        try:
            return self.objWeasel.objXMLReader.getImageLabel(self.subjectID, self.studyID, self.seriesID, imageName=self.path)
            #return self.objWeasel.treeView.returnImageName(self.subjectID, self.studyID, self.seriesID, self.path)
        except Exception as e:
            print(&#39;Error in Image.label: &#39; + str(e))
            logger.exception(&#39;Error in Image.label: &#39; + str(e))

    def new(self, suffix=&#39;_Copy&#39;, series=None):
        logger.info(&#34;Image.new called&#34;)
        try:
            if series is None:
                newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, &#39;&#39;, suffix=suffix)
            else:
                newImage = Image(series.objWeasel, series.subjectID, series.studyID, series.seriesID, &#39;&#39;, suffix=suffix)
            newImage.referencePath = self.path
            return newImage
        except Exception as e:
            print(&#39;Error in Image.new: &#39; + str(e))
            logger.exception(&#39;Error in Image.new: &#39; + str(e))

    def copy(self, suffix=&#39;_Copy&#39;, series=None, output_dir=None):
        logger.info(&#34;Image.copy called&#34;)
        try:
            if series is None:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = self.seriesUID
                #suffix = self.suffix
            else:
                series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = series.seriesUID
                suffix = series.suffix
            newPath, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.path, series_id=series_id, series_uid=series_uid, series_name=series_name, suffix=suffix, output_dir=output_dir)
            copiedImage = Image(self.objWeasel, self.subjectID, self.studyID, newSeriesID, newPath, suffix=suffix)
            if series: series.add(copiedImage)
            return copiedImage
        except Exception as e:
            print(&#39;Error in Image.copy: &#39; + str(e))
            logger.exception(&#39;Error in Image.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Image.delete called&#34;)
        try:
            GenericDICOMTools.deleteDICOM(self.objWeasel, self.path)
            self.path = []
            self.referencePath = []
            self.subjectID = self.studyID = self.seriesID = &#39;&#39;
            # Delete the instance, such as del self???
        except Exception as e:
            print(&#39;Error in Image.delete: &#39; + str(e))
            logger.exception(&#39;Error in Image.delete: &#39; + str(e))

    def write(self, pixelArray, series=None, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
        logger.info(&#34;Image.write called&#34;)
        try:
            if isinstance(value_range, list):
                pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
            else:
                list_values = np.unique(pixelArray).flatten()
                list_values = [x for x in list_values if np.isnan(x) == False]
                if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                    upper_value = list_values[-2]
                else:
                    upper_value = None
                if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                    lower_value = list_values[1]
                else:
                    lower_value = None
                pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
            if os.path.exists(self.path):
                PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.path) # Include Colourmap and Parametric Map
            else:
                if series is None:
                    series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                    series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                    series_uid = self.seriesUID
                else:
                    series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
                    series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
                    series_uid = series.seriesUID
                outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, self.referencePath, self.suffix, series_id=series_id, series_name=series_name, series_uid=series_uid, parametric_map=parametric_map, output_dir=output_dir, colourmap=colourmap)
                self.path = outputPath[0]
                if series: series.add(self)
        except Exception as e:
            print(&#39;Error in Image.write: &#39; + str(e))
            logger.exception(&#39;Error in Image.write: &#39; + str(e))
        
    def read(self):
        return self.PydicomObject

    def save(self, PydicomObject):
        changeXML = False
        newSubjectID = self.subjectID
        newStudyID = self.studyID
        newSeriesID = self.seriesID
        if PydicomObject.SeriesDescription != self.PydicomObject.SeriesDescription or PydicomObject.SeriesNumber != self.PydicomObject.SeriesNumber:
            changeXML = True
            newSeriesID = str(PydicomObject.SeriesNumber) + &#34;_&#34; + str(PydicomObject.SeriesDescription)
        if PydicomObject.StudyDate != self.PydicomObject.StudyDate or PydicomObject.StudyTime != self.PydicomObject.StudyTime or PydicomObject.StudyDescription != self.PydicomObject.StudyDescription:
            changeXML = True
            newStudyID = str(PydicomObject.StudyDate) + &#34;_&#34; + str(PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(PydicomObject.StudyDescription)
        if PydicomObject.PatientID != self.PydicomObject.PatientID:
            changeXML = True
            newSubjectID = str(PydicomObject.PatientID)
        SaveDICOM_Image.saveDicomToFile(PydicomObject, output_path=self.path)
        if changeXML == True:
            self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
        # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
        self.subjectID = newSubjectID
        self.studyID = newStudyID
        self.seriesID = newSeriesID

    @staticmethod
    def merge(listImages, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
        logger.info(&#34;Image.merge called&#34;)
        try:
            outputSeries = Image.newSeriesFrom(listImages, suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)    
            outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, outputSeries.referencePathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
            outputSeries.images = outputPathList
            return outputSeries
        except Exception as e:
            print(&#39;Error in Image.merge: &#39; + str(e))
            logger.exception(&#39;Error in Image.merge: &#39; + str(e))
    
    def display(self):
        self.objWeasel.display(self)


    def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
        logger.info(&#34;Image.plot called&#34;)
        try:
            self.objWeasel.plot(self.path, self.seriesID, self.PixelArray[0], self.PixelArray[1], xlabel, ylabel)
        except Exception as e:
            print(&#39;Error in Image.plot: &#39; + str(e))
            logger.exception(&#39;Error in Image.plot: &#39; + str(e))

    @property
    def SeriesUID(self):
        if not self.path:
            self.seriesUID = None
        elif os.path.exists(self.path):
            self.seriesUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;SeriesInstanceUID&#39;)
        else:
            self.seriesUID = None
        return self.seriesUID
    
    @property
    def StudyUID(self):
        if not self.path:
            self.studyUID = None
        elif os.path.exists(self.path):
            self.studyUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;StudyInstanceUID&#39;)
        else:
            self.studyUID = None
        return self.studyUID
    
    def Metadata(self):
        logger.info(&#34;Image.Metadata called&#34;)
        try:
            self.objWeasel.displayMetadata(self.path)
        except Exception as e:
            print(&#39;Error in Image.Metadata: &#39; + str(e))
            logger.exception(&#39;Error in Image.Metadata: &#39; + str(e))

    @property
    def PixelArray(self):
        logger.info(&#34;Image.PixelArray called&#34;)
        try:
            pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.path)
            return pixelArray
        except Exception as e:
            print(&#39;Error in Image.PixelArray: &#39; + str(e))
            logger.exception(&#39;Error in Image.PixelArray: &#39; + str(e))

    def load_mask(self, maskInstance):
        &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
        logger.info(&#34;Image.Mask called&#34;)
        try:
            if isinstance(maskInstance, Image):
                #for index, dicomFile in enumerate(targetPath):
                tempArray = np.zeros(np.shape(self.PixelArray))
                dataset_original = self.PydicomObject
                dataset = maskInstance.PydicomObject
                mask_array = maskInstance.PixelArray
                mask_array[mask_array != 0] = 1
                affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                if affine_results:
                    coords = zip(*affine_results)
                    tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                return np.transpose(tempArray) * self.PixelArray
            elif isinstance(maskInstance, Series):
                tempArray = np.zeros(np.shape(self.PixelArray))
                for maskFile in maskInstance.images:
                    dataset_original = self.PydicomObject
                    dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                    mask_array = ReadDICOM_Image.getPixelArray(dataset)
                    mask_array[mask_array != 0] = 1
                    affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                    if affine_results:
                        coords = zip(*affine_results)
                        tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                return np.transpose(tempArray) * self.PixelArray
        except Exception as e:
            print(&#39;Error in Image.Mask: &#39; + str(e))
            logger.exception(&#39;Error in Image.Mask: &#39; + str(e))

    def write_mask(self, mask_array, label=None):
        logger.info(&#34;Image.write_mask called&#34;)
        try:
            if label is not None:
                self.suffix = &#34;_&#34; + label
            self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
        except Exception as e:
            print(&#39;Error in Image.write_mask: &#39; + str(e))
            logger.exception(&#39;Error in Image.write_mask: &#39; + str(e))
    
    @property
    def ROIindices(self):
        logger.info(&#34;Image.ROIindices called&#34;)
        try:
            tempImage = self.PixelArray
            tempImage[tempImage != 0] = 1
            return np.transpose(np.where(tempImage == 1))
        except Exception as e:
            print(&#39;Error in Image.ROIindices: &#39; + str(e))
            logger.exception(&#39;Error in Image.ROIindices: &#39; + str(e))

    @property
    def Affine(self):
        logger.info(&#34;Image.Affine called&#34;)
        try:
            return ReadDICOM_Image.returnAffineArray(self.path)
        except Exception as e:
            print(&#39;Error in Image.Affine: &#39; + str(e))
            logger.exception(&#39;Error in Image.Affine: &#39; + str(e))
    
    def get_value(self, tag):
        logger.info(&#34;Image.get_value called&#34;)
        try:
            if isinstance(tag, list):
                outputValuesList = []
                for ind_tag in tag:
                    if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                    outputValuesList.append(ReadDICOM_Image.getImageTagValue(self.path, ind_tag))
                return outputValuesList
            else:
                if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
                return ReadDICOM_Image.getImageTagValue(self.path, tag)
        except Exception as e:
            print(&#39;Error in Image.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Image.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Image.set_value called&#34;)
        try:
            comparisonDicom = self.PydicomObject
            changeXML = False
            # Not necessary new IDs, but they may be new. The changeXML flag coordinates that.
            oldSubjectID = self.subjectID
            oldStudyID = self.studyID
            oldSeriesID = self.seriesID
            # Set tag commands
            if isinstance(tag, list) and isinstance(newValue, list):
                for index, ind_tag in enumerate(tag):
                    GenericDICOMTools.editDICOMTag(self.path, ind_tag, newValue[index])
            else:
                GenericDICOMTools.editDICOMTag(self.path, tag, newValue)
            # Consider the case where XML fields are changed
            if comparisonDicom.SeriesDescription != self.PydicomObject.SeriesDescription or comparisonDicom.SeriesNumber != self.PydicomObject.SeriesNumber:
                changeXML = True
                newSeriesID = str(self.PydicomObject.SeriesNumber) + &#34;_&#34; + str(self.PydicomObject.SeriesDescription)
                self.seriesID = newSeriesID
            else:
                newSeriesID = oldSeriesID
            if comparisonDicom.StudyDate != self.PydicomObject.StudyDate or comparisonDicom.StudyTime != self.PydicomObject.StudyTime or comparisonDicom.StudyDescription != self.PydicomObject.StudyDescription:
                changeXML = True
                newStudyID = str(self.PydicomObject.StudyDate) + &#34;_&#34; + str(self.PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(self.PydicomObject.StudyDescription)
                self.studyID = newStudyID
            else:
                newStudyID = oldStudyID
            if comparisonDicom.PatientID != self.PydicomObject.PatientID:
                changeXML = True
                newSubjectID = str(self.PydicomObject.PatientID)
                self.subjectID = newSubjectID
            else:
                newSubjectID = oldSubjectID
            if changeXML == True:
                self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
        except Exception as e:
            print(&#39;Error in Image.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Image.set_value: &#39; + str(e))
        
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)

    @property
    def PydicomObject(self):
        if self.path:
            return PixelArrayDICOMTools.getDICOMobject(self.path)
        else:
            return []

    def export_as_nifti(self, directory=None, filename=None):
        logger.info(&#34;Image.export_as_nifti called&#34;)
        try:
            if directory is None: directory=os.path.dirname(self.path)
            if filename is None: filename=self.seriesID
            dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomObject)
            niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), affine=self.Affine)
            # The transpose is necessary in this case to be in line with the rest of Weasel.
            niftiObj.header.extensions.append(dicomHeader)
            nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
        except Exception as e:
            print(&#39;Error in Image.export_as_nifti: &#39; + str(e))
            logger.exception(&#39;Error in Image.export_as_nifti: &#39; + str(e))

    def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
        logger.info(&#34;Image.export_as_csv called&#34;)
        try:
            if directory is None: directory = os.path.dirname(self.images[0])
            if filename is None:
                filename = os.path.join(directory, self.seriesID + &#39;.csv&#39;)
            else:
                filename = os.path.join(directory, filename + &#39;.csv&#39;)
            table = self.PixelArray
            if columnHeaders is None:
                columnHeaders = []
                counter = 0
                for _ in table:
                    counter += 1
                    columnHeaders.append(&#34;Column&#34; + str(counter))
            df = pd.DataFrame(np.transpose(table), columns=columnHeaders)
            df.to_csv(filename, index=False)
        except Exception as e:
            print(&#39;Error in Image.export_as_csv: &#39; + str(e))
            logger.exception(&#39;Error in Image.export_as_csv: &#39; + str(e))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Weasel.DICOM.Classes.Image"><code class="flex name class">
<span>class <span class="ident">Image</span></span>
<span>(</span><span>objWeasel, subjectID, studyID, seriesID, path, suffix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class corresponds to 1 DICOM file that belongs to its parent Subject, Study and Series.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objWeasel</code></strong> :&ensp;<code>the <a title="Weasel" href="../index.html">Weasel</a> global variable</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>subjectID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the subject, which is stored in the "PatientID" DICOM tag.</dd>
<dt><strong><code>studyID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the study, which is stored in the "StudyDescription" DICOM tag.</dd>
<dt><strong><code>seriesID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the series, which is stored in the "SeriesDescription" DICOM tag.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the file path to the DICOM file represented in this Image() class.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the text to append to subjectID if a new Image() class is created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Image:
    &#34;&#34;&#34;This class corresponds to 1 DICOM file that belongs to its parent Subject, Study and Series.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        seriesID : string
            This is the name or identification of the series, which is stored in the &#34;SeriesDescription&#34; DICOM tag.
        path : string
            This is the file path to the DICOM file represented in this Image() class.
        suffix : string (optional)
            This is the text to append to subjectID if a new Image() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;seriesID&#39;, &#39;path&#39;, &#39;seriesUID&#39;,
                 &#39;studyUID&#39;, &#39;suffix&#39;, &#39;referencePath&#39;)
    def __init__(self, objWeasel, subjectID, studyID, seriesID, path, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.seriesID = seriesID
        self.path = path
        self.seriesUID = self.SeriesUID
        self.studyUID = self.StudyUID
        self.suffix = &#39;&#39; if suffix is None else suffix
        self.referencePath = &#39;&#39;

    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def parent(self):
        logger.info(&#34;Image.parent called&#34;)
        try:
            temp_series = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, studyUID=self.studyUID, seriesUID=self.seriesUID)
            paths = []
            images_of_series = temp_series.children
            for image in images_of_series:
                paths.append(image.path)
            del temp_series, images_of_series
            return Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=paths, studyUID=self.studyUID, seriesUID=self.seriesUID)
        except Exception as e:
            print(&#39;Error in Image.parent: &#39; + str(e))
            logger.exception(&#39;Error in Image.parent: &#39; + str(e))
    
    @staticmethod
    def newSeriesFrom(listImages, suffix=&#39;_Copy&#39;, series_id=None, series_name=None, series_uid=None):
        logger.info(&#34;Image.newSeriesFrom called&#34;)
        try:
            pathsList = [image.path for image in listImages]
            if series_id is None:
                series_id, _ = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList)
            if series_name is None:
                series_name = listImages[0].seriesID.split(&#39;_&#39;, 1)[1] + suffix
            if series_uid is None:
                _, series_uid = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList, seriesNumber=series_id)
            seriesID = str(series_id) + &#39;_&#39; + series_name
            newSeries = Series(listImages[0].objWeasel, listImages[0].subjectID, listImages[0].studyID, seriesID, seriesUID=series_uid, suffix=suffix)
            newSeries.referencePathsList = pathsList
            return newSeries
        except Exception as e:
            print(&#39;Error in Image.newSeriesFrom: &#39; + str(e))
            logger.exception(&#39;Error in Image.newSeriesFrom: &#39; + str(e))
        
    @property
    def label(self):
        logger.info(&#34;Image.label called&#34;)
        try:
            return self.objWeasel.objXMLReader.getImageLabel(self.subjectID, self.studyID, self.seriesID, imageName=self.path)
            #return self.objWeasel.treeView.returnImageName(self.subjectID, self.studyID, self.seriesID, self.path)
        except Exception as e:
            print(&#39;Error in Image.label: &#39; + str(e))
            logger.exception(&#39;Error in Image.label: &#39; + str(e))

    def new(self, suffix=&#39;_Copy&#39;, series=None):
        logger.info(&#34;Image.new called&#34;)
        try:
            if series is None:
                newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, &#39;&#39;, suffix=suffix)
            else:
                newImage = Image(series.objWeasel, series.subjectID, series.studyID, series.seriesID, &#39;&#39;, suffix=suffix)
            newImage.referencePath = self.path
            return newImage
        except Exception as e:
            print(&#39;Error in Image.new: &#39; + str(e))
            logger.exception(&#39;Error in Image.new: &#39; + str(e))

    def copy(self, suffix=&#39;_Copy&#39;, series=None, output_dir=None):
        logger.info(&#34;Image.copy called&#34;)
        try:
            if series is None:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = self.seriesUID
                #suffix = self.suffix
            else:
                series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = series.seriesUID
                suffix = series.suffix
            newPath, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.path, series_id=series_id, series_uid=series_uid, series_name=series_name, suffix=suffix, output_dir=output_dir)
            copiedImage = Image(self.objWeasel, self.subjectID, self.studyID, newSeriesID, newPath, suffix=suffix)
            if series: series.add(copiedImage)
            return copiedImage
        except Exception as e:
            print(&#39;Error in Image.copy: &#39; + str(e))
            logger.exception(&#39;Error in Image.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Image.delete called&#34;)
        try:
            GenericDICOMTools.deleteDICOM(self.objWeasel, self.path)
            self.path = []
            self.referencePath = []
            self.subjectID = self.studyID = self.seriesID = &#39;&#39;
            # Delete the instance, such as del self???
        except Exception as e:
            print(&#39;Error in Image.delete: &#39; + str(e))
            logger.exception(&#39;Error in Image.delete: &#39; + str(e))

    def write(self, pixelArray, series=None, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
        logger.info(&#34;Image.write called&#34;)
        try:
            if isinstance(value_range, list):
                pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
            else:
                list_values = np.unique(pixelArray).flatten()
                list_values = [x for x in list_values if np.isnan(x) == False]
                if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                    upper_value = list_values[-2]
                else:
                    upper_value = None
                if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                    lower_value = list_values[1]
                else:
                    lower_value = None
                pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
            if os.path.exists(self.path):
                PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.path) # Include Colourmap and Parametric Map
            else:
                if series is None:
                    series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                    series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                    series_uid = self.seriesUID
                else:
                    series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
                    series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
                    series_uid = series.seriesUID
                outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, self.referencePath, self.suffix, series_id=series_id, series_name=series_name, series_uid=series_uid, parametric_map=parametric_map, output_dir=output_dir, colourmap=colourmap)
                self.path = outputPath[0]
                if series: series.add(self)
        except Exception as e:
            print(&#39;Error in Image.write: &#39; + str(e))
            logger.exception(&#39;Error in Image.write: &#39; + str(e))
        
    def read(self):
        return self.PydicomObject

    def save(self, PydicomObject):
        changeXML = False
        newSubjectID = self.subjectID
        newStudyID = self.studyID
        newSeriesID = self.seriesID
        if PydicomObject.SeriesDescription != self.PydicomObject.SeriesDescription or PydicomObject.SeriesNumber != self.PydicomObject.SeriesNumber:
            changeXML = True
            newSeriesID = str(PydicomObject.SeriesNumber) + &#34;_&#34; + str(PydicomObject.SeriesDescription)
        if PydicomObject.StudyDate != self.PydicomObject.StudyDate or PydicomObject.StudyTime != self.PydicomObject.StudyTime or PydicomObject.StudyDescription != self.PydicomObject.StudyDescription:
            changeXML = True
            newStudyID = str(PydicomObject.StudyDate) + &#34;_&#34; + str(PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(PydicomObject.StudyDescription)
        if PydicomObject.PatientID != self.PydicomObject.PatientID:
            changeXML = True
            newSubjectID = str(PydicomObject.PatientID)
        SaveDICOM_Image.saveDicomToFile(PydicomObject, output_path=self.path)
        if changeXML == True:
            self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
        # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
        self.subjectID = newSubjectID
        self.studyID = newStudyID
        self.seriesID = newSeriesID

    @staticmethod
    def merge(listImages, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
        logger.info(&#34;Image.merge called&#34;)
        try:
            outputSeries = Image.newSeriesFrom(listImages, suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)    
            outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, outputSeries.referencePathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
            outputSeries.images = outputPathList
            return outputSeries
        except Exception as e:
            print(&#39;Error in Image.merge: &#39; + str(e))
            logger.exception(&#39;Error in Image.merge: &#39; + str(e))
    
    def display(self):
        self.objWeasel.display(self)


    def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
        logger.info(&#34;Image.plot called&#34;)
        try:
            self.objWeasel.plot(self.path, self.seriesID, self.PixelArray[0], self.PixelArray[1], xlabel, ylabel)
        except Exception as e:
            print(&#39;Error in Image.plot: &#39; + str(e))
            logger.exception(&#39;Error in Image.plot: &#39; + str(e))

    @property
    def SeriesUID(self):
        if not self.path:
            self.seriesUID = None
        elif os.path.exists(self.path):
            self.seriesUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;SeriesInstanceUID&#39;)
        else:
            self.seriesUID = None
        return self.seriesUID
    
    @property
    def StudyUID(self):
        if not self.path:
            self.studyUID = None
        elif os.path.exists(self.path):
            self.studyUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;StudyInstanceUID&#39;)
        else:
            self.studyUID = None
        return self.studyUID
    
    def Metadata(self):
        logger.info(&#34;Image.Metadata called&#34;)
        try:
            self.objWeasel.displayMetadata(self.path)
        except Exception as e:
            print(&#39;Error in Image.Metadata: &#39; + str(e))
            logger.exception(&#39;Error in Image.Metadata: &#39; + str(e))

    @property
    def PixelArray(self):
        logger.info(&#34;Image.PixelArray called&#34;)
        try:
            pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.path)
            return pixelArray
        except Exception as e:
            print(&#39;Error in Image.PixelArray: &#39; + str(e))
            logger.exception(&#39;Error in Image.PixelArray: &#39; + str(e))

    def load_mask(self, maskInstance):
        &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
        logger.info(&#34;Image.Mask called&#34;)
        try:
            if isinstance(maskInstance, Image):
                #for index, dicomFile in enumerate(targetPath):
                tempArray = np.zeros(np.shape(self.PixelArray))
                dataset_original = self.PydicomObject
                dataset = maskInstance.PydicomObject
                mask_array = maskInstance.PixelArray
                mask_array[mask_array != 0] = 1
                affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                if affine_results:
                    coords = zip(*affine_results)
                    tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                return np.transpose(tempArray) * self.PixelArray
            elif isinstance(maskInstance, Series):
                tempArray = np.zeros(np.shape(self.PixelArray))
                for maskFile in maskInstance.images:
                    dataset_original = self.PydicomObject
                    dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                    mask_array = ReadDICOM_Image.getPixelArray(dataset)
                    mask_array[mask_array != 0] = 1
                    affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                    if affine_results:
                        coords = zip(*affine_results)
                        tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                return np.transpose(tempArray) * self.PixelArray
        except Exception as e:
            print(&#39;Error in Image.Mask: &#39; + str(e))
            logger.exception(&#39;Error in Image.Mask: &#39; + str(e))

    def write_mask(self, mask_array, label=None):
        logger.info(&#34;Image.write_mask called&#34;)
        try:
            if label is not None:
                self.suffix = &#34;_&#34; + label
            self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
        except Exception as e:
            print(&#39;Error in Image.write_mask: &#39; + str(e))
            logger.exception(&#39;Error in Image.write_mask: &#39; + str(e))
    
    @property
    def ROIindices(self):
        logger.info(&#34;Image.ROIindices called&#34;)
        try:
            tempImage = self.PixelArray
            tempImage[tempImage != 0] = 1
            return np.transpose(np.where(tempImage == 1))
        except Exception as e:
            print(&#39;Error in Image.ROIindices: &#39; + str(e))
            logger.exception(&#39;Error in Image.ROIindices: &#39; + str(e))

    @property
    def Affine(self):
        logger.info(&#34;Image.Affine called&#34;)
        try:
            return ReadDICOM_Image.returnAffineArray(self.path)
        except Exception as e:
            print(&#39;Error in Image.Affine: &#39; + str(e))
            logger.exception(&#39;Error in Image.Affine: &#39; + str(e))
    
    def get_value(self, tag):
        logger.info(&#34;Image.get_value called&#34;)
        try:
            if isinstance(tag, list):
                outputValuesList = []
                for ind_tag in tag:
                    if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                    outputValuesList.append(ReadDICOM_Image.getImageTagValue(self.path, ind_tag))
                return outputValuesList
            else:
                if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
                return ReadDICOM_Image.getImageTagValue(self.path, tag)
        except Exception as e:
            print(&#39;Error in Image.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Image.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Image.set_value called&#34;)
        try:
            comparisonDicom = self.PydicomObject
            changeXML = False
            # Not necessary new IDs, but they may be new. The changeXML flag coordinates that.
            oldSubjectID = self.subjectID
            oldStudyID = self.studyID
            oldSeriesID = self.seriesID
            # Set tag commands
            if isinstance(tag, list) and isinstance(newValue, list):
                for index, ind_tag in enumerate(tag):
                    GenericDICOMTools.editDICOMTag(self.path, ind_tag, newValue[index])
            else:
                GenericDICOMTools.editDICOMTag(self.path, tag, newValue)
            # Consider the case where XML fields are changed
            if comparisonDicom.SeriesDescription != self.PydicomObject.SeriesDescription or comparisonDicom.SeriesNumber != self.PydicomObject.SeriesNumber:
                changeXML = True
                newSeriesID = str(self.PydicomObject.SeriesNumber) + &#34;_&#34; + str(self.PydicomObject.SeriesDescription)
                self.seriesID = newSeriesID
            else:
                newSeriesID = oldSeriesID
            if comparisonDicom.StudyDate != self.PydicomObject.StudyDate or comparisonDicom.StudyTime != self.PydicomObject.StudyTime or comparisonDicom.StudyDescription != self.PydicomObject.StudyDescription:
                changeXML = True
                newStudyID = str(self.PydicomObject.StudyDate) + &#34;_&#34; + str(self.PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(self.PydicomObject.StudyDescription)
                self.studyID = newStudyID
            else:
                newStudyID = oldStudyID
            if comparisonDicom.PatientID != self.PydicomObject.PatientID:
                changeXML = True
                newSubjectID = str(self.PydicomObject.PatientID)
                self.subjectID = newSubjectID
            else:
                newSubjectID = oldSubjectID
            if changeXML == True:
                self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
        except Exception as e:
            print(&#39;Error in Image.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Image.set_value: &#39; + str(e))
        
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)

    @property
    def PydicomObject(self):
        if self.path:
            return PixelArrayDICOMTools.getDICOMobject(self.path)
        else:
            return []

    def export_as_nifti(self, directory=None, filename=None):
        logger.info(&#34;Image.export_as_nifti called&#34;)
        try:
            if directory is None: directory=os.path.dirname(self.path)
            if filename is None: filename=self.seriesID
            dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomObject)
            niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), affine=self.Affine)
            # The transpose is necessary in this case to be in line with the rest of Weasel.
            niftiObj.header.extensions.append(dicomHeader)
            nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
        except Exception as e:
            print(&#39;Error in Image.export_as_nifti: &#39; + str(e))
            logger.exception(&#39;Error in Image.export_as_nifti: &#39; + str(e))

    def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
        logger.info(&#34;Image.export_as_csv called&#34;)
        try:
            if directory is None: directory = os.path.dirname(self.images[0])
            if filename is None:
                filename = os.path.join(directory, self.seriesID + &#39;.csv&#39;)
            else:
                filename = os.path.join(directory, filename + &#39;.csv&#39;)
            table = self.PixelArray
            if columnHeaders is None:
                columnHeaders = []
                counter = 0
                for _ in table:
                    counter += 1
                    columnHeaders.append(&#34;Column&#34; + str(counter))
            df = pd.DataFrame(np.transpose(table), columns=columnHeaders)
            df.to_csv(filename, index=False)
        except Exception as e:
            print(&#39;Error in Image.export_as_csv: &#39; + str(e))
            logger.exception(&#39;Error in Image.export_as_csv: &#39; + str(e))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Image.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>listImages, series_id=None, series_name='NewSeries', series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix='_Merged', overwrite=False, progress_bar=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def merge(listImages, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
    logger.info(&#34;Image.merge called&#34;)
    try:
        outputSeries = Image.newSeriesFrom(listImages, suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)    
        outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, outputSeries.referencePathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
        outputSeries.images = outputPathList
        return outputSeries
    except Exception as e:
        print(&#39;Error in Image.merge: &#39; + str(e))
        logger.exception(&#39;Error in Image.merge: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.newSeriesFrom"><code class="name flex">
<span>def <span class="ident">newSeriesFrom</span></span>(<span>listImages, suffix='_Copy', series_id=None, series_name=None, series_uid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def newSeriesFrom(listImages, suffix=&#39;_Copy&#39;, series_id=None, series_name=None, series_uid=None):
    logger.info(&#34;Image.newSeriesFrom called&#34;)
    try:
        pathsList = [image.path for image in listImages]
        if series_id is None:
            series_id, _ = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList)
        if series_name is None:
            series_name = listImages[0].seriesID.split(&#39;_&#39;, 1)[1] + suffix
        if series_uid is None:
            _, series_uid = GenericDICOMTools.generateSeriesIDs(listImages[0].objWeasel, pathsList, seriesNumber=series_id)
        seriesID = str(series_id) + &#39;_&#39; + series_name
        newSeries = Series(listImages[0].objWeasel, listImages[0].subjectID, listImages[0].studyID, seriesID, seriesUID=series_uid, suffix=suffix)
        newSeries.referencePathsList = pathsList
        return newSeries
    except Exception as e:
        print(&#39;Error in Image.newSeriesFrom: &#39; + str(e))
        logger.exception(&#39;Error in Image.newSeriesFrom: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Image.Affine"><code class="name">var <span class="ident">Affine</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Affine(self):
    logger.info(&#34;Image.Affine called&#34;)
    try:
        return ReadDICOM_Image.returnAffineArray(self.path)
    except Exception as e:
        print(&#39;Error in Image.Affine: &#39; + str(e))
        logger.exception(&#39;Error in Image.Affine: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.PixelArray"><code class="name">var <span class="ident">PixelArray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PixelArray(self):
    logger.info(&#34;Image.PixelArray called&#34;)
    try:
        pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.path)
        return pixelArray
    except Exception as e:
        print(&#39;Error in Image.PixelArray: &#39; + str(e))
        logger.exception(&#39;Error in Image.PixelArray: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.PydicomObject"><code class="name">var <span class="ident">PydicomObject</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PydicomObject(self):
    if self.path:
        return PixelArrayDICOMTools.getDICOMobject(self.path)
    else:
        return []</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.ROIindices"><code class="name">var <span class="ident">ROIindices</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ROIindices(self):
    logger.info(&#34;Image.ROIindices called&#34;)
    try:
        tempImage = self.PixelArray
        tempImage[tempImage != 0] = 1
        return np.transpose(np.where(tempImage == 1))
    except Exception as e:
        print(&#39;Error in Image.ROIindices: &#39; + str(e))
        logger.exception(&#39;Error in Image.ROIindices: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.SeriesUID"><code class="name">var <span class="ident">SeriesUID</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def SeriesUID(self):
    if not self.path:
        self.seriesUID = None
    elif os.path.exists(self.path):
        self.seriesUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;SeriesInstanceUID&#39;)
    else:
        self.seriesUID = None
    return self.seriesUID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.StudyUID"><code class="name">var <span class="ident">StudyUID</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def StudyUID(self):
    if not self.path:
        self.studyUID = None
    elif os.path.exists(self.path):
        self.studyUID = ReadDICOM_Image.getImageTagValue(self.path, &#39;StudyInstanceUID&#39;)
    else:
        self.studyUID = None
    return self.studyUID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    logger.info(&#34;Image.label called&#34;)
    try:
        return self.objWeasel.objXMLReader.getImageLabel(self.subjectID, self.studyID, self.seriesID, imageName=self.path)
        #return self.objWeasel.treeView.returnImageName(self.subjectID, self.studyID, self.seriesID, self.path)
    except Exception as e:
        print(&#39;Error in Image.label: &#39; + str(e))
        logger.exception(&#39;Error in Image.label: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.objWeasel"><code class="name">var <span class="ident">objWeasel</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    logger.info(&#34;Image.parent called&#34;)
    try:
        temp_series = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, studyUID=self.studyUID, seriesUID=self.seriesUID)
        paths = []
        images_of_series = temp_series.children
        for image in images_of_series:
            paths.append(image.path)
        del temp_series, images_of_series
        return Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=paths, studyUID=self.studyUID, seriesUID=self.seriesUID)
    except Exception as e:
        print(&#39;Error in Image.parent: &#39; + str(e))
        logger.exception(&#39;Error in Image.parent: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.referencePath"><code class="name">var <span class="ident">referencePath</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.seriesID"><code class="name">var <span class="ident">seriesID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.seriesUID"><code class="name">var <span class="ident">seriesUID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.studyID"><code class="name">var <span class="ident">studyID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.studyUID"><code class="name">var <span class="ident">studyUID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.subjectID"><code class="name">var <span class="ident">subjectID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Image.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Image.Metadata"><code class="name flex">
<span>def <span class="ident">Metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Metadata(self):
    logger.info(&#34;Image.Metadata called&#34;)
    try:
        self.objWeasel.displayMetadata(self.path)
    except Exception as e:
        print(&#39;Error in Image.Metadata: &#39; + str(e))
        logger.exception(&#39;Error in Image.Metadata: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, suffix='_Copy', series=None, output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, suffix=&#39;_Copy&#39;, series=None, output_dir=None):
    logger.info(&#34;Image.copy called&#34;)
    try:
        if series is None:
            series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
            series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
            series_uid = self.seriesUID
            #suffix = self.suffix
        else:
            series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
            series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
            series_uid = series.seriesUID
            suffix = series.suffix
        newPath, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.path, series_id=series_id, series_uid=series_uid, series_name=series_name, suffix=suffix, output_dir=output_dir)
        copiedImage = Image(self.objWeasel, self.subjectID, self.studyID, newSeriesID, newPath, suffix=suffix)
        if series: series.add(copiedImage)
        return copiedImage
    except Exception as e:
        print(&#39;Error in Image.copy: &#39; + str(e))
        logger.exception(&#39;Error in Image.copy: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    logger.info(&#34;Image.delete called&#34;)
    try:
        GenericDICOMTools.deleteDICOM(self.objWeasel, self.path)
        self.path = []
        self.referencePath = []
        self.subjectID = self.studyID = self.seriesID = &#39;&#39;
        # Delete the instance, such as del self???
    except Exception as e:
        print(&#39;Error in Image.delete: &#39; + str(e))
        logger.exception(&#39;Error in Image.delete: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self):
    self.objWeasel.display(self)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.export_as_csv"><code class="name flex">
<span>def <span class="ident">export_as_csv</span></span>(<span>self, directory=None, filename=None, columnHeaders=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
    logger.info(&#34;Image.export_as_csv called&#34;)
    try:
        if directory is None: directory = os.path.dirname(self.images[0])
        if filename is None:
            filename = os.path.join(directory, self.seriesID + &#39;.csv&#39;)
        else:
            filename = os.path.join(directory, filename + &#39;.csv&#39;)
        table = self.PixelArray
        if columnHeaders is None:
            columnHeaders = []
            counter = 0
            for _ in table:
                counter += 1
                columnHeaders.append(&#34;Column&#34; + str(counter))
        df = pd.DataFrame(np.transpose(table), columns=columnHeaders)
        df.to_csv(filename, index=False)
    except Exception as e:
        print(&#39;Error in Image.export_as_csv: &#39; + str(e))
        logger.exception(&#39;Error in Image.export_as_csv: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.export_as_nifti"><code class="name flex">
<span>def <span class="ident">export_as_nifti</span></span>(<span>self, directory=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_as_nifti(self, directory=None, filename=None):
    logger.info(&#34;Image.export_as_nifti called&#34;)
    try:
        if directory is None: directory=os.path.dirname(self.path)
        if filename is None: filename=self.seriesID
        dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomObject)
        niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), affine=self.Affine)
        # The transpose is necessary in this case to be in line with the rest of Weasel.
        niftiObj.header.extensions.append(dicomHeader)
        nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
    except Exception as e:
        print(&#39;Error in Image.export_as_nifti: &#39; + str(e))
        logger.exception(&#39;Error in Image.export_as_nifti: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, tag):
    logger.info(&#34;Image.get_value called&#34;)
    try:
        if isinstance(tag, list):
            outputValuesList = []
            for ind_tag in tag:
                if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                outputValuesList.append(ReadDICOM_Image.getImageTagValue(self.path, ind_tag))
            return outputValuesList
        else:
            if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomObject, &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
            return ReadDICOM_Image.getImageTagValue(self.path, tag)
    except Exception as e:
        print(&#39;Error in Image.get_value: &#39; + str(e))
        logger.exception(&#39;Error in Image.get_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.load_mask"><code class="name flex">
<span>def <span class="ident">load_mask</span></span>(<span>self, maskInstance)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the PixelArray masked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_mask(self, maskInstance):
    &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
    logger.info(&#34;Image.Mask called&#34;)
    try:
        if isinstance(maskInstance, Image):
            #for index, dicomFile in enumerate(targetPath):
            tempArray = np.zeros(np.shape(self.PixelArray))
            dataset_original = self.PydicomObject
            dataset = maskInstance.PydicomObject
            mask_array = maskInstance.PixelArray
            mask_array[mask_array != 0] = 1
            affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
            if affine_results:
                coords = zip(*affine_results)
                tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
            return np.transpose(tempArray) * self.PixelArray
        elif isinstance(maskInstance, Series):
            tempArray = np.zeros(np.shape(self.PixelArray))
            for maskFile in maskInstance.images:
                dataset_original = self.PydicomObject
                dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                mask_array = ReadDICOM_Image.getPixelArray(dataset)
                mask_array[mask_array != 0] = 1
                affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                if affine_results:
                    coords = zip(*affine_results)
                    tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
            return np.transpose(tempArray) * self.PixelArray
    except Exception as e:
        print(&#39;Error in Image.Mask: &#39; + str(e))
        logger.exception(&#39;Error in Image.Mask: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, suffix='_Copy', series=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self, suffix=&#39;_Copy&#39;, series=None):
    logger.info(&#34;Image.new called&#34;)
    try:
        if series is None:
            newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, &#39;&#39;, suffix=suffix)
        else:
            newImage = Image(series.objWeasel, series.subjectID, series.studyID, series.seriesID, &#39;&#39;, suffix=suffix)
        newImage.referencePath = self.path
        return newImage
    except Exception as e:
        print(&#39;Error in Image.new: &#39; + str(e))
        logger.exception(&#39;Error in Image.new: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, xlabel='X axis', ylabel='Y axis')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
    logger.info(&#34;Image.plot called&#34;)
    try:
        self.objWeasel.plot(self.path, self.seriesID, self.PixelArray[0], self.PixelArray[1], xlabel, ylabel)
    except Exception as e:
        print(&#39;Error in Image.plot: &#39; + str(e))
        logger.exception(&#39;Error in Image.plot: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    return self.PydicomObject</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, PydicomObject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, PydicomObject):
    changeXML = False
    newSubjectID = self.subjectID
    newStudyID = self.studyID
    newSeriesID = self.seriesID
    if PydicomObject.SeriesDescription != self.PydicomObject.SeriesDescription or PydicomObject.SeriesNumber != self.PydicomObject.SeriesNumber:
        changeXML = True
        newSeriesID = str(PydicomObject.SeriesNumber) + &#34;_&#34; + str(PydicomObject.SeriesDescription)
    if PydicomObject.StudyDate != self.PydicomObject.StudyDate or PydicomObject.StudyTime != self.PydicomObject.StudyTime or PydicomObject.StudyDescription != self.PydicomObject.StudyDescription:
        changeXML = True
        newStudyID = str(PydicomObject.StudyDate) + &#34;_&#34; + str(PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(PydicomObject.StudyDescription)
    if PydicomObject.PatientID != self.PydicomObject.PatientID:
        changeXML = True
        newSubjectID = str(PydicomObject.PatientID)
    SaveDICOM_Image.saveDicomToFile(PydicomObject, output_path=self.path)
    if changeXML == True:
        self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
    # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
    self.subjectID = newSubjectID
    self.studyID = newStudyID
    self.seriesID = newSeriesID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, tag, newValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, tag, newValue):
    logger.info(&#34;Image.set_value called&#34;)
    try:
        comparisonDicom = self.PydicomObject
        changeXML = False
        # Not necessary new IDs, but they may be new. The changeXML flag coordinates that.
        oldSubjectID = self.subjectID
        oldStudyID = self.studyID
        oldSeriesID = self.seriesID
        # Set tag commands
        if isinstance(tag, list) and isinstance(newValue, list):
            for index, ind_tag in enumerate(tag):
                GenericDICOMTools.editDICOMTag(self.path, ind_tag, newValue[index])
        else:
            GenericDICOMTools.editDICOMTag(self.path, tag, newValue)
        # Consider the case where XML fields are changed
        if comparisonDicom.SeriesDescription != self.PydicomObject.SeriesDescription or comparisonDicom.SeriesNumber != self.PydicomObject.SeriesNumber:
            changeXML = True
            newSeriesID = str(self.PydicomObject.SeriesNumber) + &#34;_&#34; + str(self.PydicomObject.SeriesDescription)
            self.seriesID = newSeriesID
        else:
            newSeriesID = oldSeriesID
        if comparisonDicom.StudyDate != self.PydicomObject.StudyDate or comparisonDicom.StudyTime != self.PydicomObject.StudyTime or comparisonDicom.StudyDescription != self.PydicomObject.StudyDescription:
            changeXML = True
            newStudyID = str(self.PydicomObject.StudyDate) + &#34;_&#34; + str(self.PydicomObject.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(self.PydicomObject.StudyDescription)
            self.studyID = newStudyID
        else:
            newStudyID = oldStudyID
        if comparisonDicom.PatientID != self.PydicomObject.PatientID:
            changeXML = True
            newSubjectID = str(self.PydicomObject.PatientID)
            self.subjectID = newSubjectID
        else:
            newSubjectID = oldSubjectID
        if changeXML == True:
            self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.path, &#39;&#39;)
    except Exception as e:
        print(&#39;Error in Image.set_value: &#39; + str(e))
        logger.exception(&#39;Error in Image.set_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, pixelArray, series=None, output_dir=None, value_range=None, parametric_map=None, colourmap=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, pixelArray, series=None, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
    logger.info(&#34;Image.write called&#34;)
    try:
        if isinstance(value_range, list):
            pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
        else:
            list_values = np.unique(pixelArray).flatten()
            list_values = [x for x in list_values if np.isnan(x) == False]
            if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                upper_value = list_values[-2]
            else:
                upper_value = None
            if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                lower_value = list_values[1]
            else:
                lower_value = None
            pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
        if os.path.exists(self.path):
            PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.path) # Include Colourmap and Parametric Map
        else:
            if series is None:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = self.seriesUID
            else:
                series_id = series.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = series.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = series.seriesUID
            outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, self.referencePath, self.suffix, series_id=series_id, series_name=series_name, series_uid=series_uid, parametric_map=parametric_map, output_dir=output_dir, colourmap=colourmap)
            self.path = outputPath[0]
            if series: series.add(self)
    except Exception as e:
        print(&#39;Error in Image.write: &#39; + str(e))
        logger.exception(&#39;Error in Image.write: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Image.write_mask"><code class="name flex">
<span>def <span class="ident">write_mask</span></span>(<span>self, mask_array, label=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_mask(self, mask_array, label=None):
    logger.info(&#34;Image.write_mask called&#34;)
    try:
        if label is not None:
            self.suffix = &#34;_&#34; + label
        self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
    except Exception as e:
        print(&#39;Error in Image.write_mask: &#39; + str(e))
        logger.exception(&#39;Error in Image.write_mask: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList"><code class="flex name class">
<span>class <span class="ident">ImagesList</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing a list of objects of class Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImagesList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of objects of class Image. 
    &#34;&#34;&#34;
    @property
    def label(self):
        &#34;&#34;&#34;
        Returns a list of names of the list of images.
        &#34;&#34;&#34;
        listNames = [image.label for image in self]
        return listNames

    @property
    def paths(self):
        &#34;&#34;&#34;
        Returns a list of file paths of the list of images.
        &#34;&#34;&#34;
        listPaths = [image.path for image in self]
        return listPaths

    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of images.
        &#34;&#34;&#34;
        copy = []
        for image in self:
            copy.append(image.copy())
        return ImagesList(copy)
        
    def merge(self, series_number=None,series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of images into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, series_id=series_number, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)

    def new_parent(self, suffix=&#34;_Suffix&#34;):
        &#34;&#34;&#34;
        Creates a new parent series from the images in the list.
        &#34;&#34;&#34;
        return self[0].newSeriesFrom(self, suffix=suffix)

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique series to which the images belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for image in self:
            series = image.parent
            listIndividualAttributes = [series.subjectID, series.studyID, series.seriesID,
                                        series.images, series.studyUID, series.seriesUID, series.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            series = Series(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3], listAtt[4], listAtt[5], listAtt[6])
            parentsList.append(series)
        return SeriesList(parentsList)


    def display(self):
        &#34;&#34;&#34;
        Displays all images as a series.
        &#34;&#34;&#34;
        self[0].objWeasel.display(self)


    def sort(self, *argv, reverse=False):
        &#34;&#34;&#34;
        Sort the list of images by the given DICOM tags.
        &#34;&#34;&#34;
        tuple_to_sort = []
        list_to_sort = []
        list_to_sort.append(self)
        for tag in argv:
            if len(self.get_value(tag)) &gt; 0:
                attributeList = self.get_value(tag)
                list_to_sort.append(attributeList)
        for index, _ in enumerate(self):
            individual_tuple = []
            for individual_list in list_to_sort:
                individual_tuple.append(individual_list[index])
            tuple_to_sort.append(tuple(individual_tuple))
        tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
        list_sorted_images = []
        for individual in tuple_sorted:
            list_sorted_images.append(individual[0])
        self = ImagesList(list_sorted_images)
        return self

    def where(self, tag, condition, target):
        list_images = []
        for image in self:
            value = image[tag]
            if condition == &#34;==&#34;:
                statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
                if eval(statement) == True:
                    list_images.append(image)
            else:
                statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
                if eval(literal_eval(statement)) == True:
                    list_images.append(image)
        self = ImagesList(list_images)
        return self

    def get_value(self, tag):
        &#34;&#34;&#34;
        Returns a list of values of the given DICOM tag in the list of images
        &#34;&#34;&#34;
        attributes_list = []
        for image in self:
            attributes_list.append(image.get_value(tag))
        return attributes_list

    def set_value(self, tag, value):
        &#34;&#34;&#34;
        Set the variable &#34;value&#34; to the given DICOM tag in the list of images
        &#34;&#34;&#34;
        if isinstance(value, list) and len(self) == len(value):
            for index, image in enumerate(self):
                image.set_value(tag, value[index])
        else:
            for image in self:
                image.set_value(tag, value)
    
    def __getitem__(self, tag):
        if isinstance(tag, int):
            for index, image in enumerate(self):
                if index == tag:
                    return image
        else:
            return self.get_value(tag)

    def __setitem__(self, tag, value):
        if isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
            dicom_tag = tag.split(&#39; &#39;)[0]
            logical_operator = tag.split(&#39; &#39;)[1]
            target_value = tag.split(&#39; &#39;)[2]
            listImages = self.where(dicom_tag, logical_operator, target_value)
            listImages.set_value(dicom_tag, value)
        elif isinstance(tag, str):
            self.set_value(tag, value)
        elif isinstance(tag, int) and isinstance(value, Image):
            newList = []
            for index, image in enumerate(self):
                if index == tag:
                    newList.append(value)
                else:
                    newList.append(image)
            self = newList
            #self[tag] = value
        elif isinstance(tag, list) and isinstance(value, list):
            for index, dicom_tag in enumerate(tag):
                self.set_value(dicom_tag, value[index])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></li>
<li>builtins.list</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.ImagesList.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of names of the list of images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    &#34;&#34;&#34;
    Returns a list of names of the list of images.
    &#34;&#34;&#34;
    listNames = [image.label for image in self]
    return listNames</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of unique series to which the images belong to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;
    Returns a list of unique series to which the images belong to.
    &#34;&#34;&#34;
    parentsList = []
    listParentsAttribute = []
    for image in self:
        series = image.parent
        listIndividualAttributes = [series.subjectID, series.studyID, series.seriesID,
                                    series.images, series.studyUID, series.seriesUID, series.suffix]
        listParentsAttribute.append(listIndividualAttributes)
    listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
    for listAtt in listUniqueParentsAttribute:
        series = Series(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3], listAtt[4], listAtt[5], listAtt[6])
        parentsList.append(series)
    return SeriesList(parentsList)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.paths"><code class="name">var <span class="ident">paths</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of file paths of the list of images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paths(self):
    &#34;&#34;&#34;
    Returns a list of file paths of the list of images.
    &#34;&#34;&#34;
    listPaths = [image.path for image in self]
    return listPaths</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.ImagesList.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the list of images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Returns a copy of the list of images.
    &#34;&#34;&#34;
    copy = []
    for image in self:
        copy.append(image.copy())
    return ImagesList(copy)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays all images as a series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self):
    &#34;&#34;&#34;
    Displays all images as a series.
    &#34;&#34;&#34;
    self[0].objWeasel.display(self)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of values of the given DICOM tag in the list of images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, tag):
    &#34;&#34;&#34;
    Returns a list of values of the given DICOM tag in the list of images
    &#34;&#34;&#34;
    attributes_list = []
    for image in self:
        attributes_list.append(image.get_value(tag))
    return attributes_list</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, series_number=None, series_name='MergedSeries', study_name=None, patient_name=None, overwrite=True, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges a list of images into a new series under the same study</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, series_number=None,series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
    &#34;&#34;&#34;
    Merges a list of images into a new series under the same study
    &#34;&#34;&#34;
    if len(self) == 0: return
    return self[0].merge(self, series_id=series_number, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.new_parent"><code class="name flex">
<span>def <span class="ident">new_parent</span></span>(<span>self, suffix='_Suffix')</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new parent series from the images in the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_parent(self, suffix=&#34;_Suffix&#34;):
    &#34;&#34;&#34;
    Creates a new parent series from the images in the list.
    &#34;&#34;&#34;
    return self[0].newSeriesFrom(self, suffix=suffix)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, tag, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the variable "value" to the given DICOM tag in the list of images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, tag, value):
    &#34;&#34;&#34;
    Set the variable &#34;value&#34; to the given DICOM tag in the list of images
    &#34;&#34;&#34;
    if isinstance(value, list) and len(self) == len(value):
        for index, image in enumerate(self):
            image.set_value(tag, value[index])
    else:
        for image in self:
            image.set_value(tag, value)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, *argv, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the list of images by the given DICOM tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, *argv, reverse=False):
    &#34;&#34;&#34;
    Sort the list of images by the given DICOM tags.
    &#34;&#34;&#34;
    tuple_to_sort = []
    list_to_sort = []
    list_to_sort.append(self)
    for tag in argv:
        if len(self.get_value(tag)) &gt; 0:
            attributeList = self.get_value(tag)
            list_to_sort.append(attributeList)
    for index, _ in enumerate(self):
        individual_tuple = []
        for individual_list in list_to_sort:
            individual_tuple.append(individual_list[index])
        tuple_to_sort.append(tuple(individual_tuple))
    tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
    list_sorted_images = []
    for individual in tuple_sorted:
        list_sorted_images.append(individual[0])
    self = ImagesList(list_sorted_images)
    return self</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ImagesList.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>self, tag, condition, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(self, tag, condition, target):
    list_images = []
    for image in self:
        value = image[tag]
        if condition == &#34;==&#34;:
            statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
            if eval(statement) == True:
                list_images.append(image)
        else:
            statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
            if eval(literal_eval(statement)) == True:
                list_images.append(image)
    self = ImagesList(list_images)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.delete" href="#Weasel.DICOM.Classes.ListOfDicomObjects.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Weasel.DICOM.Classes.ListOfDicomObjects"><code class="flex name class">
<span>class <span class="ident">ListOfDicomObjects</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A superclass for managing Lists of Subjects, Studies, Series or Images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListOfDicomObjects(list):
    &#34;&#34;&#34;
    A superclass for managing Lists of Subjects, Studies, Series or Images. 
    &#34;&#34;&#34;
    def delete(self):
        &#34;&#34;&#34;
        Deletes all items in the list
        &#34;&#34;&#34;
        for item in self:
            item.delete()

    def display(self):
        &#34;&#34;&#34;
        Displays all items in the list.
        &#34;&#34;&#34;
        for item in self:
            item.objWeasel.display(item)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.list</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Weasel.DICOM.Classes.ImagesList" href="#Weasel.DICOM.Classes.ImagesList">ImagesList</a></li>
<li><a title="Weasel.DICOM.Classes.SeriesList" href="#Weasel.DICOM.Classes.SeriesList">SeriesList</a></li>
<li><a title="Weasel.DICOM.Classes.StudyList" href="#Weasel.DICOM.Classes.StudyList">StudyList</a></li>
<li><a title="Weasel.DICOM.Classes.SubjectList" href="#Weasel.DICOM.Classes.SubjectList">SubjectList</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.ListOfDicomObjects.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes all items in the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;
    Deletes all items in the list
    &#34;&#34;&#34;
    for item in self:
        item.delete()</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.ListOfDicomObjects.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays all items in the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self):
    &#34;&#34;&#34;
    Displays all items in the list.
    &#34;&#34;&#34;
    for item in self:
        item.objWeasel.display(item)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>objWeasel)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the top-level of the TreeView hierarchy. It bundles all scans opened in the Weasel GUI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objWeasel</code></strong> :&ensp;<code>the <a title="Weasel" href="../index.html">Weasel</a> global variable</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project:
    &#34;&#34;&#34;This class is the top-level of the TreeView hierarchy. It bundles all scans opened in the Weasel GUI.

        Parameters
        ----------
        objWeasel : the Weasel global variable
    &#34;&#34;&#34;
    def __init__(self, objWeasel):
        self.objWeasel = objWeasel
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Project.children called&#34;)
        try:
            children = []
            rootXML = self.objWeasel.objXMLReader.root
            for subjectXML in rootXML:
                subjectID = subjectXML.attrib[&#39;id&#39;]
                subject = Subject(self.objWeasel, subjectID)
                children.append(subject)
            return SubjectList(children)
        except Exception as e:
            print(&#39;Error in Project.children: &#39; + str(e))
            logger.exception(&#39;Error in Project.children: &#39; + str(e))
    
    @property
    def number_children(self):
        return len(self.children)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Project.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    logger.info(&#34;Project.children called&#34;)
    try:
        children = []
        rootXML = self.objWeasel.objXMLReader.root
        for subjectXML in rootXML:
            subjectID = subjectXML.attrib[&#39;id&#39;]
            subject = Subject(self.objWeasel, subjectID)
            children.append(subject)
        return SubjectList(children)
    except Exception as e:
        print(&#39;Error in Project.children: &#39; + str(e))
        logger.exception(&#39;Error in Project.children: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Project.number_children"><code class="name">var <span class="ident">number_children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_children(self):
    return len(self.children)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.Series"><code class="flex name class">
<span>class <span class="ident">Series</span></span>
<span>(</span><span>objWeasel, subjectID, studyID, seriesID, listPaths=None, studyUID=None, seriesUID=None, suffix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class encloses all DICOM files that share the same tag value of "StudyInstanceUID", "StudyDescription", "StudyDate" and "StudyTime".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objWeasel</code></strong> :&ensp;<code>the <a title="Weasel" href="../index.html">Weasel</a> global variable</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>subjectID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the subject, which is stored in the "PatientID" DICOM tag.</dd>
<dt><strong><code>studyID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the study, which is stored in the "StudyDescription" DICOM tag.</dd>
<dt><strong><code>seriesID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the series, which is stored in the "SeriesDescription" DICOM tag.</dd>
<dt><strong><code>listPaths</code></strong> :&ensp;<code>list(string) (optional)</code></dt>
<dd>This is a list containing the file paths of the DICOM files that belong to the Series() instance created.
This class creates the list based on the Weasel GUI TreeView selection if it's not given.</dd>
<dt><strong><code>studyUID</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the unique identification of the study, which is stored in the "StudyInstanceUID" DICOM tag.</dd>
<dt><strong><code>seriesUID</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the unique identification of the study, which is stored in the "SeriesInstanceUID" DICOM tag.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the text to append to subjectID if a new Series() class is created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Series:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;StudyInstanceUID&#34;, &#34;StudyDescription&#34;, &#34;StudyDate&#34; and &#34;StudyTime&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        seriesID : string
            This is the name or identification of the series, which is stored in the &#34;SeriesDescription&#34; DICOM tag.
        listPaths : list(string) (optional)
            This is a list containing the file paths of the DICOM files that belong to the Series() instance created.
            This class creates the list based on the Weasel GUI TreeView selection if it&#39;s not given.
        studyUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;StudyInstanceUID&#34; DICOM tag.
        seriesUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;SeriesInstanceUID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Series() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;seriesID&#39;, &#39;studyUID&#39;, &#39;seriesUID&#39;, 
                 &#39;images&#39;, &#39;suffix&#39;, &#39;referencePathsList&#39;)
    def __init__(self, objWeasel, subjectID, studyID, seriesID, listPaths=None, studyUID=None, seriesUID=None, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.seriesID = seriesID
        self.images = [] if listPaths is None else listPaths
        self.studyUID = self.StudyUID if studyUID is None else studyUID
        self.seriesUID = self.SeriesUID if seriesUID is None else seriesUID
        self.suffix = &#39;&#39; if suffix is None else suffix
        self.referencePathsList = []
        # This is to deal with Enhanced MRI
        #if self.PydicomList and len(self.images) == 1:
        #    self.indices = list(np.arange(len(self.PydicomList[0].PerFrameFunctionalGroupsSequence))) if hasattr(self.PydicomList[0], &#39;PerFrameFunctionalGroupsSequence&#39;) else []
        #else:
        #    self.indices = []
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Series.children called&#34;)
        try:
            children = []
            if len(self.images) &gt; 1:
                for imagePath in self.images:
                    image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
                    children.append(image)
            else:
                seriesXML = self.objWeasel.objXMLReader.getSeries(self.subjectID, self.studyID, self.seriesID)
                for imageXML in seriesXML:
                    image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imageXML.find(&#39;name&#39;).text)
                    children.append(image)
            return ImagesList(children)
        except Exception as e:
            print(&#39;Error in Series.children: &#39; + str(e))
            logger.exception(&#39;Error in Series.children: &#39; + str(e))
    
    @property
    def parent(self):
        logger.info(&#34;Series.parent called&#34;)
        try:
            return Study(self.objWeasel, self.subjectID, self.studyID, studyUID=self.studyUID)
        except Exception as e:
            print(&#39;Error in Series.parent: &#39; + str(e))
            logger.exception(&#39;Error in Series.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)

    @property
    def label(self):
        logger.info(&#34;Series.label called&#34;)
        try:
            return self.seriesID
        except Exception as e:
            print(&#39;Error in Series.label: &#39; + str(e))
            logger.exception(&#39;Error in Series.label: &#39; + str(e))
    
    def new(self, suffix=&#34;_Copy&#34;, series_id=None, series_name=None, series_uid=None):
        logger.info(&#34;Series.new called&#34;)
        try:
            if series_id is None:
                series_id, _ = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images)
            if series_name is None:
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1] + suffix
            if series_uid is None:
                _, series_uid = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images, seriesNumber=series_id)
            seriesID = str(series_id) + &#39;_&#39; + series_name
            newSeries = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, seriesUID=series_uid, suffix=suffix)
            newSeries.referencePathsList = self.images
            return newSeries
        except Exception as e:
            print(&#39;Error in Series.new: &#39; + str(e))
            logger.exception(&#39;Error in Series.new: &#39; + str(e))
    
    def copy(self, suffix=&#34;_Copy&#34;, newSeries=True, series_id=None, series_name=None, series_uid=None, study_uid=None, study_name=None, patient_id=None, output_dir=None):
        logger.info(&#34;Series.copy called&#34;)
        try:
            if newSeries == True:
                newPathsList, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name,
                                                                        study_uid=study_uid, study_name=study_name, patient_id=patient_id, suffix=suffix, output_dir=output_dir)
                return Series(self.objWeasel, self.subjectID, self.studyID, newSeriesID, listPaths=newPathsList, suffix=suffix)
            else:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                series_uid = self.seriesUID
                suffix = self.suffix
                newPathsList, _ = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name, study_uid=study_uid,
                                                              study_name=study_name, patient_id=patient_id,suffix=suffix, output_dir=output_dir) # StudyID in InterfaceXML
                for newCopiedImagePath in newPathsList:
                    newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, newCopiedImagePath)
                    self.add(newImage)
        except Exception as e:
            print(&#39;Error in Series.copy: &#39; + str(e))
            logger.exception(&#39;Error in Series.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Series.delete called&#34;)
        try:
            GenericDICOMTools.deleteDICOM(self.objWeasel, self.images)
            self.images = self.referencePathsList = []
            #self.children = self.indices = []
            #self.number_children = 0
            self.subjectID = self.studyID = self.seriesID = self.seriesUID = &#39;&#39;
        except Exception as e:
            print(&#39;Error in Series.delete: &#39; + str(e))
            logger.exception(&#39;Error in Series.delete: &#39; + str(e))

    def add(self, Image):
        logger.info(&#34;Series.add called&#34;)
        try:
            self.images.append(Image.path)
            # Might need XML functions
            #self.children.append(Image)
            #self.number_children = len(self.children)
        except Exception as e:
            print(&#39;Error in Series.add: &#39; + str(e))
            logger.exception(&#39;Error in Series.add: &#39; + str(e))

    def remove(self, all_images=False, Image=None):
        logger.info(&#34;Series.remove called&#34;)
        try:
            if all_images == True:
                self.images = []
                # Might need XML functions
                #self.children = []
                #self.number_children = 0
            elif Image is not None:
                self.images.remove(Image.path)
                # Might need XML functions
                #self.children.remove(Image)
                #self.number_children = len(self.children)
        except Exception as e:
            print(&#39;Error in Series.remove: &#39; + str(e))
            logger.exception(&#39;Error in Series.remove: &#39; + str(e))

    def write(self, pixelArray, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
        logger.info(&#34;Series.write called&#34;)
        try:
            if isinstance(value_range, list):
                pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
            else:
                list_values = np.unique(pixelArray).flatten()
                list_values = [x for x in list_values if np.isnan(x) == False]
                if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                    upper_value = list_values[-2]
                else:
                    upper_value = None
                if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                    lower_value = list_values[1]
                else:
                    lower_value = None
                pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
            if self.images:
                PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.images)
            else:
                series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
                series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
                inputReference = self.referencePathsList[0] if len(self.referencePathsList)==1 else self.referencePathsList
                outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, inputReference, self.suffix, series_id=series_id, series_name=series_name, series_uid=self.seriesUID, output_dir=output_dir, parametric_map=parametric_map, colourmap=colourmap)
                self.images = outputPath
                if self[&#34;WindowWidth&#34;] and self[&#34;WindowCenter&#34;] and isinstance(value_range, list):
                    width = value_range[1] - value_range[0]
                    center = value_range[0] + (width/2)
                    self[&#34;WindowWidth&#34;] = width
                    self[&#34;WindowCenter&#34;] = center
        except Exception as e:
            print(&#39;Error in Series.write: &#39; + str(e))
            logger.exception(&#39;Error in Series.write: &#39; + str(e))
    
    def read(self):
        return self.PydicomList

    def save(self, PydicomList):
        newSubjectID = self.subjectID
        newStudyID = self.studyID
        newSeriesID = self.seriesID
        for index, dataset in enumerate(PydicomList):
            changeXML = False
            if dataset.SeriesDescription != self.PydicomList[index].SeriesDescription or dataset.SeriesNumber != self.PydicomList[index].SeriesNumber:
                changeXML = True
                newSeriesID = str(dataset.SeriesNumber) + &#34;_&#34; + str(dataset.SeriesDescription)
            if dataset.StudyDate != self.PydicomList[index].StudyDate or dataset.StudyTime != self.PydicomList[index].StudyTime or dataset.StudyDescription != self.PydicomList[index].StudyDescription:
                changeXML = True
                newStudyID = str(dataset.StudyDate) + &#34;_&#34; + str(dataset.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(dataset.StudyDescription)
            if dataset.PatientID != self.PydicomList[index].PatientID:
                changeXML = True
                newSubjectID = str(dataset.PatientID)
            SaveDICOM_Image.saveDicomToFile(dataset, output_path=self.images[index])
            if changeXML == True:
                self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
        # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
        self.subjectID = newSubjectID
        self.studyID = newStudyID
        self.seriesID = newSeriesID

    @staticmethod
    def merge(listSeries, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
        logger.info(&#34;Series.merge called&#34;)
        try:
            outputSeries = listSeries[0].new(suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)
            pathsList = [image for series in listSeries for image in series.images]
            outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, pathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
            outputSeries.images = outputPathList
            outputSeries.referencePathsList = outputPathList
            return outputSeries
        except Exception as e:
            print(&#39;Error in Series.merge: &#39; + str(e))
            logger.exception(&#39;Error in Series.merge: &#39; + str(e))
    
    # Deprecated but might be useful in the future
    #def sort(self, tagDescription, *argv):
    #    if self.Item(tagDescription) or self.Tag(tagDescription):
    #        imagePathList, _, _, indicesSorted = ReadDICOM_Image.sortSequenceByTag(self.images, tagDescription)
    #        self.images = imagePathList
    #        #if self.Multiframe: self.indices = sorted(set(indicesSorted) &amp; set(self.indices), key=indicesSorted.index)
    #    for tag in argv:
    #        if self.Item(tag) or self.Tag(tag):
    #            imagePathList, _, _, indicesSorted = ReadDICOM_Image.sortSequenceByTag(self.images, tag)
    #            self.images = imagePathList
    #            #if self.Multiframe: self.indices = sorted(set(indicesSorted) &amp; set(self.indices), key=indicesSorted.index)
    
    def sort(self, *argv, reverse=False):
        logger.info(&#34;Series.sort called&#34;)
        try:
            tuple_to_sort = []
            list_to_sort = [self.images]
            for tag in argv:
                if len(self.get_value(tag)) &gt; 0:
                    list_to_sort.append(self.get_value(tag))
            for index in range(len(self.images)):
                individual_tuple = [individual_list[index] for individual_list in list_to_sort]
                tuple_to_sort.append(tuple(individual_tuple))
            tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
            list_sorted_images = [individual[0] for individual in tuple_sorted]
            self.images = list_sorted_images
            return self
        except Exception as e:
            print(&#39;Error in Series.sort: &#39; + str(e))
            logger.exception(&#39;Error in Series.sort: &#39; + str(e))
    
    def where(self, tag, condition, target):
        logger.info(&#34;Series.where called&#34;)
        try:
            list_images = []
            list_paths = []
            for image in self.children:
                value = image[tag]
                if condition == &#34;==&#34;:
                    statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
                    if eval(statement) == True:
                        list_images.append(image)
                        list_paths.append(image.path)
                else:
                    statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
                    if eval(literal_eval(statement)) == True:
                        list_images.append(image)
                        list_paths.append(image.path)
            self.images = list_paths
            return self
        except Exception as e:
            print(&#39;Error in Series.where: &#39; + str(e))
            logger.exception(&#39;Error in Series.where: &#39; + str(e))

    def display(self):
        self.objWeasel.display(self)

    def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
        logger.info(&#34;Series.plot called&#34;)
        try:
            for imagePath in self.images:
                image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
                image.plot(xlabel, ylabel)
        except Exception as e:
            print(&#39;Error in Series.plot: &#39; + str(e))
            logger.exception(&#39;Error in Series.plot: &#39; + str(e))

    def Metadata(self):
        logger.info(&#34;Series.Metadata called&#34;)
        try:
            self.objWeasel.displayMetadata(self.images)
        except Exception as e:
            print(&#39;Error in Series.Metadata: &#39; + str(e))
            logger.exception(&#39;Error in Series.Metadata: &#39; + str(e))

    @property
    def SeriesUID(self):
        if not self.images:
            self.seriesUID = None
        elif os.path.exists(self.images[0]):
            self.seriesUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;SeriesInstanceUID&#39;)
        else:
            self.seriesUID = None
        return self.seriesUID

    @property
    def StudyUID(self):
        if not self.images:
            self.studyUID = None
        elif os.path.exists(self.images[0]):
            self.studyUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;StudyInstanceUID&#39;)
        else:
            self.studyUID = None
        return self.studyUID

    @property
    def Magnitude(self):
        logger.info(&#34;Series.Magnitude called&#34;)
        try:
            dicomList = self.PydicomList
            magnitudeSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            magnitudeSeries.remove(all_images=True)
            magnitudeSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                flagMagnitude, _, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagMagnitude, list) and flagMagnitude:
                #    if len(flagMagnitude) &gt; 1 and len(self.images) == 1:
                #        magnitudeSeries.indices = flagMagnitude
                #    magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagMagnitude == True:
                    magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return magnitudeSeries
        except Exception as e:
            print(&#39;Error in Series.Magnitude: &#39; + str(e))
            logger.exception(&#39;Error in Series.Magnitude: &#39; + str(e))

    @property
    def Phase(self):
        logger.info(&#34;Series.Phase called&#34;)
        try:
            dicomList = self.PydicomList
            phaseSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            phaseSeries.remove(all_images=True)
            phaseSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, flagPhase, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagPhase, list) and flagPhase:
                #    if len(flagPhase) &gt; 1 and len(self.images) == 1:
                #        phaseSeries.indices = flagPhase
                #    phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagPhase == True:
                    phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return phaseSeries
        except Exception as e:
            print(&#39;Error in Series.Phase: &#39; + str(e))
            logger.exception(&#39;Error in Series.Phase: &#39; + str(e))

    @property
    def Real(self):
        logger.info(&#34;Series.Real called&#34;)
        try:
            dicomList = self.PydicomList
            realSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            realSeries.remove(all_images=True)
            realSeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, _, flagReal, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagReal, list) and flagReal:
                #    if len(flagReal) &gt; 1 and len(self.images) == 1:
                #        realSeries.indices = flagReal
                #    realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagReal:
                    realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return realSeries
        except Exception as e:
            print(&#39;Error in Series.Real: &#39; + str(e))
            logger.exception(&#39;Error in Series.Real: &#39; + str(e))

    @property
    def Imaginary(self):
        logger.info(&#34;Series.Imaginary called&#34;)
        try:
            dicomList = self.PydicomList
            imaginarySeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
            imaginarySeries.remove(all_images=True)
            imaginarySeries.referencePathsList = self.images
            for index in range(len(self.images)):
                _, _, _, flagImaginary, _ = ReadDICOM_Image.checkImageType(dicomList[index])
                #if isinstance(flagImaginary, list) and flagImaginary:
                #    if len(flagImaginary) &gt; 1 and len(self.images) == 1:
                #        imaginarySeries.indices = flagImaginary
                #    imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
                if flagImaginary:
                    imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            return imaginarySeries
        except Exception as e:
            print(&#39;Error in Series.Imaginary: &#39; + str(e))
            logger.exception(&#39;Error in Series.Imaginary: &#39; + str(e))

    @property
    def PixelArray(self):
        logger.info(&#34;Series.PixelArray called&#34;)
        try:
            pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.images)
            return pixelArray
        except Exception as e:
            print(&#39;Error in Series.PixelArray: &#39; + str(e))
            logger.exception(&#39;Error in Series.PixelArray: &#39; + str(e))
        
    def load_mask(self, maskInstance):
        &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
        logger.info(&#34;Series.Mask called&#34;)
        try:
            dataset = maskInstance.PydicomList
            mask_array = maskInstance.PixelArray
            mask_array[mask_array != 0] = 1
            mask_output = []
            if isinstance(maskInstance, Image):
                for dicomFile in self.images:
                    dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                    tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                    affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                    if affine_results:
                        coords = zip(*affine_results)
                        tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                    mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
                return np.nan_to_num(mask_output)
            elif isinstance(maskInstance, Series):
                listImages = self.images
                listMaskImages = maskInstance.images
                for dicomFile in listImages:
                    dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                    tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                    for maskFile in listMaskImages:
                        dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                        mask_array = ReadDICOM_Image.getPixelArray(dataset)
                        mask_array[mask_array != 0] = 1
                        affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                        if affine_results:
                            coords = zip(*affine_results)
                            tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                    mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
                return np.nan_to_num(mask_output)
        except Exception as e:
            print(&#39;Error in Series.Mask: &#39; + str(e))
            logger.exception(&#39;Error in Series.Mask: &#39; + str(e))
    
    def write_mask(self, mask_array, label=None):
        logger.info(&#34;Series.write_mask called&#34;)
        try:
            if label is not None:
                self.suffix = &#34;_&#34; + label
            self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
        except Exception as e:
            print(&#39;Error in Series.write_mask: &#39; + str(e))
            logger.exception(&#39;Error in Series.write_mask: &#39; + str(e))

    @property
    def Affine(self):
        logger.info(&#34;Series.Affine called&#34;)
        try:
            return ReadDICOM_Image.returnAffineArray(self.images[0])
        except Exception as e:
            print(&#39;Error in Series.Affine: &#39; + str(e))
            logger.exception(&#39;Error in Series.Affine: &#39; + str(e))

    @property
    def ListAffines(self):
        logger.info(&#34;Series.ListAffines called&#34;)
        try:
            return [ReadDICOM_Image.returnAffineArray(image) for image in self.images]
        except Exception as e:
            print(&#39;Error in Series.ListAffines: &#39; + str(e))
            logger.exception(&#39;Error in Series.ListAffines: &#39; + str(e))
    
    @property
    def ROIindices(self):
        logger.info(&#34;Series.ROIindices called&#34;)
        try:
            tempImage = self.PixelArray
            tempImage[tempImage != 0] = 1
            return np.transpose(np.where(tempImage == 1))
        except Exception as e:
            print(&#39;Error in Series.ROIindices: &#39; + str(e))
            logger.exception(&#39;Error in Series.ROIindices: &#39; + str(e))
    
    def get_value(self, tag):
        logger.info(&#34;Series.get_value called&#34;)
        try:
            if self.images:
                if isinstance(tag, list):
                    outputValuesList = []
                    for ind_tag in tag:
                        if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                        outputValuesList.append(ReadDICOM_Image.getSeriesTagValues(self.images, ind_tag)[0])
                    return outputValuesList
                elif isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
                    dicom_tag = tag.split(&#39; &#39;)[0]
                    if (dicom_tag == &#34;SliceLocation&#34; or dicom_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): dicom_tag = (0x2001, 0x100a)
                    logical_operator = tag.split(&#39; &#39;)[1]
                    target_value = tag.split(&#39; &#39;)[2]
                    series_to_return = copy.copy(self)
                    series_to_return.where(dicom_tag, logical_operator, target_value)
                    list_of_images = series_to_return.children
                    return list_of_images
                elif isinstance(tag, int):
                    return self.children[tag]
                else:
                    if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
                    return ReadDICOM_Image.getSeriesTagValues(self.images, tag)[0]
            else:
                return []
        except Exception as e:
            print(&#39;Error in Series.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Series.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Series.set_value called&#34;)
        try:
            if self.images:
                comparisonDicom = self.PydicomList
                oldSubjectID = self.subjectID
                oldStudyID = self.studyID
                oldSeriesID = self.seriesID
                if isinstance(tag, list) and isinstance(newValue, list):
                    for index, ind_tag in enumerate(tag):
                        self.set_value(ind_tag, newValue[index])
                        #GenericDICOMTools.editDICOMTag(self.images, ind_tag, newValue[index])
                elif isinstance(newValue, list):
                    for value in newValue:
                        GenericDICOMTools.editDICOMTag(self.images, tag, value)
                else:
                    GenericDICOMTools.editDICOMTag(self.images, tag, newValue)
                newDicomList = self.PydicomList
                # Consider the case where other XML fields are changed
                for index, dataset in enumerate(comparisonDicom):
                    changeXML = False
                    if dataset.SeriesDescription != newDicomList[index].SeriesDescription or dataset.SeriesNumber != newDicomList[index].SeriesNumber:
                        changeXML = True
                        newSeriesID = str(newDicomList[index].SeriesNumber) + &#34;_&#34; + str(newDicomList[index].SeriesDescription)
                        self.seriesID = newSeriesID
                    else:
                        newSeriesID = oldSeriesID
                    if dataset.StudyDate != newDicomList[index].StudyDate or dataset.StudyTime != newDicomList[index].StudyTime or dataset.StudyDescription != newDicomList[index].StudyDescription:
                        changeXML = True
                        newStudyID = str(newDicomList[index].StudyDate) + &#34;_&#34; + str(newDicomList[index].StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(newDicomList[index].StudyDescription)
                        self.studyID = newStudyID
                    else:
                        newStudyID = oldStudyID
                    if dataset.PatientID != newDicomList[index].PatientID:
                        changeXML = True
                        newSubjectID = str(newDicomList[index].PatientID)
                        self.subjectID = newSubjectID
                    else:
                        newSubjectID = oldSubjectID
                    if changeXML == True:
                        self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
        except Exception as e:
            print(&#39;Error in Series.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Series.set_value: &#39; + str(e))

    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        if isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
            listImages = self.get_value(tag)
            dicom_tag = tag.split(&#39; &#39;)[0]
            listImages.set_value(dicom_tag, value)
        elif isinstance(tag, int) and isinstance(value, Image):
            self.images[tag] = value.path
        else:
            self.set_value(tag, value)

    # Remove this function in the future - Careful with Subject.merge and Study.merge implications!
    def Item(self, tagDescription, newValue=None):
        if self.images:
            if newValue:
                GenericDICOMTools.editDICOMTag(self.images, tagDescription, newValue)
                if (tagDescription == &#39;SeriesDescription&#39;) or (tagDescription == &#39;SequenceName&#39;) or (tagDescription == &#39;ProtocolName&#39;):
                    self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_name=newValue)
                elif tagDescription == &#39;SeriesNumber&#39;:
                    self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_id=newValue)
            itemList, _ = ReadDICOM_Image.getSeriesTagValues(self.images, tagDescription)
            #if self.Multiframe: 
            #    tempList = [itemList[index] for index in self.indices]
            #    itemList = tempList
            #    del tempList
        else:
            itemList = []
        return itemList
    
    @property
    def PydicomList(self):
        if self.images:
            return PixelArrayDICOMTools.getDICOMobject(self.images)
        else:
            return []
    
    #@property
    #def Multiframe(self):
    #    if self.indices:
    #        return True
    #    else:
    #        return False

    def export_as_nifti(self, directory=None, filename=None):
        logger.info(&#34;Series.export_as_nifti called&#34;)
        try:
            if directory is None: directory=os.path.dirname(self.images[0])
            if filename is None: filename=self.seriesID
            dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomList[0])
            niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), self.Affine)
            # The transpose is necessary in this case to be in line with the rest of Weasel. The rot90() can be a bit questionable, so this should be tested in as much data as possible.
            niftiObj.header.extensions.append(dicomHeader)
            nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
        except Exception as e:
            print(&#39;Error in Series.export_as_nifti: &#39; + str(e))
            logger.exception(&#39;Error in Series.export_as_nifti: &#39; + str(e))
    
    def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
        logger.info(&#34;Series.export_as_csv called&#34;)
        try:
            if directory is None: directory = os.path.dirname(self.images[0])
            if self.number_children == 1:
                self.children[0].export_as_csv(directory=directory, filename=filename, columnHeaders=columnHeaders)
            else:
                table = self.PixelArray
                image_counter = 0
                for slice_image in table:
                    if filename is None:
                        one_filename = os.path.join(directory, self.seriesID + &#39;_&#39; + str(image_counter).zfill(6) + &#39;.csv&#39;)
                    else:
                        one_filename = os.path.join(directory, filename + &#39;_&#39; + str(image_counter).zfill(6) +&#39;.csv&#39;)
                    if columnHeaders is None:
                        one_columHeaders = []
                        counter = 0
                        for _ in slice_image:
                            counter += 1
                            one_columHeaders.append(&#34;Column&#34; + str(counter))
                    df = pd.DataFrame(np.transpose(slice_image), columns=one_columHeaders)
                    df.to_csv(one_filename, index=False)
                    image_counter += 1
        except Exception as e:
            print(&#39;Error in Series.export_as_csv: &#39; + str(e))
            logger.exception(&#39;Error in Series.export_as_csv: &#39; + str(e))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Series.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>listSeries, series_id=None, series_name='NewSeries', series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix='_Merged', overwrite=False, progress_bar=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def merge(listSeries, series_id=None, series_name=&#39;NewSeries&#39;, series_uid=None, study_name=None, study_uid=None, patient_id=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False):
    logger.info(&#34;Series.merge called&#34;)
    try:
        outputSeries = listSeries[0].new(suffix=suffix, series_id=series_id, series_name=series_name, series_uid=series_uid)
        pathsList = [image for series in listSeries for image in series.images]
        outputPathList = GenericDICOMTools.mergeDicomIntoOneSeries(outputSeries.objWeasel, pathsList, series_uid=series_uid, series_id=series_id, series_name=series_name, study_name=study_name, study_uid=study_uid, patient_id=patient_id, suffix=suffix, overwrite=overwrite, progress_bar=progress_bar)
        outputSeries.images = outputPathList
        outputSeries.referencePathsList = outputPathList
        return outputSeries
    except Exception as e:
        print(&#39;Error in Series.merge: &#39; + str(e))
        logger.exception(&#39;Error in Series.merge: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Series.Affine"><code class="name">var <span class="ident">Affine</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Affine(self):
    logger.info(&#34;Series.Affine called&#34;)
    try:
        return ReadDICOM_Image.returnAffineArray(self.images[0])
    except Exception as e:
        print(&#39;Error in Series.Affine: &#39; + str(e))
        logger.exception(&#39;Error in Series.Affine: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.Imaginary"><code class="name">var <span class="ident">Imaginary</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Imaginary(self):
    logger.info(&#34;Series.Imaginary called&#34;)
    try:
        dicomList = self.PydicomList
        imaginarySeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
        imaginarySeries.remove(all_images=True)
        imaginarySeries.referencePathsList = self.images
        for index in range(len(self.images)):
            _, _, _, flagImaginary, _ = ReadDICOM_Image.checkImageType(dicomList[index])
            #if isinstance(flagImaginary, list) and flagImaginary:
            #    if len(flagImaginary) &gt; 1 and len(self.images) == 1:
            #        imaginarySeries.indices = flagImaginary
            #    imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            if flagImaginary:
                imaginarySeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
        return imaginarySeries
    except Exception as e:
        print(&#39;Error in Series.Imaginary: &#39; + str(e))
        logger.exception(&#39;Error in Series.Imaginary: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.ListAffines"><code class="name">var <span class="ident">ListAffines</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ListAffines(self):
    logger.info(&#34;Series.ListAffines called&#34;)
    try:
        return [ReadDICOM_Image.returnAffineArray(image) for image in self.images]
    except Exception as e:
        print(&#39;Error in Series.ListAffines: &#39; + str(e))
        logger.exception(&#39;Error in Series.ListAffines: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.Magnitude"><code class="name">var <span class="ident">Magnitude</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Magnitude(self):
    logger.info(&#34;Series.Magnitude called&#34;)
    try:
        dicomList = self.PydicomList
        magnitudeSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
        magnitudeSeries.remove(all_images=True)
        magnitudeSeries.referencePathsList = self.images
        for index in range(len(self.images)):
            flagMagnitude, _, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
            #if isinstance(flagMagnitude, list) and flagMagnitude:
            #    if len(flagMagnitude) &gt; 1 and len(self.images) == 1:
            #        magnitudeSeries.indices = flagMagnitude
            #    magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            if flagMagnitude == True:
                magnitudeSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
        return magnitudeSeries
    except Exception as e:
        print(&#39;Error in Series.Magnitude: &#39; + str(e))
        logger.exception(&#39;Error in Series.Magnitude: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.Phase"><code class="name">var <span class="ident">Phase</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Phase(self):
    logger.info(&#34;Series.Phase called&#34;)
    try:
        dicomList = self.PydicomList
        phaseSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
        phaseSeries.remove(all_images=True)
        phaseSeries.referencePathsList = self.images
        for index in range(len(self.images)):
            _, flagPhase, _, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
            #if isinstance(flagPhase, list) and flagPhase:
            #    if len(flagPhase) &gt; 1 and len(self.images) == 1:
            #        phaseSeries.indices = flagPhase
            #    phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            if flagPhase == True:
                phaseSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
        return phaseSeries
    except Exception as e:
        print(&#39;Error in Series.Phase: &#39; + str(e))
        logger.exception(&#39;Error in Series.Phase: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.PixelArray"><code class="name">var <span class="ident">PixelArray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PixelArray(self):
    logger.info(&#34;Series.PixelArray called&#34;)
    try:
        pixelArray = PixelArrayDICOMTools.getPixelArrayFromDICOM(self.images)
        return pixelArray
    except Exception as e:
        print(&#39;Error in Series.PixelArray: &#39; + str(e))
        logger.exception(&#39;Error in Series.PixelArray: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.PydicomList"><code class="name">var <span class="ident">PydicomList</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PydicomList(self):
    if self.images:
        return PixelArrayDICOMTools.getDICOMobject(self.images)
    else:
        return []</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.ROIindices"><code class="name">var <span class="ident">ROIindices</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ROIindices(self):
    logger.info(&#34;Series.ROIindices called&#34;)
    try:
        tempImage = self.PixelArray
        tempImage[tempImage != 0] = 1
        return np.transpose(np.where(tempImage == 1))
    except Exception as e:
        print(&#39;Error in Series.ROIindices: &#39; + str(e))
        logger.exception(&#39;Error in Series.ROIindices: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.Real"><code class="name">var <span class="ident">Real</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Real(self):
    logger.info(&#34;Series.Real called&#34;)
    try:
        dicomList = self.PydicomList
        realSeries = Series(self.objWeasel, self.subjectID, self.studyID, self.seriesID, listPaths=self.images)
        realSeries.remove(all_images=True)
        realSeries.referencePathsList = self.images
        for index in range(len(self.images)):
            _, _, flagReal, _, _ = ReadDICOM_Image.checkImageType(dicomList[index])
            #if isinstance(flagReal, list) and flagReal:
            #    if len(flagReal) &gt; 1 and len(self.images) == 1:
            #        realSeries.indices = flagReal
            #    realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
            if flagReal:
                realSeries.add(Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, self.images[index]))
        return realSeries
    except Exception as e:
        print(&#39;Error in Series.Real: &#39; + str(e))
        logger.exception(&#39;Error in Series.Real: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.SeriesUID"><code class="name">var <span class="ident">SeriesUID</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def SeriesUID(self):
    if not self.images:
        self.seriesUID = None
    elif os.path.exists(self.images[0]):
        self.seriesUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;SeriesInstanceUID&#39;)
    else:
        self.seriesUID = None
    return self.seriesUID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.StudyUID"><code class="name">var <span class="ident">StudyUID</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def StudyUID(self):
    if not self.images:
        self.studyUID = None
    elif os.path.exists(self.images[0]):
        self.studyUID = ReadDICOM_Image.getImageTagValue(self.images[0], &#39;StudyInstanceUID&#39;)
    else:
        self.studyUID = None
    return self.studyUID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    logger.info(&#34;Series.children called&#34;)
    try:
        children = []
        if len(self.images) &gt; 1:
            for imagePath in self.images:
                image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
                children.append(image)
        else:
            seriesXML = self.objWeasel.objXMLReader.getSeries(self.subjectID, self.studyID, self.seriesID)
            for imageXML in seriesXML:
                image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imageXML.find(&#39;name&#39;).text)
                children.append(image)
        return ImagesList(children)
    except Exception as e:
        print(&#39;Error in Series.children: &#39; + str(e))
        logger.exception(&#39;Error in Series.children: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.images"><code class="name">var <span class="ident">images</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    logger.info(&#34;Series.label called&#34;)
    try:
        return self.seriesID
    except Exception as e:
        print(&#39;Error in Series.label: &#39; + str(e))
        logger.exception(&#39;Error in Series.label: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.number_children"><code class="name">var <span class="ident">number_children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_children(self):
    return len(self.children)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.objWeasel"><code class="name">var <span class="ident">objWeasel</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    logger.info(&#34;Series.parent called&#34;)
    try:
        return Study(self.objWeasel, self.subjectID, self.studyID, studyUID=self.studyUID)
    except Exception as e:
        print(&#39;Error in Series.parent: &#39; + str(e))
        logger.exception(&#39;Error in Series.parent: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.referencePathsList"><code class="name">var <span class="ident">referencePathsList</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.seriesID"><code class="name">var <span class="ident">seriesID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.seriesUID"><code class="name">var <span class="ident">seriesUID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.studyID"><code class="name">var <span class="ident">studyID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.studyUID"><code class="name">var <span class="ident">studyUID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.subjectID"><code class="name">var <span class="ident">subjectID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Series.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Series.Item"><code class="name flex">
<span>def <span class="ident">Item</span></span>(<span>self, tagDescription, newValue=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Item(self, tagDescription, newValue=None):
    if self.images:
        if newValue:
            GenericDICOMTools.editDICOMTag(self.images, tagDescription, newValue)
            if (tagDescription == &#39;SeriesDescription&#39;) or (tagDescription == &#39;SequenceName&#39;) or (tagDescription == &#39;ProtocolName&#39;):
                self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_name=newValue)
            elif tagDescription == &#39;SeriesNumber&#39;:
                self.objWeasel.objXMLreader.renameSeriesinXMLFile(self.images, series_id=newValue)
        itemList, _ = ReadDICOM_Image.getSeriesTagValues(self.images, tagDescription)
        #if self.Multiframe: 
        #    tempList = [itemList[index] for index in self.indices]
        #    itemList = tempList
        #    del tempList
    else:
        itemList = []
    return itemList</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.Metadata"><code class="name flex">
<span>def <span class="ident">Metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Metadata(self):
    logger.info(&#34;Series.Metadata called&#34;)
    try:
        self.objWeasel.displayMetadata(self.images)
    except Exception as e:
        print(&#39;Error in Series.Metadata: &#39; + str(e))
        logger.exception(&#39;Error in Series.Metadata: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, Image)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, Image):
    logger.info(&#34;Series.add called&#34;)
    try:
        self.images.append(Image.path)
        # Might need XML functions
        #self.children.append(Image)
        #self.number_children = len(self.children)
    except Exception as e:
        print(&#39;Error in Series.add: &#39; + str(e))
        logger.exception(&#39;Error in Series.add: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, suffix='_Copy', newSeries=True, series_id=None, series_name=None, series_uid=None, study_uid=None, study_name=None, patient_id=None, output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, suffix=&#34;_Copy&#34;, newSeries=True, series_id=None, series_name=None, series_uid=None, study_uid=None, study_name=None, patient_id=None, output_dir=None):
    logger.info(&#34;Series.copy called&#34;)
    try:
        if newSeries == True:
            newPathsList, newSeriesID = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name,
                                                                    study_uid=study_uid, study_name=study_name, patient_id=patient_id, suffix=suffix, output_dir=output_dir)
            return Series(self.objWeasel, self.subjectID, self.studyID, newSeriesID, listPaths=newPathsList, suffix=suffix)
        else:
            series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
            series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
            series_uid = self.seriesUID
            suffix = self.suffix
            newPathsList, _ = GenericDICOMTools.copyDICOM(self.objWeasel, self.images, series_id=series_id, series_uid=series_uid, series_name=series_name, study_uid=study_uid,
                                                          study_name=study_name, patient_id=patient_id,suffix=suffix, output_dir=output_dir) # StudyID in InterfaceXML
            for newCopiedImagePath in newPathsList:
                newImage = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, newCopiedImagePath)
                self.add(newImage)
    except Exception as e:
        print(&#39;Error in Series.copy: &#39; + str(e))
        logger.exception(&#39;Error in Series.copy: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    logger.info(&#34;Series.delete called&#34;)
    try:
        GenericDICOMTools.deleteDICOM(self.objWeasel, self.images)
        self.images = self.referencePathsList = []
        #self.children = self.indices = []
        #self.number_children = 0
        self.subjectID = self.studyID = self.seriesID = self.seriesUID = &#39;&#39;
    except Exception as e:
        print(&#39;Error in Series.delete: &#39; + str(e))
        logger.exception(&#39;Error in Series.delete: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self):
    self.objWeasel.display(self)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.export_as_csv"><code class="name flex">
<span>def <span class="ident">export_as_csv</span></span>(<span>self, directory=None, filename=None, columnHeaders=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_as_csv(self, directory=None, filename=None, columnHeaders=None):
    logger.info(&#34;Series.export_as_csv called&#34;)
    try:
        if directory is None: directory = os.path.dirname(self.images[0])
        if self.number_children == 1:
            self.children[0].export_as_csv(directory=directory, filename=filename, columnHeaders=columnHeaders)
        else:
            table = self.PixelArray
            image_counter = 0
            for slice_image in table:
                if filename is None:
                    one_filename = os.path.join(directory, self.seriesID + &#39;_&#39; + str(image_counter).zfill(6) + &#39;.csv&#39;)
                else:
                    one_filename = os.path.join(directory, filename + &#39;_&#39; + str(image_counter).zfill(6) +&#39;.csv&#39;)
                if columnHeaders is None:
                    one_columHeaders = []
                    counter = 0
                    for _ in slice_image:
                        counter += 1
                        one_columHeaders.append(&#34;Column&#34; + str(counter))
                df = pd.DataFrame(np.transpose(slice_image), columns=one_columHeaders)
                df.to_csv(one_filename, index=False)
                image_counter += 1
    except Exception as e:
        print(&#39;Error in Series.export_as_csv: &#39; + str(e))
        logger.exception(&#39;Error in Series.export_as_csv: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.export_as_nifti"><code class="name flex">
<span>def <span class="ident">export_as_nifti</span></span>(<span>self, directory=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_as_nifti(self, directory=None, filename=None):
    logger.info(&#34;Series.export_as_nifti called&#34;)
    try:
        if directory is None: directory=os.path.dirname(self.images[0])
        if filename is None: filename=self.seriesID
        dicomHeader = nib.nifti1.Nifti1DicomExtension(2, self.PydicomList[0])
        niftiObj = nib.Nifti1Image(np.flipud(np.rot90(np.transpose(self.PixelArray))), self.Affine)
        # The transpose is necessary in this case to be in line with the rest of Weasel. The rot90() can be a bit questionable, so this should be tested in as much data as possible.
        niftiObj.header.extensions.append(dicomHeader)
        nib.save(niftiObj, directory + &#39;/&#39; + filename + &#39;.nii.gz&#39;)
    except Exception as e:
        print(&#39;Error in Series.export_as_nifti: &#39; + str(e))
        logger.exception(&#39;Error in Series.export_as_nifti: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, tag):
    logger.info(&#34;Series.get_value called&#34;)
    try:
        if self.images:
            if isinstance(tag, list):
                outputValuesList = []
                for ind_tag in tag:
                    if (ind_tag == &#34;SliceLocation&#34; or ind_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): ind_tag = (0x2001, 0x100a)
                    outputValuesList.append(ReadDICOM_Image.getSeriesTagValues(self.images, ind_tag)[0])
                return outputValuesList
            elif isinstance(tag, str) and len(tag.split(&#39; &#39;)) == 3:
                dicom_tag = tag.split(&#39; &#39;)[0]
                if (dicom_tag == &#34;SliceLocation&#34; or dicom_tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): dicom_tag = (0x2001, 0x100a)
                logical_operator = tag.split(&#39; &#39;)[1]
                target_value = tag.split(&#39; &#39;)[2]
                series_to_return = copy.copy(self)
                series_to_return.where(dicom_tag, logical_operator, target_value)
                list_of_images = series_to_return.children
                return list_of_images
            elif isinstance(tag, int):
                return self.children[tag]
            else:
                if (tag == &#34;SliceLocation&#34; or tag == (0x0020,0x1041)) and not hasattr(self.PydicomList[0], &#34;SliceLocation&#34;): tag = (0x2001, 0x100a)
                return ReadDICOM_Image.getSeriesTagValues(self.images, tag)[0]
        else:
            return []
    except Exception as e:
        print(&#39;Error in Series.get_value: &#39; + str(e))
        logger.exception(&#39;Error in Series.get_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.load_mask"><code class="name flex">
<span>def <span class="ident">load_mask</span></span>(<span>self, maskInstance)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the PixelArray masked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_mask(self, maskInstance):
    &#34;&#34;&#34;Returns the PixelArray masked.&#34;&#34;&#34;
    logger.info(&#34;Series.Mask called&#34;)
    try:
        dataset = maskInstance.PydicomList
        mask_array = maskInstance.PixelArray
        mask_array[mask_array != 0] = 1
        mask_output = []
        if isinstance(maskInstance, Image):
            for dicomFile in self.images:
                dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                if affine_results:
                    coords = zip(*affine_results)
                    tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
            return np.nan_to_num(mask_output)
        elif isinstance(maskInstance, Series):
            listImages = self.images
            listMaskImages = maskInstance.images
            for dicomFile in listImages:
                dataset_original = ReadDICOM_Image.getDicomDataset(dicomFile)
                tempArray = np.zeros(np.shape(ReadDICOM_Image.getPixelArray(dataset_original)))
                for maskFile in listMaskImages:
                    dataset = ReadDICOM_Image.getDicomDataset(maskFile)
                    mask_array = ReadDICOM_Image.getPixelArray(dataset)
                    mask_array[mask_array != 0] = 1
                    affine_results = ReadDICOM_Image.mapMaskToImage(mask_array, dataset, dataset_original)
                    if affine_results:
                        coords = zip(*affine_results)
                        tempArray[tuple(coords)] = list(np.ones(len(affine_results)).flatten())
                mask_output.append(np.transpose(tempArray) * ReadDICOM_Image.getPixelArray(dataset_original))
            return np.nan_to_num(mask_output)
    except Exception as e:
        print(&#39;Error in Series.Mask: &#39; + str(e))
        logger.exception(&#39;Error in Series.Mask: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, suffix='_Copy', series_id=None, series_name=None, series_uid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self, suffix=&#34;_Copy&#34;, series_id=None, series_name=None, series_uid=None):
    logger.info(&#34;Series.new called&#34;)
    try:
        if series_id is None:
            series_id, _ = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images)
        if series_name is None:
            series_name = self.seriesID.split(&#39;_&#39;, 1)[1] + suffix
        if series_uid is None:
            _, series_uid = GenericDICOMTools.generateSeriesIDs(self.objWeasel, self.images, seriesNumber=series_id)
        seriesID = str(series_id) + &#39;_&#39; + series_name
        newSeries = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, seriesUID=series_uid, suffix=suffix)
        newSeries.referencePathsList = self.images
        return newSeries
    except Exception as e:
        print(&#39;Error in Series.new: &#39; + str(e))
        logger.exception(&#39;Error in Series.new: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, xlabel='X axis', ylabel='Y axis')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, xlabel=&#34;X axis&#34;, ylabel=&#34;Y axis&#34;):
    logger.info(&#34;Series.plot called&#34;)
    try:
        for imagePath in self.images:
            image = Image(self.objWeasel, self.subjectID, self.studyID, self.seriesID, imagePath)
            image.plot(xlabel, ylabel)
    except Exception as e:
        print(&#39;Error in Series.plot: &#39; + str(e))
        logger.exception(&#39;Error in Series.plot: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    return self.PydicomList</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, all_images=False, Image=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, all_images=False, Image=None):
    logger.info(&#34;Series.remove called&#34;)
    try:
        if all_images == True:
            self.images = []
            # Might need XML functions
            #self.children = []
            #self.number_children = 0
        elif Image is not None:
            self.images.remove(Image.path)
            # Might need XML functions
            #self.children.remove(Image)
            #self.number_children = len(self.children)
    except Exception as e:
        print(&#39;Error in Series.remove: &#39; + str(e))
        logger.exception(&#39;Error in Series.remove: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, PydicomList)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, PydicomList):
    newSubjectID = self.subjectID
    newStudyID = self.studyID
    newSeriesID = self.seriesID
    for index, dataset in enumerate(PydicomList):
        changeXML = False
        if dataset.SeriesDescription != self.PydicomList[index].SeriesDescription or dataset.SeriesNumber != self.PydicomList[index].SeriesNumber:
            changeXML = True
            newSeriesID = str(dataset.SeriesNumber) + &#34;_&#34; + str(dataset.SeriesDescription)
        if dataset.StudyDate != self.PydicomList[index].StudyDate or dataset.StudyTime != self.PydicomList[index].StudyTime or dataset.StudyDescription != self.PydicomList[index].StudyDescription:
            changeXML = True
            newStudyID = str(dataset.StudyDate) + &#34;_&#34; + str(dataset.StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(dataset.StudyDescription)
        if dataset.PatientID != self.PydicomList[index].PatientID:
            changeXML = True
            newSubjectID = str(dataset.PatientID)
        SaveDICOM_Image.saveDicomToFile(dataset, output_path=self.images[index])
        if changeXML == True:
            self.objWeasel.objXMLReader.moveImageInXMLFile(self.subjectID, self.studyID, self.seriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
    # Only after updating the Element Tree (XML), we can change the instance values and save the DICOM file
    self.subjectID = newSubjectID
    self.studyID = newStudyID
    self.seriesID = newSeriesID</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, tag, newValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, tag, newValue):
    logger.info(&#34;Series.set_value called&#34;)
    try:
        if self.images:
            comparisonDicom = self.PydicomList
            oldSubjectID = self.subjectID
            oldStudyID = self.studyID
            oldSeriesID = self.seriesID
            if isinstance(tag, list) and isinstance(newValue, list):
                for index, ind_tag in enumerate(tag):
                    self.set_value(ind_tag, newValue[index])
                    #GenericDICOMTools.editDICOMTag(self.images, ind_tag, newValue[index])
            elif isinstance(newValue, list):
                for value in newValue:
                    GenericDICOMTools.editDICOMTag(self.images, tag, value)
            else:
                GenericDICOMTools.editDICOMTag(self.images, tag, newValue)
            newDicomList = self.PydicomList
            # Consider the case where other XML fields are changed
            for index, dataset in enumerate(comparisonDicom):
                changeXML = False
                if dataset.SeriesDescription != newDicomList[index].SeriesDescription or dataset.SeriesNumber != newDicomList[index].SeriesNumber:
                    changeXML = True
                    newSeriesID = str(newDicomList[index].SeriesNumber) + &#34;_&#34; + str(newDicomList[index].SeriesDescription)
                    self.seriesID = newSeriesID
                else:
                    newSeriesID = oldSeriesID
                if dataset.StudyDate != newDicomList[index].StudyDate or dataset.StudyTime != newDicomList[index].StudyTime or dataset.StudyDescription != newDicomList[index].StudyDescription:
                    changeXML = True
                    newStudyID = str(newDicomList[index].StudyDate) + &#34;_&#34; + str(newDicomList[index].StudyTime).split(&#34;.&#34;)[0] + &#34;_&#34; + str(newDicomList[index].StudyDescription)
                    self.studyID = newStudyID
                else:
                    newStudyID = oldStudyID
                if dataset.PatientID != newDicomList[index].PatientID:
                    changeXML = True
                    newSubjectID = str(newDicomList[index].PatientID)
                    self.subjectID = newSubjectID
                else:
                    newSubjectID = oldSubjectID
                if changeXML == True:
                    self.objWeasel.objXMLReader.moveImageInXMLFile(oldSubjectID, oldStudyID, oldSeriesID, newSubjectID, newStudyID, newSeriesID, self.images[index], &#39;&#39;)
    except Exception as e:
        print(&#39;Error in Series.set_value: &#39; + str(e))
        logger.exception(&#39;Error in Series.set_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, *argv, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, *argv, reverse=False):
    logger.info(&#34;Series.sort called&#34;)
    try:
        tuple_to_sort = []
        list_to_sort = [self.images]
        for tag in argv:
            if len(self.get_value(tag)) &gt; 0:
                list_to_sort.append(self.get_value(tag))
        for index in range(len(self.images)):
            individual_tuple = [individual_list[index] for individual_list in list_to_sort]
            tuple_to_sort.append(tuple(individual_tuple))
        tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[1:], reverse=reverse)
        list_sorted_images = [individual[0] for individual in tuple_sorted]
        self.images = list_sorted_images
        return self
    except Exception as e:
        print(&#39;Error in Series.sort: &#39; + str(e))
        logger.exception(&#39;Error in Series.sort: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>self, tag, condition, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(self, tag, condition, target):
    logger.info(&#34;Series.where called&#34;)
    try:
        list_images = []
        list_paths = []
        for image in self.children:
            value = image[tag]
            if condition == &#34;==&#34;:
                statement = &#39;str(&#39; + repr(value) + &#39;) &#39; + condition + &#39; str(&#39; + repr(target) + &#39;)&#39;
                if eval(statement) == True:
                    list_images.append(image)
                    list_paths.append(image.path)
            else:
                statement = repr(value) + &#39; &#39; + repr(condition) + &#39; &#39; + repr(target)
                if eval(literal_eval(statement)) == True:
                    list_images.append(image)
                    list_paths.append(image.path)
        self.images = list_paths
        return self
    except Exception as e:
        print(&#39;Error in Series.where: &#39; + str(e))
        logger.exception(&#39;Error in Series.where: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, pixelArray, output_dir=None, value_range=None, parametric_map=None, colourmap=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, pixelArray, output_dir=None, value_range=None, parametric_map=None, colourmap=None):
    logger.info(&#34;Series.write called&#34;)
    try:
        if isinstance(value_range, list):
            pixelArray = np.clip(pixelArray, value_range[0], value_range[1])
        else:
            list_values = np.unique(pixelArray).flatten()
            list_values = [x for x in list_values if np.isnan(x) == False]
            if np.isposinf(list_values[-1]) or np.isinf(list_values[-1]):
                upper_value = list_values[-2]
            else:
                upper_value = None
            if np.isneginf(list_values[0]) or np.isinf(list_values[0]):
                lower_value = list_values[1]
            else:
                lower_value = None
            pixelArray = np.nan_to_num(pixelArray, posinf=upper_value, neginf=lower_value)
        if self.images:
            PixelArrayDICOMTools.overwritePixelArray(pixelArray, self.images)
        else:
            series_id = self.seriesID.split(&#39;_&#39;, 1)[0]
            series_name = self.seriesID.split(&#39;_&#39;, 1)[1]
            inputReference = self.referencePathsList[0] if len(self.referencePathsList)==1 else self.referencePathsList
            outputPath = PixelArrayDICOMTools.writeNewPixelArray(self.objWeasel, pixelArray, inputReference, self.suffix, series_id=series_id, series_name=series_name, series_uid=self.seriesUID, output_dir=output_dir, parametric_map=parametric_map, colourmap=colourmap)
            self.images = outputPath
            if self[&#34;WindowWidth&#34;] and self[&#34;WindowCenter&#34;] and isinstance(value_range, list):
                width = value_range[1] - value_range[0]
                center = value_range[0] + (width/2)
                self[&#34;WindowWidth&#34;] = width
                self[&#34;WindowCenter&#34;] = center
    except Exception as e:
        print(&#39;Error in Series.write: &#39; + str(e))
        logger.exception(&#39;Error in Series.write: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Series.write_mask"><code class="name flex">
<span>def <span class="ident">write_mask</span></span>(<span>self, mask_array, label=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_mask(self, mask_array, label=None):
    logger.info(&#34;Series.write_mask called&#34;)
    try:
        if label is not None:
            self.suffix = &#34;_&#34; + label
        self.write_mask(mask_array, parametric_map=&#34;SEG&#34;)
    except Exception as e:
        print(&#39;Error in Series.write_mask: &#39; + str(e))
        logger.exception(&#39;Error in Series.write_mask: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.SeriesList"><code class="flex name class">
<span>class <span class="ident">SeriesList</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing a list of class Series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeriesList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Series. 
    &#34;&#34;&#34;  
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of series.
        &#34;&#34;&#34;
        copy = []
        for series in self:
            copy.append(series.copy())
        return SeriesList(copy)

    def merge(self, series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)  

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique studies to which the series belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for series in self:
            study = series.parent
            listIndividualAttributes = [study.subjectID, study.studyID, study.studyUID, study.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            study = Study(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3])
            parentsList.append(study)
        return StudyList(parentsList)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of images where each list refers to the various images of a series.
        &#34;&#34;&#34;
        childrenList = []
        for series in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(series.children)
        return childrenList</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></li>
<li>builtins.list</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.SeriesList.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of lists of images where each list refers to the various images of a series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    &#34;&#34;&#34;
    Returns a list of lists of images where each list refers to the various images of a series.
    &#34;&#34;&#34;
    childrenList = []
    for series in self:
        # We&#39;re returning list of lists by using append.
        # If we want a flat list, we&#39;ll have to use extend instead.
        childrenList.append(series.children)
    return childrenList</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.SeriesList.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of unique studies to which the series belong to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;
    Returns a list of unique studies to which the series belong to.
    &#34;&#34;&#34;
    parentsList = []
    listParentsAttribute = []
    for series in self:
        study = series.parent
        listIndividualAttributes = [study.subjectID, study.studyID, study.studyUID, study.suffix]
        listParentsAttribute.append(listIndividualAttributes)
    listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
    for listAtt in listUniqueParentsAttribute:
        study = Study(self[0].objWeasel, listAtt[0], listAtt[1], listAtt[2], listAtt[3])
        parentsList.append(study)
    return StudyList(parentsList)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.SeriesList.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the list of series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Returns a copy of the list of series.
    &#34;&#34;&#34;
    copy = []
    for series in self:
        copy.append(series.copy())
    return SeriesList(copy)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.SeriesList.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, series_name='MergedSeries', study_name=None, patient_name=None, overwrite=True, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges a list of series into a new series under the same study</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, series_name=&#39;MergedSeries&#39;, study_name=None, patient_name=None, overwrite=True, progress_bar=True):
    &#34;&#34;&#34;
    Merges a list of series into a new series under the same study
    &#34;&#34;&#34;
    if len(self) == 0: return
    return self[0].merge(self, series_name=series_name, study_name=study_name, patient_id=patient_name, overwrite=overwrite, progress_bar=progress_bar)  </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.delete" href="#Weasel.DICOM.Classes.ListOfDicomObjects.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.display" href="#Weasel.DICOM.Classes.ListOfDicomObjects.display">display</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Weasel.DICOM.Classes.Study"><code class="flex name class">
<span>class <span class="ident">Study</span></span>
<span>(</span><span>objWeasel, subjectID, studyID, studyUID=None, suffix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class encloses all DICOM files that share the same tag value of "StudyInstanceUID", "StudyDescription", "StudyDate" and "StudyTime".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objWeasel</code></strong> :&ensp;<code>the <a title="Weasel" href="../index.html">Weasel</a> global variable</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>subjectID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the subject, which is stored in the "PatientID" DICOM tag.</dd>
<dt><strong><code>studyID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the study, which is stored in the "StudyDescription" DICOM tag.</dd>
<dt><strong><code>studyUID</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the unique identification of the study, which is stored in the "StudyInstanceUID" DICOM tag.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the text to append to subjectID if a new Study() class is created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Study:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;StudyInstanceUID&#34;, &#34;StudyDescription&#34;, &#34;StudyDate&#34; and &#34;StudyTime&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        studyID : string
            This is the name or identification of the study, which is stored in the &#34;StudyDescription&#34; DICOM tag.
        studyUID : string (optional)
            This is the unique identification of the study, which is stored in the &#34;StudyInstanceUID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Study() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;studyID&#39;, &#39;studyUID&#39;, &#39;suffix&#39;)
    def __init__(self, objWeasel, subjectID, studyID, studyUID=None, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.studyID = studyID
        self.studyUID = self.StudyUID if studyUID is None else studyUID
        self.suffix = &#39;&#39; if suffix is None else suffix
    
    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)

    @property
    def children(self):
        logger.info(&#34;Study.children called&#34;)
        try:
            children = []
            studyXML = self.objWeasel.objXMLReader.getStudy(self.subjectID, self.studyID)
            if studyXML:
                for seriesXML in studyXML:
                    seriesID = seriesXML.attrib[&#39;id&#39;]
                    images = []
                    for imageXML in seriesXML:
                        images.append(imageXML.find(&#39;name&#39;).text)
                    series = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, listPaths=images)
                    children.append(series)
            return SeriesList(children)
        except Exception as e:
            print(&#39;Error in Study.children: &#39; + str(e))
            logger.exception(&#39;Error in Study.children: &#39; + str(e))
    
    @property
    def parent(self):
        logger.info(&#34;Study.parent called&#34;)
        try:
            return Subject(self.objWeasel, self.subjectID)
        except Exception as e:
            print(&#39;Error in Study.parent: &#39; + str(e))
            logger.exception(&#39;Error in Study.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)

    @property
    def label(self):
        logger.info(&#34;Study.label called&#34;)
        try:
            return self.studyID
        except Exception as e:
            print(&#39;Error in Study.label: &#39; + str(e))
            logger.exception(&#39;Error in Study.label: &#39; + str(e))

    @property
    def all_images(self):
        logger.info(&#34;Study.all_images called&#34;)
        try:
            listImages = []
            for series in self.children:
                listImages.extend(series.children)
            return ImagesList(listImages)
        except Exception as e:
            print(&#39;Error in Study.all_images: &#39; + str(e))
            logger.exception(&#39;Error in Study.all_images: &#39; + str(e))

    def new(self, suffix=&#34;_Copy&#34;, studyID=None):
        logger.info(&#34;Study.new called&#34;)
        try:
            if studyID is None:
                studyID = self.studyID + suffix
            else:
                dt = datetime.datetime.now()
                time = dt.strftime(&#39;%H%M%S&#39;)
                date = dt.strftime(&#39;%Y%m%d&#39;)
                studyID = date + &#34;_&#34; + time + &#34;_&#34; + studyID + suffix
            prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
            study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
            return Study(self.objWeasel, self.subjectID, studyID, studyUID=study_uid, suffix=suffix)
        except Exception as e:
            print(&#39;Error in Study.new: &#39; + str(e))
            logger.exception(&#39;Error in Study.new: &#39; + str(e))

    def copy(self, suffix=&#34;_Copy&#34;, newSubjectID=None, output_dir=None):
        logger.info(&#34;Study.copy called&#34;)
        try:
            if newSubjectID:
                prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
                study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
                newStudyInstance = Study(self.objWeasel, newSubjectID, self.studyID + suffix, studyUID=study_uid, suffix=suffix)
            else:
                newStudyInstance = self.new(suffix=suffix)
            seriesPathsList = []
            for series in self.children:
                copiedSeries = series.copy(suffix=suffix, series_id=series.seriesID.split(&#39;_&#39;, 1)[0], series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=newStudyInstance.studyUID,
                                           study_name=newStudyInstance.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=newSubjectID, output_dir=output_dir)
                seriesPathsList.append(copiedSeries.images)
            #interfaceDICOMXMLFile.insertNewStudyInXMLFile(newStudyInstance.objWeasel, newStudyInstance.subjectID, newStudyInstance.studyID, suffix, seriesList=seriesPathsList)
            return newStudyInstance
        except Exception as e:
            print(&#39;Error in Study.copy: &#39; + str(e))
            logger.exception(&#39;Error in Study.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Study.delete called&#34;)
        try:
            for series in self.children:
                series.delete()
            #interfaceDICOMXMLFile.removeOneStudyFromSubject(self.objWeasel, self.subjectID, self.studyID)
            self.subjectID = self.studyID = &#39;&#39;
        except Exception as e:
            print(&#39;Error in Study.delete: &#39; + str(e))
            logger.exception(&#39;Error in Study.delete: &#39; + str(e))
    
    def add(self, series):
        logger.info(&#34;Study.add called&#34;)
        try:
            series[&#34;PatientID&#34;] = self.subjectID
            series[&#34;StudyDate&#34;] = self.studyID.split(&#34;_&#34;)[0]
            series[&#34;StudyTime&#34;] = self.studyID.split(&#34;_&#34;)[1]
            series[&#34;StudyDescription&#34;] = &#34;&#34;.join(self.studyID.split(&#34;_&#34;)[2:])
            series[&#34;StudyInstanceUID&#34;] = self.studyUID
            # Need to adapt the series to the new Study
            seriesNewID, seriesNewUID = GenericDICOMTools.generateSeriesIDs(self.objWeasel, series.images, studyUID=self.studyUID)
            series[&#34;SeriesNumber&#34;] = seriesNewID
            series[&#34;SeriesInstanceUID&#34;] = seriesNewUID
        except Exception as e:
            print(&#39;Error in Study.add: &#39; + str(e))
            logger.exception(&#39;Error in Study.add: &#39; + str(e))

    @staticmethod
    def merge(listStudies, newStudyName=None, suffix=&#39;_Merged&#39;, overwrite=False, output_dir=None, progress_bar=True):
        logger.info(&#34;Study.merge called&#34;)
        try:
            if newStudyName:
                prefixUID = &#39;.&#39;.join(listStudies[0].studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
                study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
                newStudyID = listStudies[0].studyID.split(&#39;_&#39;)[0] + &#34;_&#34; + listStudies[0].studyID.split(&#39;_&#39;)[1] + &#34;_&#34; + newStudyName
                outputStudy = Study(listStudies[0].objWeasel, listStudies[0].subjectID, newStudyID, studyUID=study_uid)
            else:
                outputStudy = listStudies[0].new(suffix=suffix)
            # Set up Progress Bar
            progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listStudies)) + &#34; Studies&#34;
            if progress_bar == True: 
                listStudies[0].objWeasel.progress_bar(
                    msg = (&#34;&lt;H4&gt;Merging {} Studies&lt;/H4&gt;&#34;).format(len(listStudies)),
                    index = 0, max = len(listStudies))
            # Add new study (outputStudy) to XML
            seriesPathsList = []
            if overwrite == False:
                for index, study in enumerate(listStudies):
                    if progress_bar == True: 
                        listStudies[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listStudies))
                    seriesNumber = 1
                    for series in study.children:
                        copiedSeries = series.copy(suffix=suffix, series_id=seriesNumber, series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=outputStudy.studyUID,
                                                   study_name=outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=outputStudy.subjectID, output_dir=output_dir)
                        seriesPathsList.append(copiedSeries.images)
                        seriesNumber += 1
            else:
                seriesNumber = 1
                for index, study in enumerate(listStudies):
                    if progress_bar == True: 
                        listStudies[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listStudies))
                    for series in study.children:
                        series.Item(&#39;PatientID&#39;, outputStudy.subjectID)
                        series.Item(&#39;StudyInstanceUID&#39;, outputStudy.studyUID)
                        series.Item(&#39;StudyDescription&#39;, outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1])
                        series.Item(&#39;SeriesNumber&#39;, seriesNumber)
                        # Generate new series uid based on outputStudy.studyUID
                        _, new_series_uid = GenericDICOMTools.generateSeriesIDs(series.objWeasel, series.images, seriesNumber=seriesNumber, studyUID=outputStudy.studyUID)
                        series.Item(&#39;SeriesInstanceUID&#39;, new_series_uid)
                        seriesPathsList.append(series.images)
                        seriesNumber += 1
                    study.objWeasel.objXMLReader.removeOneStudyFromSubject(study.subjectID, study.studyID)
            outputStudy.objWeasel.objXMLReader.insertNewStudyInXMLFile(outputStudy.subjectID, outputStudy.studyID, suffix, seriesList=seriesPathsList)
            return outputStudy
        except Exception as e:
            print(&#39;Error in Study.merge: &#39; + str(e))
            logger.exception(&#39;Error in Study.merge: &#39; + str(e))

    @property
    def StudyUID(self):
        if len(self.children) &gt; 0:
            return self.children[0].studyUID
        else:
            return pydicom.uid.generate_uid(prefix=None)
    
    def get_value(self, tag):
        logger.info(&#34;Study.get_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                seriesOutputValuesList = []
                for series in self.children:
                    seriesOutputValuesList.append(series.get_value(tag)) # extend will allow long single list, while append creates list of lists.
                return seriesOutputValuesList
            else:
                return []
        except Exception as e:
            print(&#39;Error in Study.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Study.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Study.set_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                for series in self.children:
                    series.set_value(tag, newValue)
        except Exception as e:
            print(&#39;Error in Study.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Study.set_value: &#39; + str(e))

    
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Study.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>listStudies, newStudyName=None, suffix='_Merged', overwrite=False, output_dir=None, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def merge(listStudies, newStudyName=None, suffix=&#39;_Merged&#39;, overwrite=False, output_dir=None, progress_bar=True):
    logger.info(&#34;Study.merge called&#34;)
    try:
        if newStudyName:
            prefixUID = &#39;.&#39;.join(listStudies[0].studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
            study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
            newStudyID = listStudies[0].studyID.split(&#39;_&#39;)[0] + &#34;_&#34; + listStudies[0].studyID.split(&#39;_&#39;)[1] + &#34;_&#34; + newStudyName
            outputStudy = Study(listStudies[0].objWeasel, listStudies[0].subjectID, newStudyID, studyUID=study_uid)
        else:
            outputStudy = listStudies[0].new(suffix=suffix)
        # Set up Progress Bar
        progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listStudies)) + &#34; Studies&#34;
        if progress_bar == True: 
            listStudies[0].objWeasel.progress_bar(
                msg = (&#34;&lt;H4&gt;Merging {} Studies&lt;/H4&gt;&#34;).format(len(listStudies)),
                index = 0, max = len(listStudies))
        # Add new study (outputStudy) to XML
        seriesPathsList = []
        if overwrite == False:
            for index, study in enumerate(listStudies):
                if progress_bar == True: 
                    listStudies[0].objWeasel.progress_bar(
                        msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                        index = index+1, max = len(listStudies))
                seriesNumber = 1
                for series in study.children:
                    copiedSeries = series.copy(suffix=suffix, series_id=seriesNumber, series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=outputStudy.studyUID,
                                               study_name=outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=outputStudy.subjectID, output_dir=output_dir)
                    seriesPathsList.append(copiedSeries.images)
                    seriesNumber += 1
        else:
            seriesNumber = 1
            for index, study in enumerate(listStudies):
                if progress_bar == True: 
                    listStudies[0].objWeasel.progress_bar(
                        msg = (&#34;&lt;H4&gt;Merging study &#34; + study.studyID + &#34;&lt;/H4&gt;&#34;),
                        index = index+1, max = len(listStudies))
                for series in study.children:
                    series.Item(&#39;PatientID&#39;, outputStudy.subjectID)
                    series.Item(&#39;StudyInstanceUID&#39;, outputStudy.studyUID)
                    series.Item(&#39;StudyDescription&#39;, outputStudy.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1])
                    series.Item(&#39;SeriesNumber&#39;, seriesNumber)
                    # Generate new series uid based on outputStudy.studyUID
                    _, new_series_uid = GenericDICOMTools.generateSeriesIDs(series.objWeasel, series.images, seriesNumber=seriesNumber, studyUID=outputStudy.studyUID)
                    series.Item(&#39;SeriesInstanceUID&#39;, new_series_uid)
                    seriesPathsList.append(series.images)
                    seriesNumber += 1
                study.objWeasel.objXMLReader.removeOneStudyFromSubject(study.subjectID, study.studyID)
        outputStudy.objWeasel.objXMLReader.insertNewStudyInXMLFile(outputStudy.subjectID, outputStudy.studyID, suffix, seriesList=seriesPathsList)
        return outputStudy
    except Exception as e:
        print(&#39;Error in Study.merge: &#39; + str(e))
        logger.exception(&#39;Error in Study.merge: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Study.StudyUID"><code class="name">var <span class="ident">StudyUID</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def StudyUID(self):
    if len(self.children) &gt; 0:
        return self.children[0].studyUID
    else:
        return pydicom.uid.generate_uid(prefix=None)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.all_images"><code class="name">var <span class="ident">all_images</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_images(self):
    logger.info(&#34;Study.all_images called&#34;)
    try:
        listImages = []
        for series in self.children:
            listImages.extend(series.children)
        return ImagesList(listImages)
    except Exception as e:
        print(&#39;Error in Study.all_images: &#39; + str(e))
        logger.exception(&#39;Error in Study.all_images: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    logger.info(&#34;Study.children called&#34;)
    try:
        children = []
        studyXML = self.objWeasel.objXMLReader.getStudy(self.subjectID, self.studyID)
        if studyXML:
            for seriesXML in studyXML:
                seriesID = seriesXML.attrib[&#39;id&#39;]
                images = []
                for imageXML in seriesXML:
                    images.append(imageXML.find(&#39;name&#39;).text)
                series = Series(self.objWeasel, self.subjectID, self.studyID, seriesID, listPaths=images)
                children.append(series)
        return SeriesList(children)
    except Exception as e:
        print(&#39;Error in Study.children: &#39; + str(e))
        logger.exception(&#39;Error in Study.children: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    logger.info(&#34;Study.label called&#34;)
    try:
        return self.studyID
    except Exception as e:
        print(&#39;Error in Study.label: &#39; + str(e))
        logger.exception(&#39;Error in Study.label: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.number_children"><code class="name">var <span class="ident">number_children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_children(self):
    return len(self.children)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.objWeasel"><code class="name">var <span class="ident">objWeasel</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Study.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    logger.info(&#34;Study.parent called&#34;)
    try:
        return Subject(self.objWeasel, self.subjectID)
    except Exception as e:
        print(&#39;Error in Study.parent: &#39; + str(e))
        logger.exception(&#39;Error in Study.parent: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.studyID"><code class="name">var <span class="ident">studyID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Study.studyUID"><code class="name">var <span class="ident">studyUID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Study.subjectID"><code class="name">var <span class="ident">subjectID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Study.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Study.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, series)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, series):
    logger.info(&#34;Study.add called&#34;)
    try:
        series[&#34;PatientID&#34;] = self.subjectID
        series[&#34;StudyDate&#34;] = self.studyID.split(&#34;_&#34;)[0]
        series[&#34;StudyTime&#34;] = self.studyID.split(&#34;_&#34;)[1]
        series[&#34;StudyDescription&#34;] = &#34;&#34;.join(self.studyID.split(&#34;_&#34;)[2:])
        series[&#34;StudyInstanceUID&#34;] = self.studyUID
        # Need to adapt the series to the new Study
        seriesNewID, seriesNewUID = GenericDICOMTools.generateSeriesIDs(self.objWeasel, series.images, studyUID=self.studyUID)
        series[&#34;SeriesNumber&#34;] = seriesNewID
        series[&#34;SeriesInstanceUID&#34;] = seriesNewUID
    except Exception as e:
        print(&#39;Error in Study.add: &#39; + str(e))
        logger.exception(&#39;Error in Study.add: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, suffix='_Copy', newSubjectID=None, output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, suffix=&#34;_Copy&#34;, newSubjectID=None, output_dir=None):
    logger.info(&#34;Study.copy called&#34;)
    try:
        if newSubjectID:
            prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
            study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
            newStudyInstance = Study(self.objWeasel, newSubjectID, self.studyID + suffix, studyUID=study_uid, suffix=suffix)
        else:
            newStudyInstance = self.new(suffix=suffix)
        seriesPathsList = []
        for series in self.children:
            copiedSeries = series.copy(suffix=suffix, series_id=series.seriesID.split(&#39;_&#39;, 1)[0], series_name=series.seriesID.split(&#39;_&#39;, 1)[1], study_uid=newStudyInstance.studyUID,
                                       study_name=newStudyInstance.studyID.split(&#39;_&#39;, 1)[1].split(&#39;_&#39;, 1)[1], patient_id=newSubjectID, output_dir=output_dir)
            seriesPathsList.append(copiedSeries.images)
        #interfaceDICOMXMLFile.insertNewStudyInXMLFile(newStudyInstance.objWeasel, newStudyInstance.subjectID, newStudyInstance.studyID, suffix, seriesList=seriesPathsList)
        return newStudyInstance
    except Exception as e:
        print(&#39;Error in Study.copy: &#39; + str(e))
        logger.exception(&#39;Error in Study.copy: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    logger.info(&#34;Study.delete called&#34;)
    try:
        for series in self.children:
            series.delete()
        #interfaceDICOMXMLFile.removeOneStudyFromSubject(self.objWeasel, self.subjectID, self.studyID)
        self.subjectID = self.studyID = &#39;&#39;
    except Exception as e:
        print(&#39;Error in Study.delete: &#39; + str(e))
        logger.exception(&#39;Error in Study.delete: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, tag):
    logger.info(&#34;Study.get_value called&#34;)
    try:
        if len(self.children) &gt; 0:
            seriesOutputValuesList = []
            for series in self.children:
                seriesOutputValuesList.append(series.get_value(tag)) # extend will allow long single list, while append creates list of lists.
            return seriesOutputValuesList
        else:
            return []
    except Exception as e:
        print(&#39;Error in Study.get_value: &#39; + str(e))
        logger.exception(&#39;Error in Study.get_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, suffix='_Copy', studyID=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self, suffix=&#34;_Copy&#34;, studyID=None):
    logger.info(&#34;Study.new called&#34;)
    try:
        if studyID is None:
            studyID = self.studyID + suffix
        else:
            dt = datetime.datetime.now()
            time = dt.strftime(&#39;%H%M%S&#39;)
            date = dt.strftime(&#39;%Y%m%d&#39;)
            studyID = date + &#34;_&#34; + time + &#34;_&#34; + studyID + suffix
        prefixUID = &#39;.&#39;.join(self.studyUID.split(&#34;.&#34;, maxsplit=6)[:5]) + &#34;.&#34; + str(random.randint(0, 9999)) + &#34;.&#34;
        study_uid = pydicom.uid.generate_uid(prefix=prefixUID)
        return Study(self.objWeasel, self.subjectID, studyID, studyUID=study_uid, suffix=suffix)
    except Exception as e:
        print(&#39;Error in Study.new: &#39; + str(e))
        logger.exception(&#39;Error in Study.new: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Study.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, tag, newValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, tag, newValue):
    logger.info(&#34;Study.set_value called&#34;)
    try:
        if len(self.children) &gt; 0:
            for series in self.children:
                series.set_value(tag, newValue)
    except Exception as e:
        print(&#39;Error in Study.set_value: &#39; + str(e))
        logger.exception(&#39;Error in Study.set_value: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.StudyList"><code class="flex name class">
<span>class <span class="ident">StudyList</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing a list of class Study.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StudyList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Study. 
    &#34;&#34;&#34;
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of studies.
        &#34;&#34;&#34;
        copy = []
        for study in self:
            copy.append(study.copy())
        return StudyList(copy)

    def merge(self, study_name=&#39;MergedStudies&#39;, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, newStudyName=study_name, overwrite=overwrite, progress_bar=progress_bar)

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns a list of unique subjects to which the studies belong to.
        &#34;&#34;&#34;
        parentsList = []
        listParentsAttribute = []
        for study in self:
            subject = study.parent
            listIndividualAttributes = [subject.subjectID, subject.suffix]
            listParentsAttribute.append(listIndividualAttributes)
        listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
        for listAtt in listUniqueParentsAttribute:
            subject = Subject(self[0].objWeasel, listAtt[0], listAtt[1])
            parentsList.append(subject)
        return SubjectList(parentsList)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of series where each list refers to the various series of a study.
        &#34;&#34;&#34;
        childrenList = []
        for study in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(study.children)
        return childrenList</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></li>
<li>builtins.list</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.StudyList.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of lists of series where each list refers to the various series of a study.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    &#34;&#34;&#34;
    Returns a list of lists of series where each list refers to the various series of a study.
    &#34;&#34;&#34;
    childrenList = []
    for study in self:
        # We&#39;re returning list of lists by using append.
        # If we want a flat list, we&#39;ll have to use extend instead.
        childrenList.append(study.children)
    return childrenList</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.StudyList.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of unique subjects to which the studies belong to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;
    Returns a list of unique subjects to which the studies belong to.
    &#34;&#34;&#34;
    parentsList = []
    listParentsAttribute = []
    for study in self:
        subject = study.parent
        listIndividualAttributes = [subject.subjectID, subject.suffix]
        listParentsAttribute.append(listIndividualAttributes)
    listUniqueParentsAttribute = self[0].objWeasel.unique_elements(listParentsAttribute)
    for listAtt in listUniqueParentsAttribute:
        subject = Subject(self[0].objWeasel, listAtt[0], listAtt[1])
        parentsList.append(subject)
    return SubjectList(parentsList)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.StudyList.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the list of studies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Returns a copy of the list of studies.
    &#34;&#34;&#34;
    copy = []
    for study in self:
        copy.append(study.copy())
    return StudyList(copy)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.StudyList.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, study_name='MergedStudies', overwrite=True, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges a list of series into a new series under the same study</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, study_name=&#39;MergedStudies&#39;, overwrite=True, progress_bar=True):
    &#34;&#34;&#34;
    Merges a list of series into a new series under the same study
    &#34;&#34;&#34;
    if len(self) == 0: return
    return self[0].merge(self, newStudyName=study_name, overwrite=overwrite, progress_bar=progress_bar)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.delete" href="#Weasel.DICOM.Classes.ListOfDicomObjects.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.display" href="#Weasel.DICOM.Classes.ListOfDicomObjects.display">display</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Weasel.DICOM.Classes.Subject"><code class="flex name class">
<span>class <span class="ident">Subject</span></span>
<span>(</span><span>objWeasel, subjectID, suffix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class encloses all DICOM files that share the same tag value of "PatientID".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objWeasel</code></strong> :&ensp;<code>the <a title="Weasel" href="../index.html">Weasel</a> global variable</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>subjectID</code></strong> :&ensp;<code>string</code></dt>
<dd>This is the name or identification of the subject, which is stored in the "PatientID" DICOM tag.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>This is the text to append to subjectID if a new Subject() class is created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Subject:
    &#34;&#34;&#34;This class encloses all DICOM files that share the same tag value of &#34;PatientID&#34;.

        Parameters
        ----------
        objWeasel : the Weasel global variable
        subjectID : string
            This is the name or identification of the subject, which is stored in the &#34;PatientID&#34; DICOM tag.
        suffix : string (optional)
            This is the text to append to subjectID if a new Subject() class is created.
    &#34;&#34;&#34;
    __slots__ = (&#39;objWeasel&#39;, &#39;subjectID&#39;, &#39;suffix&#39;)
    def __init__(self, objWeasel, subjectID, suffix=None):
        self.objWeasel = objWeasel
        self.subjectID = subjectID
        self.suffix = &#39;&#39; if suffix is None else suffix

    def __repr__(self):
       return &#39;{}&#39;.format(self.__class__.__name__)
    
    @property
    def children(self):
        logger.info(&#34;Subject.children called&#34;)
        try:
            children = []
            subjectXML = self.objWeasel.objXMLReader.getSubject(self.subjectID)
            if subjectXML:
                for studyXML in subjectXML:
                    studyID = studyXML.attrib[&#39;id&#39;]
                    study = Study(self.objWeasel, self.subjectID, studyID)
                    children.append(study)
            return StudyList(children)
        except Exception as e:
            print(&#39;Error in Subject.children: &#39; + str(e))
            logger.exception(&#39;Error in Subject.children: &#39; + str(e))

    @property
    def parent(self):
        logger.info(&#34;Subject.parent called&#34;)
        try:
            return Project(self.objWeasel)
        except Exception as e:
            print(&#39;Error in Subject.parent: &#39; + str(e))
            logger.exception(&#39;Error in Subject.parent: &#39; + str(e))

    @property
    def number_children(self):
        return len(self.children)
    
    @property
    def label(self):
        logger.info(&#34;Subject.label called&#34;)
        try:
            return self.subjectID
        except Exception as e:
            print(&#39;Error in Subject.label: &#39; + str(e))
            logger.exception(&#39;Error in Subject.label: &#39; + str(e))
    
    @property
    def all_images(self):
        logger.info(&#34;Subject.all_images called&#34;)
        try:
            listImages = []
            for study in self.children:
                listImages.extend(study.all_images)
            return ImagesList(listImages)
        except Exception as e:
            print(&#39;Error in Subject.all_images: &#39; + str(e))
            logger.exception(&#39;Error in Subject.all_images: &#39; + str(e))
    
    def new(self, suffix=&#34;_Copy&#34;, subjectID=None):
        logger.info(&#34;Subject.new called&#34;)
        try:
            if subjectID is None:
                subjectID = self.subjectID + suffix
            return Subject(self.objWeasel, subjectID)
        except Exception as e:
            print(&#39;Error in Subject.new: &#39; + str(e))
            logger.exception(&#39;Error in Subject.new: &#39; + str(e))

    def copy(self, suffix=&#34;_Copy&#34;, output_dir=None):
        logger.info(&#34;Subject.copy called&#34;)
        try:
            newSubjectID = self.subjectID + suffix
            for study in self.children:
                study.copy(suffix=&#39;&#39;, newSubjectID=newSubjectID, output_dir=output_dir)
            return Subject(self.objWeasel, newSubjectID)
        except Exception as e:
            print(&#39;Error in Subject.copy: &#39; + str(e))
            logger.exception(&#39;Error in Subject.copy: &#39; + str(e))

    def delete(self):
        logger.info(&#34;Subject.delete called&#34;)
        try:
            for study in self.children:
                study.delete()
            self.subjectID = &#39;&#39;
            #interfaceDICOMXMLFile.removeSubjectinXMLFile(self.objWeasel, self.subjectID)
        except Exception as e:
            print(&#39;Error in Subject.delete: &#39; + str(e))
            logger.exception(&#39;Error in Subject.delete: &#39; + str(e))

    def add(self, study):
        logger.info(&#34;Subject.add called&#34;)
        try:
            study.subjectID = self.subjectID
            study[&#34;PatientID&#34;] = study.subjectID
            #interfaceDICOMXMLFile.insertNewStudyInXMLFile(self, study.subjectID, study.studyID, study.suffix)
        except Exception as e:
            print(&#39;Error in Subject.add: &#39; + str(e))
            logger.exception(&#39;Error in Subject.add: &#39; + str(e))

    @staticmethod
    def merge(listSubjects, newSubjectName=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False, output_dir=None):
        logger.info(&#34;Subject.merge called&#34;)
        try:
            if newSubjectName:
                outputSubject = Subject(listSubjects[0].objWeasel, newSubjectName)
            else:
                outputSubject = listSubjects[0].new(suffix=suffix)
            # Setup Progress Bar
            progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listSubjects)) + &#34; Subjects&#34;
            if progress_bar == True: 
                listSubjects[0].objWeasel.progress_bar(
                    msg = (&#34;&lt;H4&gt;Merging {} Subjects&lt;/H4&gt;&#34;).format(len(listSubjects)),
                    index = 0, max = len(listSubjects))
            # Add new subject (outputSubject) to XML
            for index, subject in enumerate(listSubjects):
                # Increment progress bar
                subjMsg = &#34;Merging subject &#34; + subject.subjectID
                if progress_bar == True: 
                    listSubjects[0].objWeasel.progress_bar(
                        msg = (&#34;&lt;H4&gt;&#34; + subjMsg + &#34;&lt;/H4&gt;&#34;),
                        index = index+1, max = len(listSubjects))
                # Overwrite or not?
                if overwrite == False:
                    for study in subject.children:
                        # Create a copy of the study into the new subject
                        studyMsg = &#34;, study &#34; + study.studyID
                        if progress_bar == True: 
                            listSubjects[0].objWeasel.progress_bar(
                                msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                                index = index+1, max = len(listSubjects))
                        study.copy(suffix=suffix, newSubjectID=outputSubject.subjectID, output_dir=output_dir)
                else:
                    for study in subject.children:
                        studyMsg = &#34;, study &#34; + study.studyID
                        if progress_bar == True: 
                            listSubjects[0].objWeasel.progress_bar(
                                msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                                index = index+1, max = len(listSubjects))
                        seriesPathsList = []
                        for series in study.children:
                            series.Item(&#39;PatientID&#39;, outputSubject.subjectID)
                            seriesPathsList.append(series.images)
                        outputSubject.objWeasel.objXMLReader.insertNewStudyInXMLFile(
                                    outputSubject.subjectID, study.studyID, suffix, seriesList=seriesPathsList) # Need new Study name situation
                        # Add study to new subject in the XML
                    subject.objWeasel.objXMLReader.removeSubjectFromXMLFile(subject.subjectID)
            return outputSubject
        except Exception as e:
            print(&#39;Error in Subject.merge: &#39; + str(e))
            logger.exception(&#39;Error in Subject.merge: &#39; + str(e))

    def get_value(self, tag):
        logger.info(&#34;Subject.get_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                studyOutputValuesList = []
                for study in self.children:
                    studyOutputValuesList.append(study.get_value(tag)) # extend will allow long single list, while append creates list of lists
                return studyOutputValuesList
            else:
                return []
        except Exception as e:
            print(&#39;Error in Subject.get_value: &#39; + str(e))
            logger.exception(&#39;Error in Subject.get_value: &#39; + str(e))

    def set_value(self, tag, newValue):
        logger.info(&#34;Subject.set_value called&#34;)
        try:
            if len(self.children) &gt; 0:
                for study in self.children:
                    study.set_value(tag, newValue)
        except Exception as e:
            print(&#39;Error in Subject.set_value: &#39; + str(e))
            logger.exception(&#39;Error in Subject.set_value: &#39; + str(e))
    
    def __getitem__(self, tag):
        return self.get_value(tag)

    def __setitem__(self, tag, value):
        self.set_value(tag, value)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Subject.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>listSubjects, newSubjectName=None, suffix='_Merged', overwrite=False, progress_bar=False, output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def merge(listSubjects, newSubjectName=None, suffix=&#39;_Merged&#39;, overwrite=False, progress_bar=False, output_dir=None):
    logger.info(&#34;Subject.merge called&#34;)
    try:
        if newSubjectName:
            outputSubject = Subject(listSubjects[0].objWeasel, newSubjectName)
        else:
            outputSubject = listSubjects[0].new(suffix=suffix)
        # Setup Progress Bar
        progressBarTitle = &#34;Progress Bar - Merging &#34; + str(len(listSubjects)) + &#34; Subjects&#34;
        if progress_bar == True: 
            listSubjects[0].objWeasel.progress_bar(
                msg = (&#34;&lt;H4&gt;Merging {} Subjects&lt;/H4&gt;&#34;).format(len(listSubjects)),
                index = 0, max = len(listSubjects))
        # Add new subject (outputSubject) to XML
        for index, subject in enumerate(listSubjects):
            # Increment progress bar
            subjMsg = &#34;Merging subject &#34; + subject.subjectID
            if progress_bar == True: 
                listSubjects[0].objWeasel.progress_bar(
                    msg = (&#34;&lt;H4&gt;&#34; + subjMsg + &#34;&lt;/H4&gt;&#34;),
                    index = index+1, max = len(listSubjects))
            # Overwrite or not?
            if overwrite == False:
                for study in subject.children:
                    # Create a copy of the study into the new subject
                    studyMsg = &#34;, study &#34; + study.studyID
                    if progress_bar == True: 
                        listSubjects[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listSubjects))
                    study.copy(suffix=suffix, newSubjectID=outputSubject.subjectID, output_dir=output_dir)
            else:
                for study in subject.children:
                    studyMsg = &#34;, study &#34; + study.studyID
                    if progress_bar == True: 
                        listSubjects[0].objWeasel.progress_bar(
                            msg = (&#34;&lt;H4&gt;&#34; + subjMsg + studyMsg + &#34;&lt;/H4&gt;&#34;),
                            index = index+1, max = len(listSubjects))
                    seriesPathsList = []
                    for series in study.children:
                        series.Item(&#39;PatientID&#39;, outputSubject.subjectID)
                        seriesPathsList.append(series.images)
                    outputSubject.objWeasel.objXMLReader.insertNewStudyInXMLFile(
                                outputSubject.subjectID, study.studyID, suffix, seriesList=seriesPathsList) # Need new Study name situation
                    # Add study to new subject in the XML
                subject.objWeasel.objXMLReader.removeSubjectFromXMLFile(subject.subjectID)
        return outputSubject
    except Exception as e:
        print(&#39;Error in Subject.merge: &#39; + str(e))
        logger.exception(&#39;Error in Subject.merge: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Subject.all_images"><code class="name">var <span class="ident">all_images</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_images(self):
    logger.info(&#34;Subject.all_images called&#34;)
    try:
        listImages = []
        for study in self.children:
            listImages.extend(study.all_images)
        return ImagesList(listImages)
    except Exception as e:
        print(&#39;Error in Subject.all_images: &#39; + str(e))
        logger.exception(&#39;Error in Subject.all_images: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    logger.info(&#34;Subject.children called&#34;)
    try:
        children = []
        subjectXML = self.objWeasel.objXMLReader.getSubject(self.subjectID)
        if subjectXML:
            for studyXML in subjectXML:
                studyID = studyXML.attrib[&#39;id&#39;]
                study = Study(self.objWeasel, self.subjectID, studyID)
                children.append(study)
        return StudyList(children)
    except Exception as e:
        print(&#39;Error in Subject.children: &#39; + str(e))
        logger.exception(&#39;Error in Subject.children: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    logger.info(&#34;Subject.label called&#34;)
    try:
        return self.subjectID
    except Exception as e:
        print(&#39;Error in Subject.label: &#39; + str(e))
        logger.exception(&#39;Error in Subject.label: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.number_children"><code class="name">var <span class="ident">number_children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_children(self):
    return len(self.children)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.objWeasel"><code class="name">var <span class="ident">objWeasel</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    logger.info(&#34;Subject.parent called&#34;)
    try:
        return Project(self.objWeasel)
    except Exception as e:
        print(&#39;Error in Subject.parent: &#39; + str(e))
        logger.exception(&#39;Error in Subject.parent: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.subjectID"><code class="name">var <span class="ident">subjectID</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.Subject.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, study)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, study):
    logger.info(&#34;Subject.add called&#34;)
    try:
        study.subjectID = self.subjectID
        study[&#34;PatientID&#34;] = study.subjectID
        #interfaceDICOMXMLFile.insertNewStudyInXMLFile(self, study.subjectID, study.studyID, study.suffix)
    except Exception as e:
        print(&#39;Error in Subject.add: &#39; + str(e))
        logger.exception(&#39;Error in Subject.add: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, suffix='_Copy', output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, suffix=&#34;_Copy&#34;, output_dir=None):
    logger.info(&#34;Subject.copy called&#34;)
    try:
        newSubjectID = self.subjectID + suffix
        for study in self.children:
            study.copy(suffix=&#39;&#39;, newSubjectID=newSubjectID, output_dir=output_dir)
        return Subject(self.objWeasel, newSubjectID)
    except Exception as e:
        print(&#39;Error in Subject.copy: &#39; + str(e))
        logger.exception(&#39;Error in Subject.copy: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    logger.info(&#34;Subject.delete called&#34;)
    try:
        for study in self.children:
            study.delete()
        self.subjectID = &#39;&#39;
        #interfaceDICOMXMLFile.removeSubjectinXMLFile(self.objWeasel, self.subjectID)
    except Exception as e:
        print(&#39;Error in Subject.delete: &#39; + str(e))
        logger.exception(&#39;Error in Subject.delete: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, tag):
    logger.info(&#34;Subject.get_value called&#34;)
    try:
        if len(self.children) &gt; 0:
            studyOutputValuesList = []
            for study in self.children:
                studyOutputValuesList.append(study.get_value(tag)) # extend will allow long single list, while append creates list of lists
            return studyOutputValuesList
        else:
            return []
    except Exception as e:
        print(&#39;Error in Subject.get_value: &#39; + str(e))
        logger.exception(&#39;Error in Subject.get_value: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, suffix='_Copy', subjectID=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self, suffix=&#34;_Copy&#34;, subjectID=None):
    logger.info(&#34;Subject.new called&#34;)
    try:
        if subjectID is None:
            subjectID = self.subjectID + suffix
        return Subject(self.objWeasel, subjectID)
    except Exception as e:
        print(&#39;Error in Subject.new: &#39; + str(e))
        logger.exception(&#39;Error in Subject.new: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.Subject.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, tag, newValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, tag, newValue):
    logger.info(&#34;Subject.set_value called&#34;)
    try:
        if len(self.children) &gt; 0:
            for study in self.children:
                study.set_value(tag, newValue)
    except Exception as e:
        print(&#39;Error in Subject.set_value: &#39; + str(e))
        logger.exception(&#39;Error in Subject.set_value: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Weasel.DICOM.Classes.SubjectList"><code class="flex name class">
<span>class <span class="ident">SubjectList</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing a list of class Subject.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubjectList(ListOfDicomObjects):
    &#34;&#34;&#34;
    A class containing a list of class Subject. 
    &#34;&#34;&#34;
    def copy(self):
        &#34;&#34;&#34;
        Returns a copy of the list of subjects.
        &#34;&#34;&#34;
        copy = []
        for subject in self:
            copy.append(subject.copy())
        return SubjectList(copy)

    def merge(self, subject_name=&#39;MergedSubjects&#39;, overwrite=True, progress_bar=True):
        &#34;&#34;&#34;
        Merges a list of series into a new series under the same study
        &#34;&#34;&#34;
        if len(self) == 0: return
        return self[0].merge(self, newSubjectName=subject_name, overwrite=overwrite, progress_bar=progress_bar)

    @property
    def children(self):
        &#34;&#34;&#34;
        Returns a list of lists of series where each list refers to the various series of a study.
        &#34;&#34;&#34;
        childrenList = []
        for subject in self:
            # We&#39;re returning list of lists by using append.
            # If we want a flat list, we&#39;ll have to use extend instead.
            childrenList.append(subject.subject)
        return childrenList</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></li>
<li>builtins.list</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Weasel.DICOM.Classes.SubjectList.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of lists of series where each list refers to the various series of a study.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    &#34;&#34;&#34;
    Returns a list of lists of series where each list refers to the various series of a study.
    &#34;&#34;&#34;
    childrenList = []
    for subject in self:
        # We&#39;re returning list of lists by using append.
        # If we want a flat list, we&#39;ll have to use extend instead.
        childrenList.append(subject.subject)
    return childrenList</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Weasel.DICOM.Classes.SubjectList.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the list of subjects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Returns a copy of the list of subjects.
    &#34;&#34;&#34;
    copy = []
    for subject in self:
        copy.append(subject.copy())
    return SubjectList(copy)</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.Classes.SubjectList.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, subject_name='MergedSubjects', overwrite=True, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges a list of series into a new series under the same study</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, subject_name=&#39;MergedSubjects&#39;, overwrite=True, progress_bar=True):
    &#34;&#34;&#34;
    Merges a list of series into a new series under the same study
    &#34;&#34;&#34;
    if len(self) == 0: return
    return self[0].merge(self, newSubjectName=subject_name, overwrite=overwrite, progress_bar=progress_bar)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.delete" href="#Weasel.DICOM.Classes.ListOfDicomObjects.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.display" href="#Weasel.DICOM.Classes.ListOfDicomObjects.display">display</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Weasel.DICOM" href="index.html">Weasel.DICOM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Weasel.DICOM.Classes.Image" href="#Weasel.DICOM.Classes.Image">Image</a></code></h4>
<ul class="two-column">
<li><code><a title="Weasel.DICOM.Classes.Image.Affine" href="#Weasel.DICOM.Classes.Image.Affine">Affine</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.Metadata" href="#Weasel.DICOM.Classes.Image.Metadata">Metadata</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.PixelArray" href="#Weasel.DICOM.Classes.Image.PixelArray">PixelArray</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.PydicomObject" href="#Weasel.DICOM.Classes.Image.PydicomObject">PydicomObject</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.ROIindices" href="#Weasel.DICOM.Classes.Image.ROIindices">ROIindices</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.SeriesUID" href="#Weasel.DICOM.Classes.Image.SeriesUID">SeriesUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.StudyUID" href="#Weasel.DICOM.Classes.Image.StudyUID">StudyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.copy" href="#Weasel.DICOM.Classes.Image.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.delete" href="#Weasel.DICOM.Classes.Image.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.display" href="#Weasel.DICOM.Classes.Image.display">display</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.export_as_csv" href="#Weasel.DICOM.Classes.Image.export_as_csv">export_as_csv</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.export_as_nifti" href="#Weasel.DICOM.Classes.Image.export_as_nifti">export_as_nifti</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.get_value" href="#Weasel.DICOM.Classes.Image.get_value">get_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.label" href="#Weasel.DICOM.Classes.Image.label">label</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.load_mask" href="#Weasel.DICOM.Classes.Image.load_mask">load_mask</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.merge" href="#Weasel.DICOM.Classes.Image.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.new" href="#Weasel.DICOM.Classes.Image.new">new</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.newSeriesFrom" href="#Weasel.DICOM.Classes.Image.newSeriesFrom">newSeriesFrom</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.objWeasel" href="#Weasel.DICOM.Classes.Image.objWeasel">objWeasel</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.parent" href="#Weasel.DICOM.Classes.Image.parent">parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.path" href="#Weasel.DICOM.Classes.Image.path">path</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.plot" href="#Weasel.DICOM.Classes.Image.plot">plot</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.read" href="#Weasel.DICOM.Classes.Image.read">read</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.referencePath" href="#Weasel.DICOM.Classes.Image.referencePath">referencePath</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.save" href="#Weasel.DICOM.Classes.Image.save">save</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.seriesID" href="#Weasel.DICOM.Classes.Image.seriesID">seriesID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.seriesUID" href="#Weasel.DICOM.Classes.Image.seriesUID">seriesUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.set_value" href="#Weasel.DICOM.Classes.Image.set_value">set_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.studyID" href="#Weasel.DICOM.Classes.Image.studyID">studyID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.studyUID" href="#Weasel.DICOM.Classes.Image.studyUID">studyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.subjectID" href="#Weasel.DICOM.Classes.Image.subjectID">subjectID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.suffix" href="#Weasel.DICOM.Classes.Image.suffix">suffix</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.write" href="#Weasel.DICOM.Classes.Image.write">write</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Image.write_mask" href="#Weasel.DICOM.Classes.Image.write_mask">write_mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.ImagesList" href="#Weasel.DICOM.Classes.ImagesList">ImagesList</a></code></h4>
<ul class="two-column">
<li><code><a title="Weasel.DICOM.Classes.ImagesList.copy" href="#Weasel.DICOM.Classes.ImagesList.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.display" href="#Weasel.DICOM.Classes.ImagesList.display">display</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.get_value" href="#Weasel.DICOM.Classes.ImagesList.get_value">get_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.label" href="#Weasel.DICOM.Classes.ImagesList.label">label</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.merge" href="#Weasel.DICOM.Classes.ImagesList.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.new_parent" href="#Weasel.DICOM.Classes.ImagesList.new_parent">new_parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.parent" href="#Weasel.DICOM.Classes.ImagesList.parent">parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.paths" href="#Weasel.DICOM.Classes.ImagesList.paths">paths</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.set_value" href="#Weasel.DICOM.Classes.ImagesList.set_value">set_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.sort" href="#Weasel.DICOM.Classes.ImagesList.sort">sort</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ImagesList.where" href="#Weasel.DICOM.Classes.ImagesList.where">where</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects" href="#Weasel.DICOM.Classes.ListOfDicomObjects">ListOfDicomObjects</a></code></h4>
<ul class="">
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.delete" href="#Weasel.DICOM.Classes.ListOfDicomObjects.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.ListOfDicomObjects.display" href="#Weasel.DICOM.Classes.ListOfDicomObjects.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.Project" href="#Weasel.DICOM.Classes.Project">Project</a></code></h4>
<ul class="">
<li><code><a title="Weasel.DICOM.Classes.Project.children" href="#Weasel.DICOM.Classes.Project.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Project.number_children" href="#Weasel.DICOM.Classes.Project.number_children">number_children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.Series" href="#Weasel.DICOM.Classes.Series">Series</a></code></h4>
<ul class="two-column">
<li><code><a title="Weasel.DICOM.Classes.Series.Affine" href="#Weasel.DICOM.Classes.Series.Affine">Affine</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Imaginary" href="#Weasel.DICOM.Classes.Series.Imaginary">Imaginary</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Item" href="#Weasel.DICOM.Classes.Series.Item">Item</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.ListAffines" href="#Weasel.DICOM.Classes.Series.ListAffines">ListAffines</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Magnitude" href="#Weasel.DICOM.Classes.Series.Magnitude">Magnitude</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Metadata" href="#Weasel.DICOM.Classes.Series.Metadata">Metadata</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Phase" href="#Weasel.DICOM.Classes.Series.Phase">Phase</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.PixelArray" href="#Weasel.DICOM.Classes.Series.PixelArray">PixelArray</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.PydicomList" href="#Weasel.DICOM.Classes.Series.PydicomList">PydicomList</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.ROIindices" href="#Weasel.DICOM.Classes.Series.ROIindices">ROIindices</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.Real" href="#Weasel.DICOM.Classes.Series.Real">Real</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.SeriesUID" href="#Weasel.DICOM.Classes.Series.SeriesUID">SeriesUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.StudyUID" href="#Weasel.DICOM.Classes.Series.StudyUID">StudyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.add" href="#Weasel.DICOM.Classes.Series.add">add</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.children" href="#Weasel.DICOM.Classes.Series.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.copy" href="#Weasel.DICOM.Classes.Series.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.delete" href="#Weasel.DICOM.Classes.Series.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.display" href="#Weasel.DICOM.Classes.Series.display">display</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.export_as_csv" href="#Weasel.DICOM.Classes.Series.export_as_csv">export_as_csv</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.export_as_nifti" href="#Weasel.DICOM.Classes.Series.export_as_nifti">export_as_nifti</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.get_value" href="#Weasel.DICOM.Classes.Series.get_value">get_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.images" href="#Weasel.DICOM.Classes.Series.images">images</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.label" href="#Weasel.DICOM.Classes.Series.label">label</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.load_mask" href="#Weasel.DICOM.Classes.Series.load_mask">load_mask</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.merge" href="#Weasel.DICOM.Classes.Series.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.new" href="#Weasel.DICOM.Classes.Series.new">new</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.number_children" href="#Weasel.DICOM.Classes.Series.number_children">number_children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.objWeasel" href="#Weasel.DICOM.Classes.Series.objWeasel">objWeasel</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.parent" href="#Weasel.DICOM.Classes.Series.parent">parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.plot" href="#Weasel.DICOM.Classes.Series.plot">plot</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.read" href="#Weasel.DICOM.Classes.Series.read">read</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.referencePathsList" href="#Weasel.DICOM.Classes.Series.referencePathsList">referencePathsList</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.remove" href="#Weasel.DICOM.Classes.Series.remove">remove</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.save" href="#Weasel.DICOM.Classes.Series.save">save</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.seriesID" href="#Weasel.DICOM.Classes.Series.seriesID">seriesID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.seriesUID" href="#Weasel.DICOM.Classes.Series.seriesUID">seriesUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.set_value" href="#Weasel.DICOM.Classes.Series.set_value">set_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.sort" href="#Weasel.DICOM.Classes.Series.sort">sort</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.studyID" href="#Weasel.DICOM.Classes.Series.studyID">studyID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.studyUID" href="#Weasel.DICOM.Classes.Series.studyUID">studyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.subjectID" href="#Weasel.DICOM.Classes.Series.subjectID">subjectID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.suffix" href="#Weasel.DICOM.Classes.Series.suffix">suffix</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.where" href="#Weasel.DICOM.Classes.Series.where">where</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.write" href="#Weasel.DICOM.Classes.Series.write">write</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Series.write_mask" href="#Weasel.DICOM.Classes.Series.write_mask">write_mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.SeriesList" href="#Weasel.DICOM.Classes.SeriesList">SeriesList</a></code></h4>
<ul class="">
<li><code><a title="Weasel.DICOM.Classes.SeriesList.children" href="#Weasel.DICOM.Classes.SeriesList.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.SeriesList.copy" href="#Weasel.DICOM.Classes.SeriesList.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.SeriesList.merge" href="#Weasel.DICOM.Classes.SeriesList.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.SeriesList.parent" href="#Weasel.DICOM.Classes.SeriesList.parent">parent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.Study" href="#Weasel.DICOM.Classes.Study">Study</a></code></h4>
<ul class="two-column">
<li><code><a title="Weasel.DICOM.Classes.Study.StudyUID" href="#Weasel.DICOM.Classes.Study.StudyUID">StudyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.add" href="#Weasel.DICOM.Classes.Study.add">add</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.all_images" href="#Weasel.DICOM.Classes.Study.all_images">all_images</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.children" href="#Weasel.DICOM.Classes.Study.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.copy" href="#Weasel.DICOM.Classes.Study.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.delete" href="#Weasel.DICOM.Classes.Study.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.get_value" href="#Weasel.DICOM.Classes.Study.get_value">get_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.label" href="#Weasel.DICOM.Classes.Study.label">label</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.merge" href="#Weasel.DICOM.Classes.Study.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.new" href="#Weasel.DICOM.Classes.Study.new">new</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.number_children" href="#Weasel.DICOM.Classes.Study.number_children">number_children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.objWeasel" href="#Weasel.DICOM.Classes.Study.objWeasel">objWeasel</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.parent" href="#Weasel.DICOM.Classes.Study.parent">parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.set_value" href="#Weasel.DICOM.Classes.Study.set_value">set_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.studyID" href="#Weasel.DICOM.Classes.Study.studyID">studyID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.studyUID" href="#Weasel.DICOM.Classes.Study.studyUID">studyUID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.subjectID" href="#Weasel.DICOM.Classes.Study.subjectID">subjectID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Study.suffix" href="#Weasel.DICOM.Classes.Study.suffix">suffix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.StudyList" href="#Weasel.DICOM.Classes.StudyList">StudyList</a></code></h4>
<ul class="">
<li><code><a title="Weasel.DICOM.Classes.StudyList.children" href="#Weasel.DICOM.Classes.StudyList.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.StudyList.copy" href="#Weasel.DICOM.Classes.StudyList.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.StudyList.merge" href="#Weasel.DICOM.Classes.StudyList.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.StudyList.parent" href="#Weasel.DICOM.Classes.StudyList.parent">parent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.Subject" href="#Weasel.DICOM.Classes.Subject">Subject</a></code></h4>
<ul class="two-column">
<li><code><a title="Weasel.DICOM.Classes.Subject.add" href="#Weasel.DICOM.Classes.Subject.add">add</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.all_images" href="#Weasel.DICOM.Classes.Subject.all_images">all_images</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.children" href="#Weasel.DICOM.Classes.Subject.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.copy" href="#Weasel.DICOM.Classes.Subject.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.delete" href="#Weasel.DICOM.Classes.Subject.delete">delete</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.get_value" href="#Weasel.DICOM.Classes.Subject.get_value">get_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.label" href="#Weasel.DICOM.Classes.Subject.label">label</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.merge" href="#Weasel.DICOM.Classes.Subject.merge">merge</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.new" href="#Weasel.DICOM.Classes.Subject.new">new</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.number_children" href="#Weasel.DICOM.Classes.Subject.number_children">number_children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.objWeasel" href="#Weasel.DICOM.Classes.Subject.objWeasel">objWeasel</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.parent" href="#Weasel.DICOM.Classes.Subject.parent">parent</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.set_value" href="#Weasel.DICOM.Classes.Subject.set_value">set_value</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.subjectID" href="#Weasel.DICOM.Classes.Subject.subjectID">subjectID</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.Subject.suffix" href="#Weasel.DICOM.Classes.Subject.suffix">suffix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Weasel.DICOM.Classes.SubjectList" href="#Weasel.DICOM.Classes.SubjectList">SubjectList</a></code></h4>
<ul class="">
<li><code><a title="Weasel.DICOM.Classes.SubjectList.children" href="#Weasel.DICOM.Classes.SubjectList.children">children</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.SubjectList.copy" href="#Weasel.DICOM.Classes.SubjectList.copy">copy</a></code></li>
<li><code><a title="Weasel.DICOM.Classes.SubjectList.merge" href="#Weasel.DICOM.Classes.SubjectList.merge">merge</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>