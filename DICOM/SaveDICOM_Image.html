<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Weasel.DICOM.SaveDICOM_Image API documentation</title>
<meta name="description" content="Collection of functions that save meaningful content (related to image, colourmap, dates and times, acquisiton, etc.) into DICOM files." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Weasel.DICOM.SaveDICOM_Image</code></h1>
</header>
<section id="section-intro">
<p>Collection of functions that save meaningful content (related to image, colourmap, dates and times, acquisiton, etc.) into DICOM files.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Collection of functions that save meaningful content (related to image, colourmap, dates and times, acquisiton, etc.) into DICOM files.
&#34;&#34;&#34;

import os
import numpy as np
import pydicom
from pydicom.dataset import Dataset, FileDataset
from pydicom.sequence import Sequence
from pydicom.datadict import dictionary_VR
from datetime import datetime, timedelta
import copy
import random
from matplotlib import cm
import DICOM.ReadDICOM_Image as ReadDICOM_Image
import DICOM.ParametricMapsDictionary as param
import logging
logger = logging.getLogger(__name__)


def returnFilePath(imagePath, suffix, new_path=None, output_folder=None):
    &#34;&#34;&#34;This method returns the new filepath of the object to be saved.&#34;&#34;&#34;
    # Think of a way to choose a select a new FilePath
    logger.info(&#34;SaveDICOM_Image.returnFilePath called&#34;)
    try:
        if os.path.exists(imagePath):
            # Need to think about what new name to give to the file and how to save multiple files for the same sequence
            if new_path is not None:
                newFilePath = new_path + &#39;.dcm&#39;
            else:
                if output_folder is None:
                    outputFolder = os.path.join(os.path.dirname(imagePath), &#34;output&#34; + suffix)
                else:
                    outputFolder = output_folder
                fileName = os.path.splitext(os.path.basename(imagePath))[0]
                os.makedirs(outputFolder, exist_ok=True)
                newFilePath = os.path.join(outputFolder, fileName + suffix + &#39;.dcm&#39;)
                counter = 1
                loop = 1
                if os.path.exists(newFilePath):
                    while loop == 1:
                        newFilePath = os.path.join(outputFolder, fileName + suffix + &#39;(&#39; + str(counter) + &#39;)&#39; + &#39;.dcm&#39;)
                        if os.path.exists(newFilePath):
                            counter += 1
                        else:
                            loop = 0
            return newFilePath

        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.returnFilePath: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.returnFilePath: &#39; + str(e))


def saveNewSingleDicomImage(newFilePath, imagePath, pixelArray, suffix, series_id=None, series_uid=None, series_name=None, image_number=None, parametric_map=None, colourmap=None, list_refs_path=None):
    &#34;&#34;&#34;This method saves the new pixelArray into DICOM in the given newFilePath&#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.saveNewSingleDicomImage called&#34;)
    try:
        if os.path.exists(imagePath):
            dataset = ReadDICOM_Image.getDicomDataset(imagePath)
            if list_refs_path is not None:
                refs = []
                for individualRef in list_refs_path:
                    refs.append(ReadDICOM_Image.getDicomDataset(individualRef))
            else:
                refs = None
            if colourmap is not None:
                if isinstance(colourmap, str):
                    pass
                else:
                    colourmap = colourmap.reshape(-1, colourmap.shape[-1]) # Flatten (x, y, 3) to (x*y, 3)
            newDataset = createNewSingleDicom(dataset, pixelArray, series_id=series_id, series_uid=series_uid, series_name=series_name, comment=suffix, parametric_map=parametric_map, colourmap=colourmap, list_refs=refs)
            if (image_number is not None) and (len(np.shape(pixelArray)) &lt; 3):
                newDataset.InstanceNumber = image_number
                newDataset.ImageNumber = image_number
            saveDicomToFile(newDataset, output_path=newFilePath)
            del dataset, newDataset, refs, image_number
            return
        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveNewSingleDicomImage: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveNewSingleDicomImage: &#39; + str(e))


def updateSingleDicomImage(objWeasel, spinBoxIntensity, spinBoxContrast, 
                imagePath=&#39;&#39;, seriesID=&#39;&#39;, studyID=&#39;&#39;, colourmap=None, lut=None):
    &#34;&#34;&#34;This method is used in the Displays module. It saves the image in the viewer to DICOM, 
        with the intensity and contrast values and colourmap set in the viewer.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.updateSingleDicomImage called&#34;)
    try:
        logger.info(&#34;In SaveDICOM_Image.updateSingleDicomImage&#34;)
        objWeasel.progress_bar(msg=&#34;&lt;H4&gt;Updating 1 DICOM file&lt;/H4&gt;&#34;)
        objWeasel.progressBar.set_maximum(1)
        objWeasel.progressBar.set_value(0)
        dataset = ReadDICOM_Image.getDicomDataset(imagePath)
        levels = [spinBoxIntensity.value(), spinBoxContrast.value()]
        updatedDataset = updateSingleDicom(dataset, colourmap=colourmap, levels=levels, lut=lut)
        saveDicomToFile(updatedDataset, output_path=imagePath)
        objWeasel.progressBar.set_value(1)
        objWeasel.progressBar.close()
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.updateSingleDicomImage: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.updateSingleDicomImage: &#39; + str(e))


def saveDicomNewSeries(derivedImagePathList, imagePathList, pixelArrayList, suffix, series_id=None, series_uid=None, series_name=None, parametric_map=None, colourmap=None, list_refs_path=None):
    &#34;&#34;&#34;This method saves the pixelArrayList into DICOM files with metadata pointing to the same series&#34;&#34;&#34;
    # What if it&#39;s a map with less files than original? Think about iterating the first elements and sort path list by SliceLocation - see T2* algorithm
    # Think of a way to choose a select a new FilePath or Folder
    logger.info(&#34;SaveDICOM_Image.saveDicomNewSeries called&#34;)
    try:
        if os.path.exists(imagePathList[0]):
            # Series ID and UID
            if (series_id is None) and (series_uid is None):
                ids = generateUIDs(ReadDICOM_Image.getDicomDataset(imagePathList[0]))
                series_id = ids[0]
                series_uid = ids[1]
            elif (series_id is not None) and (series_uid is None):
                series_uid = generateUIDs(ReadDICOM_Image.getDicomDataset(imagePathList[0]), seriesNumber=series_id)[1]
            elif (series_id is None) and (series_uid is not None):
                series_id = int(str(ReadDICOM_Image.getDicomDataset(imagePathList[0]).SeriesNumber) + str(random.randint(0, 9999)))

            refs = None
            for index, newFilePath in enumerate(derivedImagePathList):
                # Extra references, besides the main one, which is imagePathList
                if list_refs_path is not None:
                    if len(np.shape(list_refs_path)) == 1:
                        refs = list_refs_path[index]
                    else:
                        refs = []
                        for individualRef in list_refs_path:
                            refs.append(individualRef[index])
                if colourmap is not None:
                    if isinstance(colourmap, str):
                        colour = colourmap
                    else:
                        colour = colourmap[index, ...]
                else:
                    colour = None

                saveNewSingleDicomImage(newFilePath, imagePathList[index], pixelArrayList[index], suffix, series_id=series_id, series_uid=series_uid, series_name=series_name, image_number=index+1, parametric_map=parametric_map, 
                                      colourmap=colour, list_refs_path=refs)
            del series_id, series_uid, refs
            return
        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveDicomNewSeries: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveDicomNewSeries: &#39; + str(e))
 
    
def generateUIDs(dataset, seriesNumber=None, studyUID=None):
    &#34;&#34;&#34;
    This function generates and returns a SeriesUID and an InstanceUID.
    It also returns SeriesNumber in the first index of the output list.
    The SeriesUID is generated based on the StudyUID and on seriesNumber (if provided)
    The InstanceUID is generated based on SeriesUID.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.generateUIDs called&#34;)
    try:
        if studyUID is None:     
            studyUID = dataset.StudyInstanceUID
        # See http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_B.html regarding UID creation rules
        prefix = studyUID.split(&#34;.&#34;, maxsplit=7)
        prefix = &#39;.&#39;.join(prefix[:6])
        if seriesNumber is None:
            seriesNumber = str(dataset.SeriesNumber) + str(random.randint(0, 999))
        prefixSeries = prefix + &#34;.&#34; + str(seriesNumber) + &#34;.&#34;
        imageNumber = str(dataset.InstanceNumber).lstrip(&#34;0&#34;)
        if imageNumber == &#34;&#34;: imageNumber = &#34;999999&#34; 
        prefixImage = prefix + &#34;.&#34; + str(seriesNumber) + &#34;.&#34; + imageNumber + &#34;.&#34;
        seriesUID = pydicom.uid.generate_uid(prefix=prefixSeries)
        imageUID = pydicom.uid.generate_uid(prefix=prefixImage)
        return [seriesNumber, seriesUID, imageUID]
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.generateUIDs: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.generateUIDs: &#39; + str(e))


def overwriteDicomFileTag(imagePath, dicomTag, newValue):
    &#34;&#34;&#34;
    This method writes the `newValue` into the `dicomTag` in `imagePath`.
    If `dicomTag` exists in `imagePath`, this will overwrite.
    Otherwise, it will create `dicomTag` and store the `newValue`.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.overwriteDicomFileTag called&#34;)
    try:
        if isinstance(imagePath, list):
            datasetList = ReadDICOM_Image.getSeriesDicomDataset(imagePath)
            for index, dataset in enumerate(datasetList):
                if isinstance(dicomTag, str):
                    try: 
                        if dataset.data_element(dicomTag).VR == &#34;TM&#34;: 
                            dataset.data_element(dicomTag).value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset.data_element(dicomTag).value = newValue
                    except:
                        if dictionary_VR(dicomTag) == &#34;TM&#34;: 
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue) 
                elif isinstance(dicomTag, tuple):
                    try:
                        if dataset[dicomTag].VR == &#34;TM&#34;:
                            dataset[dicomTag].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset[dicomTag].value = newValue
                    except:
                        if dataset[dicomTag].VR == &#34;TM&#34;:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue)
                else:
                    try:
                        if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                            dataset[hex(dicomTag)].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset[hex(dicomTag)].value = newValue
                    except:
                        if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                            dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), newValue)
                saveDicomToFile(dataset, output_path=imagePath[index])
        else:
            dataset = ReadDICOM_Image.getDicomDataset(imagePath)
            if isinstance(dicomTag, str):
                try: 
                    if dataset.data_element(dicomTag).VR == &#34;TM&#34;: 
                        dataset.data_element(dicomTag).value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset.data_element(dicomTag).value = newValue
                except:
                    if dictionary_VR(dicomTag) == &#34;TM&#34;: 
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue) 
            elif isinstance(dicomTag, tuple):
                try:
                    if dataset[dicomTag].VR == &#34;TM&#34;:
                        dataset[dicomTag].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset[dicomTag].value = newValue
                except:
                    if dataset[dicomTag].VR == &#34;TM&#34;:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue)
            else:
                try:
                    if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                        dataset[hex(dicomTag)].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset[hex(dicomTag)].value = newValue
                except:
                    if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                        dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), newValue)
            saveDicomToFile(dataset, output_path=imagePath)
        return
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.overwriteDicomFileTag: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.overwriteDicomFileTag: &#39; + str(e))


def createNewPixelArray(imageArray, dataset):
    &#34;&#34;&#34;This method saves the imageArray into the `dataset` input argument based on other DICOM parameters in `dataset`.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.createNewPixelArray called&#34;)
    try:
        # Delete &#39;Philips Rescale Slope&#39; tag if it exists
        if [0x2005, 0x100E] in dataset:
            del dataset[0x2005, 0x100E]
        # If the new array is a binary image / mask
        if len(np.unique(imageArray)) == 2:
            param.editDicom(dataset, imageArray, &#34;SEG&#34;)
            return dataset
        numberFrames = 1
        enhancedArrayInt = []
        numDimensions = len(np.shape(imageArray))
        # If Enhanced MRI, then:
        # For each frame, slope and intercept are M and B. For registration, I will have to add Image Position and Orientation
        if hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
            if numDimensions == 2:
                dataset.NumberOfFrames = 1
            else:
                dataset.NumberOfFrames = np.shape(imageArray)[0]
            del dataset.PerFrameFunctionalGroupsSequence[dataset.NumberOfFrames:]
            numberFrames = dataset.NumberOfFrames
        for index in range(numberFrames):
            if len(np.shape(imageArray)) == 2:
                tempArray = imageArray
            else:
                tempArray = np.squeeze(imageArray[index, ...])
            dataset.PixelRepresentation = 0
            target = (np.power(2, dataset.BitsAllocated) - 1) * np.ones(np.shape(tempArray))
            maximum = np.ones(np.shape(tempArray)) * np.amax(tempArray)
            minimum = np.ones(np.shape(tempArray)) * np.amin(tempArray)
            imageScaled = target * (tempArray - minimum) / (maximum - minimum)
            slope =  target / (maximum - minimum)
            intercept = (- target * minimum)/ (maximum - minimum)
            rescaleSlope = np.ones(np.shape(tempArray)) / slope
            rescaleIntercept = - intercept / slope
            if dataset.BitsAllocated == 8:
                imageArrayInt = imageScaled.astype(np.uint8)
            elif dataset.BitsAllocated == 16:
                imageArrayInt = imageScaled.astype(np.uint16)
            elif dataset.BitsAllocated == 32:
                imageArrayInt = imageScaled.astype(np.uint32)
            elif dataset.BitsAllocated == 64:
                imageArrayInt = imageScaled.astype(np.uint64)
            else:
                imageArrayInt = imageScaled.astype(dataset.pixel_array.dtype)
            dataset.add_new(&#39;0x00280106&#39;, &#39;US&#39;, int(np.amin(imageArrayInt)))
            dataset.add_new(&#39;0x00280107&#39;, &#39;US&#39;, int(np.amax(imageArrayInt)))
            if hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
                # Rotate back to Original Position
                enhancedArrayInt.append(np.transpose(imageArrayInt))
                # Rescsale Slope and Intercept
                dataset.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0].RescaleSlope = rescaleSlope.flatten()[0]
                dataset.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0].RescaleIntercept = rescaleIntercept.flatten()[0]
                # Set Window Center and Width
                center = (np.amax(tempArray) + np.amin(tempArray)) / 2 # (0 if int(np.amin(imageArrayInt)) &lt; 0 else int(target.flatten()[0]/2))
                width = np.amax(tempArray) - np.amin(tempArray) # int(target.flatten()[0])
                if width == 1.0: width = 1.1 
                dataset.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowCenter = center
                dataset.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowWidth = width
            else:
                # Rotate back to Original Position
                imageArrayInt = np.transpose(imageArrayInt)
                # Rescsale Slope and Intercept
                dataset.RescaleSlope = rescaleSlope.flatten()[0]
                dataset.RescaleIntercept = rescaleIntercept.flatten()[0]
                # Set Window Center and Width
                center = (np.amax(tempArray) + np.amin(tempArray)) / 2
                width = np.amax(tempArray) - np.amin(tempArray)
                if width == 1.0: width = 1.1
                dataset.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
                dataset.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
                # dataset.WindowCenter = (0 if int(np.amin(imageArrayInt)) &lt; 0 else int(target.flatten()[0]/2))
                # dataset.WindowWidth = int(target.flatten()[0])
        if enhancedArrayInt:
            imageArrayInt = np.array(enhancedArrayInt)
        
        # Set the shape/dimensions and PixelData
        dataset.Rows = np.shape(imageArrayInt)[-2]
        dataset.Columns = np.shape(imageArrayInt)[-1]
        dataset.PixelData = imageArrayInt.tobytes()
        del imageScaled, enhancedArrayInt, tempArray
        return dataset
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.createNewPixelArray: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.createNewPixelArray: &#39; + str(e))


def createNewSingleDicom(dicomData, imageArray, series_id=None, series_uid=None, series_name=None, comment=None, parametric_map=None, colourmap=None, list_refs=None):
    &#34;&#34;&#34;This function takes a DICOM Object, copies most of the DICOM tags from the DICOM given in input
        and writes the imageArray into the new DICOM Object in PixelData. 
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.createNewSingleDicom called&#34;)
    try:
        newDicom = copy.deepcopy(dicomData)
        #imageArray = copy.deepcopy(imageArray)

        # Series ID and UID
        if (series_id is None) and (series_uid is None):
            ids = generateUIDs(dicomData)
            series_id = ids[0]
            series_uid = ids[1]
        elif (series_id is not None) and (series_uid is None):
            series_uid = generateUIDs(dicomData, seriesNumber=series_id)[1]
        elif (series_id is None) and (series_uid is not None):
            series_id = str(dicomData.SeriesNumber) + str(random.randint(0, 999))
        newDicom.SeriesNumber = int(series_id)
        newDicom.SeriesInstanceUID = series_uid

        # Generate Unique ID based on the Series ID
        newDicom.SOPInstanceUID = generateUIDs(newDicom, seriesNumber=series_id)[2]

        # Date and Time of Creation
        dt = datetime.now()
        timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds
        newDicom.ContentDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.ContentTime = timeStr
        newDicom.InstanceCreationDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.InstanceCreationTime = timeStr
        newDicom.SeriesDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.ImageDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.AcquisitionDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.SeriesTime = timeStr
        newDicom.ImageTime = timeStr
        newDicom.AcquisitionTime = timeStr
        newDicom.ImageType.insert(0, &#34;DERIVED&#34;)

        # Series, Instance and Class for Reference
        refd_series_sequence = Sequence()
        newDicom.ReferencedSeriesSequence = refd_series_sequence
        refd_series1 = Dataset()
        refd_instance_sequence = Sequence()
        refd_series1.ReferencedInstanceSequence = refd_instance_sequence
        refd_instance1 = Dataset()
        refd_instance1.ReferencedSOPClassUID = dicomData.SOPClassUID
        refd_instance1.ReferencedSOPInstanceUID = dicomData.SOPInstanceUID
        refd_instance_sequence.append(refd_instance1)
        refd_series1.SeriesInstanceUID = dicomData.SeriesInstanceUID
        refd_series_sequence.append(refd_series1)

        # Extra references, besides the main one, which is dicomData
        if list_refs is not None:
            if np.shape(list_refs) == ():
                refd_series1 = Dataset()
                refd_instance_sequence = Sequence()
                refd_series1.ReferencedInstanceSequence = refd_instance_sequence
                refd_instance1 = Dataset()
                refd_instance1.ReferencedSOPInstanceUID = list_refs.SOPInstanceUID
                refd_instance1.ReferencedSOPClassUID = list_refs.SOPClassUID
                refd_instance_sequence.append(refd_instance1)
                refd_series1.SeriesInstanceUID = list_refs.SeriesInstanceUID
                refd_series_sequence.append(refd_series1)
            else:
                for individualRef in list_refs:
                    refd_series1 = Dataset()
                    refd_instance_sequence = Sequence()
                    refd_series1.ReferencedInstanceSequence = refd_instance_sequence
                    refd_instance1 = Dataset()
                    refd_instance1.ReferencedSOPInstanceUID = individualRef.SOPInstanceUID
                    refd_instance1.ReferencedSOPClassUID = individualRef.SOPClassUID
                    refd_instance_sequence.append(refd_instance1)
                    refd_series1.SeriesInstanceUID = individualRef.SeriesInstanceUID
                    refd_series_sequence.append(refd_series1)
            del list_refs

        # Comments
        if comment is not None:
            newDicom.ImageComments = comment
            # Then assign new Series Name by default
            if len(dicomData.dir(&#34;SeriesDescription&#34;))&gt;0:
                newDicom.SeriesDescription = dicomData.SeriesDescription + comment
            elif len(dicomData.dir(&#34;SequenceName&#34;))&gt;0 &amp; len(dicomData.dir(&#34;PulseSequenceName&#34;))==0:
                newDicom.SeriesDescription = dicomData.SequenceName + comment
            elif len(dicomData.dir(&#34;ProtocolName&#34;))&gt;0:
                newDicom.SeriesDescription = dicomData.ProtocolName + comment
            else:
                newDicom.SeriesDescription = &#34;NewSeries&#34; + newDicom.SeriesNumber
                
        # But if the user provides a Series Name
        if series_name:
            newDicom.SeriesDescription = series_name

        # Parametric Map
        if parametric_map is not None:
            param.editDicom(newDicom, imageArray, parametric_map)
            return newDicom

        newDicom = createNewPixelArray(imageArray, newDicom)    

        # Add colourmap here
        if (colourmap is None) and hasattr(newDicom, &#39;PhotometricInterpretation&#39;):
            if newDicom.PhotometricInterpretation == &#39;PALETTE COLOR&#39;:
                # This deletes the colourmap that came with the source/input DICOM
                stringType = &#39;US&#39;
                imageArrayInt = newDicom.pixel_array
                minValue = int(np.amin(imageArrayInt))
                numberOfValues = int(np.amax(imageArrayInt))
                arrayForRGB = np.arange(0, numberOfValues)
                colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
                totalBytes = dicomData.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
        elif colourmap is not None:
            if isinstance(colourmap, str):
                newDicom.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
                newDicom.RGBLUTTransferFunction = &#39;TABLE&#39;
                newDicom.ContentLabel = colourmap
                stringType = &#39;US&#39;
                imageArrayInt = newDicom.pixel_array
                minValue = int(np.amin(imageArrayInt))
                numberOfValues = int(np.amax(imageArrayInt))
                arrayForRGB = np.arange(0, numberOfValues)
                colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
                totalBytes = dicomData.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                del imageArrayInt
            else:
                colorsList = np.unique(colourmap, axis=0) / int(np.amax(colourmap))
                newDicom.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
                newDicom.RGBLUTTransferFunction = &#39;TABLE&#39;
                numberOfValues = len(colorsList)
                pixelArray = newDicom.pixel_array
                minValue = int(np.amin(pixelArray))
                totalBytes = newDicom.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                if hasattr(newDicom, &#39;ContentLabel&#39;):
                    del newDicom.ContentLabel

        del dicomData, imageArray#, imageArrayInt, imageScaled, enhancedArrayInt, tempArray
        return newDicom
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.createNewSingleDicom: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.createNewSingleDicom: &#39; + str(e))


def updateSingleDicom(dicomData, colourmap=None, levels=None, lut=None):
    &#34;&#34;&#34;This function takes a DICOM Object and changes it to include the
        new colourmap selected in the interface. It will have more features in the future.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.updateSingleDicom called&#34;)
    try:
        #and (colourmap != &#39;gray&#39;) removed from If statement below, so as to save gray colour tables
        if (colourmap == &#39;gray&#39;):
            dicomData.PhotometricInterpretation = &#39;MONOCHROME2&#39;
            dicomData.ContentLabel = &#39;&#39;
            if hasattr(dicomData, &#39;RedPaletteColorLookupTableData&#39;):
                del (dicomData.RGBLUTTransferFunction, dicomData.RedPaletteColorLookupTableData,
                    dicomData.GreenPaletteColorLookupTableData, dicomData.BluePaletteColorLookupTableData,
                    dicomData.RedPaletteColorLookupTableDescriptor, dicomData.GreenPaletteColorLookupTableDescriptor,
                    dicomData.BluePaletteColorLookupTableDescriptor)
        if ((colourmap is not None)  and (colourmap != &#39;custom&#39;) and (colourmap != &#39;gray&#39;) 
            and (colourmap != &#39;default&#39;) and isinstance(colourmap, str)):
            dicomData.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
            dicomData.RGBLUTTransferFunction = &#39;TABLE&#39;
            dicomData.ContentLabel = colourmap
            stringType = &#39;US&#39; # (&#39;SS&#39; if minValue &lt; 0 else &#39;US&#39;)
            dicomData.PixelRepresentation = 0 # (1 if minValue &lt; 0 else 0)
            pixelArray = dicomData.pixel_array
            minValue = int(np.amin(pixelArray))
            maxValue = int(np.amax(pixelArray))
            numberOfValues = int(maxValue - minValue)
            arrayForRGB = np.arange(0, numberOfValues)
            colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
            totalBytes = dicomData.BitsAllocated
            dicomData.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
            dicomData.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
            dicomData.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
        if (levels is not None):
            if hasattr(dicomData, &#39;PerFrameFunctionalGroupsSequence&#39;):
                for index in range(len(dicomData.PerFrameFunctionalGroupsSequence)):
                    slope = float(getattr(dicomData.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0], &#39;RescaleSlope&#39;, 1))
                    intercept = float(getattr(dicomData.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0], &#39;RescaleIntercept&#39;, 0))
                    center = levels[0] # (levels[0] - intercept) / slope
                    width = levels[1] # / slope
                    dicomData.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowCenter = center
                    dicomData.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowWidth = width
            else:
                slope = float(getattr(dicomData, &#39;RescaleSlope&#39;, 1))
                intercept = float(getattr(dicomData, &#39;RescaleIntercept&#39;, 0))
                center = levels[0] # (levels[0] - intercept) / slope
                width = levels[1] # / slope
                dicomData.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
                dicomData.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
            
        return dicomData   
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.updateSingleDicom: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.updateSingleDicom: &#39; + str(e))

    
def saveDicomToFile(dicomData, output_path=None):
    &#34;&#34;&#34;This method takes a DICOM object and saves it as a DICOM file 
        with the set filename in the input arguments.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.saveDicomToFile called&#34;)
    try:
        if output_path is None:
            try:
                output_path = os.getcwd() + str(dicomData.InstanceNumber).zfill(6) + &#34;.dcm&#34;
            except:
                try:
                    output_path = os.getcwd() + str(dicomData.ImageNumber).zfill(6) + &#34;.dcm&#34;
                except:
                    output_path = os.getcwd() + str(dicomData.SOPInstanceUID) + &#34;.dcm&#34;

        pydicom.filewriter.dcmwrite(output_path, dicomData, write_like_original=True)
        # Try to read the new generated file to check if it&#39;s corrupted
        #list_tags = [&#39;InstanceNumber&#39;, &#39;SOPInstanceUID&#39;, &#39;PixelData&#39;, &#39;FloatPixelData&#39;, &#39;DoubleFloatPixelData&#39;, &#39;AcquisitionTime&#39;,
        #             &#39;AcquisitionDate&#39;, &#39;SeriesTime&#39;, &#39;SeriesDate&#39;, &#39;PatientName&#39;, &#39;PatientID&#39;, &#39;StudyDate&#39;, &#39;StudyTime&#39;, 
        #             &#39;SeriesDescription&#39;, &#39;SequenceName&#39;, &#39;ProtocolName&#39;, &#39;SeriesNumber&#39;, &#39;PerFrameFunctionalGroupsSequence&#39;]
        #try:
        #    pydicom.dcmread(output_path, specific_tags=list_tags)
        #except:
        #    del output_path
        #    print(&#39;File &#39; + output_path + &#39; corrupted during the saving process. Weasel deleted the mentioned file locally.&#39;)
        return
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveDicomToFile: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveDicomToFile: &#39; + str(e))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Weasel.DICOM.SaveDICOM_Image.createNewPixelArray"><code class="name flex">
<span>def <span class="ident">createNewPixelArray</span></span>(<span>imageArray, dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>This method saves the imageArray into the <code>dataset</code> input argument based on other DICOM parameters in <code>dataset</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNewPixelArray(imageArray, dataset):
    &#34;&#34;&#34;This method saves the imageArray into the `dataset` input argument based on other DICOM parameters in `dataset`.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.createNewPixelArray called&#34;)
    try:
        # Delete &#39;Philips Rescale Slope&#39; tag if it exists
        if [0x2005, 0x100E] in dataset:
            del dataset[0x2005, 0x100E]
        # If the new array is a binary image / mask
        if len(np.unique(imageArray)) == 2:
            param.editDicom(dataset, imageArray, &#34;SEG&#34;)
            return dataset
        numberFrames = 1
        enhancedArrayInt = []
        numDimensions = len(np.shape(imageArray))
        # If Enhanced MRI, then:
        # For each frame, slope and intercept are M and B. For registration, I will have to add Image Position and Orientation
        if hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
            if numDimensions == 2:
                dataset.NumberOfFrames = 1
            else:
                dataset.NumberOfFrames = np.shape(imageArray)[0]
            del dataset.PerFrameFunctionalGroupsSequence[dataset.NumberOfFrames:]
            numberFrames = dataset.NumberOfFrames
        for index in range(numberFrames):
            if len(np.shape(imageArray)) == 2:
                tempArray = imageArray
            else:
                tempArray = np.squeeze(imageArray[index, ...])
            dataset.PixelRepresentation = 0
            target = (np.power(2, dataset.BitsAllocated) - 1) * np.ones(np.shape(tempArray))
            maximum = np.ones(np.shape(tempArray)) * np.amax(tempArray)
            minimum = np.ones(np.shape(tempArray)) * np.amin(tempArray)
            imageScaled = target * (tempArray - minimum) / (maximum - minimum)
            slope =  target / (maximum - minimum)
            intercept = (- target * minimum)/ (maximum - minimum)
            rescaleSlope = np.ones(np.shape(tempArray)) / slope
            rescaleIntercept = - intercept / slope
            if dataset.BitsAllocated == 8:
                imageArrayInt = imageScaled.astype(np.uint8)
            elif dataset.BitsAllocated == 16:
                imageArrayInt = imageScaled.astype(np.uint16)
            elif dataset.BitsAllocated == 32:
                imageArrayInt = imageScaled.astype(np.uint32)
            elif dataset.BitsAllocated == 64:
                imageArrayInt = imageScaled.astype(np.uint64)
            else:
                imageArrayInt = imageScaled.astype(dataset.pixel_array.dtype)
            dataset.add_new(&#39;0x00280106&#39;, &#39;US&#39;, int(np.amin(imageArrayInt)))
            dataset.add_new(&#39;0x00280107&#39;, &#39;US&#39;, int(np.amax(imageArrayInt)))
            if hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
                # Rotate back to Original Position
                enhancedArrayInt.append(np.transpose(imageArrayInt))
                # Rescsale Slope and Intercept
                dataset.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0].RescaleSlope = rescaleSlope.flatten()[0]
                dataset.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0].RescaleIntercept = rescaleIntercept.flatten()[0]
                # Set Window Center and Width
                center = (np.amax(tempArray) + np.amin(tempArray)) / 2 # (0 if int(np.amin(imageArrayInt)) &lt; 0 else int(target.flatten()[0]/2))
                width = np.amax(tempArray) - np.amin(tempArray) # int(target.flatten()[0])
                if width == 1.0: width = 1.1 
                dataset.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowCenter = center
                dataset.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowWidth = width
            else:
                # Rotate back to Original Position
                imageArrayInt = np.transpose(imageArrayInt)
                # Rescsale Slope and Intercept
                dataset.RescaleSlope = rescaleSlope.flatten()[0]
                dataset.RescaleIntercept = rescaleIntercept.flatten()[0]
                # Set Window Center and Width
                center = (np.amax(tempArray) + np.amin(tempArray)) / 2
                width = np.amax(tempArray) - np.amin(tempArray)
                if width == 1.0: width = 1.1
                dataset.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
                dataset.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
                # dataset.WindowCenter = (0 if int(np.amin(imageArrayInt)) &lt; 0 else int(target.flatten()[0]/2))
                # dataset.WindowWidth = int(target.flatten()[0])
        if enhancedArrayInt:
            imageArrayInt = np.array(enhancedArrayInt)
        
        # Set the shape/dimensions and PixelData
        dataset.Rows = np.shape(imageArrayInt)[-2]
        dataset.Columns = np.shape(imageArrayInt)[-1]
        dataset.PixelData = imageArrayInt.tobytes()
        del imageScaled, enhancedArrayInt, tempArray
        return dataset
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.createNewPixelArray: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.createNewPixelArray: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.createNewSingleDicom"><code class="name flex">
<span>def <span class="ident">createNewSingleDicom</span></span>(<span>dicomData, imageArray, series_id=None, series_uid=None, series_name=None, comment=None, parametric_map=None, colourmap=None, list_refs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes a DICOM Object, copies most of the DICOM tags from the DICOM given in input
and writes the imageArray into the new DICOM Object in PixelData.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNewSingleDicom(dicomData, imageArray, series_id=None, series_uid=None, series_name=None, comment=None, parametric_map=None, colourmap=None, list_refs=None):
    &#34;&#34;&#34;This function takes a DICOM Object, copies most of the DICOM tags from the DICOM given in input
        and writes the imageArray into the new DICOM Object in PixelData. 
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.createNewSingleDicom called&#34;)
    try:
        newDicom = copy.deepcopy(dicomData)
        #imageArray = copy.deepcopy(imageArray)

        # Series ID and UID
        if (series_id is None) and (series_uid is None):
            ids = generateUIDs(dicomData)
            series_id = ids[0]
            series_uid = ids[1]
        elif (series_id is not None) and (series_uid is None):
            series_uid = generateUIDs(dicomData, seriesNumber=series_id)[1]
        elif (series_id is None) and (series_uid is not None):
            series_id = str(dicomData.SeriesNumber) + str(random.randint(0, 999))
        newDicom.SeriesNumber = int(series_id)
        newDicom.SeriesInstanceUID = series_uid

        # Generate Unique ID based on the Series ID
        newDicom.SOPInstanceUID = generateUIDs(newDicom, seriesNumber=series_id)[2]

        # Date and Time of Creation
        dt = datetime.now()
        timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds
        newDicom.ContentDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.ContentTime = timeStr
        newDicom.InstanceCreationDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.InstanceCreationTime = timeStr
        newDicom.SeriesDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.ImageDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.AcquisitionDate = dt.strftime(&#39;%Y%m%d&#39;)
        newDicom.SeriesTime = timeStr
        newDicom.ImageTime = timeStr
        newDicom.AcquisitionTime = timeStr
        newDicom.ImageType.insert(0, &#34;DERIVED&#34;)

        # Series, Instance and Class for Reference
        refd_series_sequence = Sequence()
        newDicom.ReferencedSeriesSequence = refd_series_sequence
        refd_series1 = Dataset()
        refd_instance_sequence = Sequence()
        refd_series1.ReferencedInstanceSequence = refd_instance_sequence
        refd_instance1 = Dataset()
        refd_instance1.ReferencedSOPClassUID = dicomData.SOPClassUID
        refd_instance1.ReferencedSOPInstanceUID = dicomData.SOPInstanceUID
        refd_instance_sequence.append(refd_instance1)
        refd_series1.SeriesInstanceUID = dicomData.SeriesInstanceUID
        refd_series_sequence.append(refd_series1)

        # Extra references, besides the main one, which is dicomData
        if list_refs is not None:
            if np.shape(list_refs) == ():
                refd_series1 = Dataset()
                refd_instance_sequence = Sequence()
                refd_series1.ReferencedInstanceSequence = refd_instance_sequence
                refd_instance1 = Dataset()
                refd_instance1.ReferencedSOPInstanceUID = list_refs.SOPInstanceUID
                refd_instance1.ReferencedSOPClassUID = list_refs.SOPClassUID
                refd_instance_sequence.append(refd_instance1)
                refd_series1.SeriesInstanceUID = list_refs.SeriesInstanceUID
                refd_series_sequence.append(refd_series1)
            else:
                for individualRef in list_refs:
                    refd_series1 = Dataset()
                    refd_instance_sequence = Sequence()
                    refd_series1.ReferencedInstanceSequence = refd_instance_sequence
                    refd_instance1 = Dataset()
                    refd_instance1.ReferencedSOPInstanceUID = individualRef.SOPInstanceUID
                    refd_instance1.ReferencedSOPClassUID = individualRef.SOPClassUID
                    refd_instance_sequence.append(refd_instance1)
                    refd_series1.SeriesInstanceUID = individualRef.SeriesInstanceUID
                    refd_series_sequence.append(refd_series1)
            del list_refs

        # Comments
        if comment is not None:
            newDicom.ImageComments = comment
            # Then assign new Series Name by default
            if len(dicomData.dir(&#34;SeriesDescription&#34;))&gt;0:
                newDicom.SeriesDescription = dicomData.SeriesDescription + comment
            elif len(dicomData.dir(&#34;SequenceName&#34;))&gt;0 &amp; len(dicomData.dir(&#34;PulseSequenceName&#34;))==0:
                newDicom.SeriesDescription = dicomData.SequenceName + comment
            elif len(dicomData.dir(&#34;ProtocolName&#34;))&gt;0:
                newDicom.SeriesDescription = dicomData.ProtocolName + comment
            else:
                newDicom.SeriesDescription = &#34;NewSeries&#34; + newDicom.SeriesNumber
                
        # But if the user provides a Series Name
        if series_name:
            newDicom.SeriesDescription = series_name

        # Parametric Map
        if parametric_map is not None:
            param.editDicom(newDicom, imageArray, parametric_map)
            return newDicom

        newDicom = createNewPixelArray(imageArray, newDicom)    

        # Add colourmap here
        if (colourmap is None) and hasattr(newDicom, &#39;PhotometricInterpretation&#39;):
            if newDicom.PhotometricInterpretation == &#39;PALETTE COLOR&#39;:
                # This deletes the colourmap that came with the source/input DICOM
                stringType = &#39;US&#39;
                imageArrayInt = newDicom.pixel_array
                minValue = int(np.amin(imageArrayInt))
                numberOfValues = int(np.amax(imageArrayInt))
                arrayForRGB = np.arange(0, numberOfValues)
                colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
                totalBytes = dicomData.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
        elif colourmap is not None:
            if isinstance(colourmap, str):
                newDicom.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
                newDicom.RGBLUTTransferFunction = &#39;TABLE&#39;
                newDicom.ContentLabel = colourmap
                stringType = &#39;US&#39;
                imageArrayInt = newDicom.pixel_array
                minValue = int(np.amin(imageArrayInt))
                numberOfValues = int(np.amax(imageArrayInt))
                arrayForRGB = np.arange(0, numberOfValues)
                colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
                totalBytes = dicomData.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                del imageArrayInt
            else:
                colorsList = np.unique(colourmap, axis=0) / int(np.amax(colourmap))
                newDicom.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
                newDicom.RGBLUTTransferFunction = &#39;TABLE&#39;
                numberOfValues = len(colorsList)
                pixelArray = newDicom.pixel_array
                minValue = int(np.amin(pixelArray))
                totalBytes = newDicom.BitsAllocated
                newDicom.add_new(&#39;0x00281101&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281102&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.add_new(&#39;0x00281103&#39;, &#39;US&#39;, [numberOfValues, minValue, totalBytes])
                newDicom.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                newDicom.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                    2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
                if hasattr(newDicom, &#39;ContentLabel&#39;):
                    del newDicom.ContentLabel

        del dicomData, imageArray#, imageArrayInt, imageScaled, enhancedArrayInt, tempArray
        return newDicom
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.createNewSingleDicom: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.createNewSingleDicom: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.generateUIDs"><code class="name flex">
<span>def <span class="ident">generateUIDs</span></span>(<span>dataset, seriesNumber=None, studyUID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates and returns a SeriesUID and an InstanceUID.
It also returns SeriesNumber in the first index of the output list.
The SeriesUID is generated based on the StudyUID and on seriesNumber (if provided)
The InstanceUID is generated based on SeriesUID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateUIDs(dataset, seriesNumber=None, studyUID=None):
    &#34;&#34;&#34;
    This function generates and returns a SeriesUID and an InstanceUID.
    It also returns SeriesNumber in the first index of the output list.
    The SeriesUID is generated based on the StudyUID and on seriesNumber (if provided)
    The InstanceUID is generated based on SeriesUID.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.generateUIDs called&#34;)
    try:
        if studyUID is None:     
            studyUID = dataset.StudyInstanceUID
        # See http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_B.html regarding UID creation rules
        prefix = studyUID.split(&#34;.&#34;, maxsplit=7)
        prefix = &#39;.&#39;.join(prefix[:6])
        if seriesNumber is None:
            seriesNumber = str(dataset.SeriesNumber) + str(random.randint(0, 999))
        prefixSeries = prefix + &#34;.&#34; + str(seriesNumber) + &#34;.&#34;
        imageNumber = str(dataset.InstanceNumber).lstrip(&#34;0&#34;)
        if imageNumber == &#34;&#34;: imageNumber = &#34;999999&#34; 
        prefixImage = prefix + &#34;.&#34; + str(seriesNumber) + &#34;.&#34; + imageNumber + &#34;.&#34;
        seriesUID = pydicom.uid.generate_uid(prefix=prefixSeries)
        imageUID = pydicom.uid.generate_uid(prefix=prefixImage)
        return [seriesNumber, seriesUID, imageUID]
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.generateUIDs: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.generateUIDs: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.overwriteDicomFileTag"><code class="name flex">
<span>def <span class="ident">overwriteDicomFileTag</span></span>(<span>imagePath, dicomTag, newValue)</span>
</code></dt>
<dd>
<div class="desc"><p>This method writes the <code>newValue</code> into the <code>dicomTag</code> in <code>imagePath</code>.
If <code>dicomTag</code> exists in <code>imagePath</code>, this will overwrite.
Otherwise, it will create <code>dicomTag</code> and store the <code>newValue</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overwriteDicomFileTag(imagePath, dicomTag, newValue):
    &#34;&#34;&#34;
    This method writes the `newValue` into the `dicomTag` in `imagePath`.
    If `dicomTag` exists in `imagePath`, this will overwrite.
    Otherwise, it will create `dicomTag` and store the `newValue`.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.overwriteDicomFileTag called&#34;)
    try:
        if isinstance(imagePath, list):
            datasetList = ReadDICOM_Image.getSeriesDicomDataset(imagePath)
            for index, dataset in enumerate(datasetList):
                if isinstance(dicomTag, str):
                    try: 
                        if dataset.data_element(dicomTag).VR == &#34;TM&#34;: 
                            dataset.data_element(dicomTag).value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset.data_element(dicomTag).value = newValue
                    except:
                        if dictionary_VR(dicomTag) == &#34;TM&#34;: 
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue) 
                elif isinstance(dicomTag, tuple):
                    try:
                        if dataset[dicomTag].VR == &#34;TM&#34;:
                            dataset[dicomTag].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset[dicomTag].value = newValue
                    except:
                        if dataset[dicomTag].VR == &#34;TM&#34;:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue)
                else:
                    try:
                        if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                            dataset[hex(dicomTag)].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                        else:
                            dataset[hex(dicomTag)].value = newValue
                    except:
                        if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                            dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                        else:
                            dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), newValue)
                saveDicomToFile(dataset, output_path=imagePath[index])
        else:
            dataset = ReadDICOM_Image.getDicomDataset(imagePath)
            if isinstance(dicomTag, str):
                try: 
                    if dataset.data_element(dicomTag).VR == &#34;TM&#34;: 
                        dataset.data_element(dicomTag).value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset.data_element(dicomTag).value = newValue
                except:
                    if dictionary_VR(dicomTag) == &#34;TM&#34;: 
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue) 
            elif isinstance(dicomTag, tuple):
                try:
                    if dataset[dicomTag].VR == &#34;TM&#34;:
                        dataset[dicomTag].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset[dicomTag].value = newValue
                except:
                    if dataset[dicomTag].VR == &#34;TM&#34;:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(dicomTag, dictionary_VR(dicomTag), newValue)
            else:
                try:
                    if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                        dataset[hex(dicomTag)].value = datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;)
                    else:
                        dataset[hex(dicomTag)].value = newValue
                except:
                    if dataset[hex(dicomTag)].VR == &#34;TM&#34;:
                        dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), datetime.strptime(str(timedelta(seconds=int(newValue))), &#34;%H:%M:%S&#34;))
                    else:
                        dataset.add_new(hex(dicomTag), dictionary_VR(hex(dicomTag)), newValue)
            saveDicomToFile(dataset, output_path=imagePath)
        return
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.overwriteDicomFileTag: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.overwriteDicomFileTag: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.returnFilePath"><code class="name flex">
<span>def <span class="ident">returnFilePath</span></span>(<span>imagePath, suffix, new_path=None, output_folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the new filepath of the object to be saved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returnFilePath(imagePath, suffix, new_path=None, output_folder=None):
    &#34;&#34;&#34;This method returns the new filepath of the object to be saved.&#34;&#34;&#34;
    # Think of a way to choose a select a new FilePath
    logger.info(&#34;SaveDICOM_Image.returnFilePath called&#34;)
    try:
        if os.path.exists(imagePath):
            # Need to think about what new name to give to the file and how to save multiple files for the same sequence
            if new_path is not None:
                newFilePath = new_path + &#39;.dcm&#39;
            else:
                if output_folder is None:
                    outputFolder = os.path.join(os.path.dirname(imagePath), &#34;output&#34; + suffix)
                else:
                    outputFolder = output_folder
                fileName = os.path.splitext(os.path.basename(imagePath))[0]
                os.makedirs(outputFolder, exist_ok=True)
                newFilePath = os.path.join(outputFolder, fileName + suffix + &#39;.dcm&#39;)
                counter = 1
                loop = 1
                if os.path.exists(newFilePath):
                    while loop == 1:
                        newFilePath = os.path.join(outputFolder, fileName + suffix + &#39;(&#39; + str(counter) + &#39;)&#39; + &#39;.dcm&#39;)
                        if os.path.exists(newFilePath):
                            counter += 1
                        else:
                            loop = 0
            return newFilePath

        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.returnFilePath: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.returnFilePath: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.saveDicomNewSeries"><code class="name flex">
<span>def <span class="ident">saveDicomNewSeries</span></span>(<span>derivedImagePathList, imagePathList, pixelArrayList, suffix, series_id=None, series_uid=None, series_name=None, parametric_map=None, colourmap=None, list_refs_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method saves the pixelArrayList into DICOM files with metadata pointing to the same series</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveDicomNewSeries(derivedImagePathList, imagePathList, pixelArrayList, suffix, series_id=None, series_uid=None, series_name=None, parametric_map=None, colourmap=None, list_refs_path=None):
    &#34;&#34;&#34;This method saves the pixelArrayList into DICOM files with metadata pointing to the same series&#34;&#34;&#34;
    # What if it&#39;s a map with less files than original? Think about iterating the first elements and sort path list by SliceLocation - see T2* algorithm
    # Think of a way to choose a select a new FilePath or Folder
    logger.info(&#34;SaveDICOM_Image.saveDicomNewSeries called&#34;)
    try:
        if os.path.exists(imagePathList[0]):
            # Series ID and UID
            if (series_id is None) and (series_uid is None):
                ids = generateUIDs(ReadDICOM_Image.getDicomDataset(imagePathList[0]))
                series_id = ids[0]
                series_uid = ids[1]
            elif (series_id is not None) and (series_uid is None):
                series_uid = generateUIDs(ReadDICOM_Image.getDicomDataset(imagePathList[0]), seriesNumber=series_id)[1]
            elif (series_id is None) and (series_uid is not None):
                series_id = int(str(ReadDICOM_Image.getDicomDataset(imagePathList[0]).SeriesNumber) + str(random.randint(0, 9999)))

            refs = None
            for index, newFilePath in enumerate(derivedImagePathList):
                # Extra references, besides the main one, which is imagePathList
                if list_refs_path is not None:
                    if len(np.shape(list_refs_path)) == 1:
                        refs = list_refs_path[index]
                    else:
                        refs = []
                        for individualRef in list_refs_path:
                            refs.append(individualRef[index])
                if colourmap is not None:
                    if isinstance(colourmap, str):
                        colour = colourmap
                    else:
                        colour = colourmap[index, ...]
                else:
                    colour = None

                saveNewSingleDicomImage(newFilePath, imagePathList[index], pixelArrayList[index], suffix, series_id=series_id, series_uid=series_uid, series_name=series_name, image_number=index+1, parametric_map=parametric_map, 
                                      colourmap=colour, list_refs_path=refs)
            del series_id, series_uid, refs
            return
        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveDicomNewSeries: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveDicomNewSeries: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.saveDicomToFile"><code class="name flex">
<span>def <span class="ident">saveDicomToFile</span></span>(<span>dicomData, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes a DICOM object and saves it as a DICOM file
with the set filename in the input arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveDicomToFile(dicomData, output_path=None):
    &#34;&#34;&#34;This method takes a DICOM object and saves it as a DICOM file 
        with the set filename in the input arguments.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.saveDicomToFile called&#34;)
    try:
        if output_path is None:
            try:
                output_path = os.getcwd() + str(dicomData.InstanceNumber).zfill(6) + &#34;.dcm&#34;
            except:
                try:
                    output_path = os.getcwd() + str(dicomData.ImageNumber).zfill(6) + &#34;.dcm&#34;
                except:
                    output_path = os.getcwd() + str(dicomData.SOPInstanceUID) + &#34;.dcm&#34;

        pydicom.filewriter.dcmwrite(output_path, dicomData, write_like_original=True)
        # Try to read the new generated file to check if it&#39;s corrupted
        #list_tags = [&#39;InstanceNumber&#39;, &#39;SOPInstanceUID&#39;, &#39;PixelData&#39;, &#39;FloatPixelData&#39;, &#39;DoubleFloatPixelData&#39;, &#39;AcquisitionTime&#39;,
        #             &#39;AcquisitionDate&#39;, &#39;SeriesTime&#39;, &#39;SeriesDate&#39;, &#39;PatientName&#39;, &#39;PatientID&#39;, &#39;StudyDate&#39;, &#39;StudyTime&#39;, 
        #             &#39;SeriesDescription&#39;, &#39;SequenceName&#39;, &#39;ProtocolName&#39;, &#39;SeriesNumber&#39;, &#39;PerFrameFunctionalGroupsSequence&#39;]
        #try:
        #    pydicom.dcmread(output_path, specific_tags=list_tags)
        #except:
        #    del output_path
        #    print(&#39;File &#39; + output_path + &#39; corrupted during the saving process. Weasel deleted the mentioned file locally.&#39;)
        return
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveDicomToFile: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveDicomToFile: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.saveNewSingleDicomImage"><code class="name flex">
<span>def <span class="ident">saveNewSingleDicomImage</span></span>(<span>newFilePath, imagePath, pixelArray, suffix, series_id=None, series_uid=None, series_name=None, image_number=None, parametric_map=None, colourmap=None, list_refs_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method saves the new pixelArray into DICOM in the given newFilePath</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveNewSingleDicomImage(newFilePath, imagePath, pixelArray, suffix, series_id=None, series_uid=None, series_name=None, image_number=None, parametric_map=None, colourmap=None, list_refs_path=None):
    &#34;&#34;&#34;This method saves the new pixelArray into DICOM in the given newFilePath&#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.saveNewSingleDicomImage called&#34;)
    try:
        if os.path.exists(imagePath):
            dataset = ReadDICOM_Image.getDicomDataset(imagePath)
            if list_refs_path is not None:
                refs = []
                for individualRef in list_refs_path:
                    refs.append(ReadDICOM_Image.getDicomDataset(individualRef))
            else:
                refs = None
            if colourmap is not None:
                if isinstance(colourmap, str):
                    pass
                else:
                    colourmap = colourmap.reshape(-1, colourmap.shape[-1]) # Flatten (x, y, 3) to (x*y, 3)
            newDataset = createNewSingleDicom(dataset, pixelArray, series_id=series_id, series_uid=series_uid, series_name=series_name, comment=suffix, parametric_map=parametric_map, colourmap=colourmap, list_refs=refs)
            if (image_number is not None) and (len(np.shape(pixelArray)) &lt; 3):
                newDataset.InstanceNumber = image_number
                newDataset.ImageNumber = image_number
            saveDicomToFile(newDataset, output_path=newFilePath)
            del dataset, newDataset, refs, image_number
            return
        else:
            return None
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.saveNewSingleDicomImage: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.saveNewSingleDicomImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.updateSingleDicom"><code class="name flex">
<span>def <span class="ident">updateSingleDicom</span></span>(<span>dicomData, colourmap=None, levels=None, lut=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes a DICOM Object and changes it to include the
new colourmap selected in the interface. It will have more features in the future.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateSingleDicom(dicomData, colourmap=None, levels=None, lut=None):
    &#34;&#34;&#34;This function takes a DICOM Object and changes it to include the
        new colourmap selected in the interface. It will have more features in the future.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.updateSingleDicom called&#34;)
    try:
        #and (colourmap != &#39;gray&#39;) removed from If statement below, so as to save gray colour tables
        if (colourmap == &#39;gray&#39;):
            dicomData.PhotometricInterpretation = &#39;MONOCHROME2&#39;
            dicomData.ContentLabel = &#39;&#39;
            if hasattr(dicomData, &#39;RedPaletteColorLookupTableData&#39;):
                del (dicomData.RGBLUTTransferFunction, dicomData.RedPaletteColorLookupTableData,
                    dicomData.GreenPaletteColorLookupTableData, dicomData.BluePaletteColorLookupTableData,
                    dicomData.RedPaletteColorLookupTableDescriptor, dicomData.GreenPaletteColorLookupTableDescriptor,
                    dicomData.BluePaletteColorLookupTableDescriptor)
        if ((colourmap is not None)  and (colourmap != &#39;custom&#39;) and (colourmap != &#39;gray&#39;) 
            and (colourmap != &#39;default&#39;) and isinstance(colourmap, str)):
            dicomData.PhotometricInterpretation = &#39;PALETTE COLOR&#39;
            dicomData.RGBLUTTransferFunction = &#39;TABLE&#39;
            dicomData.ContentLabel = colourmap
            stringType = &#39;US&#39; # (&#39;SS&#39; if minValue &lt; 0 else &#39;US&#39;)
            dicomData.PixelRepresentation = 0 # (1 if minValue &lt; 0 else 0)
            pixelArray = dicomData.pixel_array
            minValue = int(np.amin(pixelArray))
            maxValue = int(np.amax(pixelArray))
            numberOfValues = int(maxValue - minValue)
            arrayForRGB = np.arange(0, numberOfValues)
            colorsList = cm.ScalarMappable(cmap=colourmap).to_rgba(np.array(arrayForRGB), bytes=False)
            totalBytes = dicomData.BitsAllocated
            dicomData.add_new(&#39;0x00281101&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.add_new(&#39;0x00281102&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.add_new(&#39;0x00281103&#39;, stringType, [numberOfValues, minValue, totalBytes])
            dicomData.RedPaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 0].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
            dicomData.GreenPaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 1].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
            dicomData.BluePaletteColorLookupTableData = bytes(np.array([int((np.power(
                2, totalBytes) - 1) * value) for value in colorsList[:, 2].flatten()]).astype(&#39;uint&#39;+str(totalBytes)))
        if (levels is not None):
            if hasattr(dicomData, &#39;PerFrameFunctionalGroupsSequence&#39;):
                for index in range(len(dicomData.PerFrameFunctionalGroupsSequence)):
                    slope = float(getattr(dicomData.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0], &#39;RescaleSlope&#39;, 1))
                    intercept = float(getattr(dicomData.PerFrameFunctionalGroupsSequence[index].PixelValueTransformationSequence[0], &#39;RescaleIntercept&#39;, 0))
                    center = levels[0] # (levels[0] - intercept) / slope
                    width = levels[1] # / slope
                    dicomData.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowCenter = center
                    dicomData.PerFrameFunctionalGroupsSequence[index].FrameVOILUTSequence[0].WindowWidth = width
            else:
                slope = float(getattr(dicomData, &#39;RescaleSlope&#39;, 1))
                intercept = float(getattr(dicomData, &#39;RescaleIntercept&#39;, 0))
                center = levels[0] # (levels[0] - intercept) / slope
                width = levels[1] # / slope
                dicomData.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
                dicomData.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
            
        return dicomData   
    except Exception as e:
        print(&#39;Error in function SaveDICOM_Image.updateSingleDicom: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.updateSingleDicom: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="Weasel.DICOM.SaveDICOM_Image.updateSingleDicomImage"><code class="name flex">
<span>def <span class="ident">updateSingleDicomImage</span></span>(<span>objWeasel, spinBoxIntensity, spinBoxContrast, imagePath='', seriesID='', studyID='', colourmap=None, lut=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used in the Displays module. It saves the image in the viewer to DICOM,
with the intensity and contrast values and colourmap set in the viewer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateSingleDicomImage(objWeasel, spinBoxIntensity, spinBoxContrast, 
                imagePath=&#39;&#39;, seriesID=&#39;&#39;, studyID=&#39;&#39;, colourmap=None, lut=None):
    &#34;&#34;&#34;This method is used in the Displays module. It saves the image in the viewer to DICOM, 
        with the intensity and contrast values and colourmap set in the viewer.
    &#34;&#34;&#34;
    logger.info(&#34;SaveDICOM_Image.updateSingleDicomImage called&#34;)
    try:
        logger.info(&#34;In SaveDICOM_Image.updateSingleDicomImage&#34;)
        objWeasel.progress_bar(msg=&#34;&lt;H4&gt;Updating 1 DICOM file&lt;/H4&gt;&#34;)
        objWeasel.progressBar.set_maximum(1)
        objWeasel.progressBar.set_value(0)
        dataset = ReadDICOM_Image.getDicomDataset(imagePath)
        levels = [spinBoxIntensity.value(), spinBoxContrast.value()]
        updatedDataset = updateSingleDicom(dataset, colourmap=colourmap, levels=levels, lut=lut)
        saveDicomToFile(updatedDataset, output_path=imagePath)
        objWeasel.progressBar.set_value(1)
        objWeasel.progressBar.close()
    except Exception as e:
        print(&#39;Error in SaveDICOM_Image.updateSingleDicomImage: &#39; + str(e))
        logger.exception(&#39;Error in SaveDICOM_Image.updateSingleDicomImage: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Weasel.DICOM" href="index.html">Weasel.DICOM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.createNewPixelArray" href="#Weasel.DICOM.SaveDICOM_Image.createNewPixelArray">createNewPixelArray</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.createNewSingleDicom" href="#Weasel.DICOM.SaveDICOM_Image.createNewSingleDicom">createNewSingleDicom</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.generateUIDs" href="#Weasel.DICOM.SaveDICOM_Image.generateUIDs">generateUIDs</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.overwriteDicomFileTag" href="#Weasel.DICOM.SaveDICOM_Image.overwriteDicomFileTag">overwriteDicomFileTag</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.returnFilePath" href="#Weasel.DICOM.SaveDICOM_Image.returnFilePath">returnFilePath</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.saveDicomNewSeries" href="#Weasel.DICOM.SaveDICOM_Image.saveDicomNewSeries">saveDicomNewSeries</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.saveDicomToFile" href="#Weasel.DICOM.SaveDICOM_Image.saveDicomToFile">saveDicomToFile</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.saveNewSingleDicomImage" href="#Weasel.DICOM.SaveDICOM_Image.saveNewSingleDicomImage">saveNewSingleDicomImage</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.updateSingleDicom" href="#Weasel.DICOM.SaveDICOM_Image.updateSingleDicom">updateSingleDicom</a></code></li>
<li><code><a title="Weasel.DICOM.SaveDICOM_Image.updateSingleDicomImage" href="#Weasel.DICOM.SaveDICOM_Image.updateSingleDicomImage">updateSingleDicomImage</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>