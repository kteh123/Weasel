<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>WEASEL.DICOM.ParametricMapsDictionary API documentation</title>
<meta name="description" content="This module is used in `SaveDICOM_Image.py` and used as the optional argument `parametric_map` in write functions of `Classes.py` and in â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>WEASEL.DICOM.ParametricMapsDictionary</code></h1>
</header>
<section id="section-intro">
<p>This module is used in <code>SaveDICOM_Image.py</code> and used as the optional argument <code>parametric_map</code> in write functions of <code>Classes.py</code> and in "writeNewPixelArray" of <code>DeveloperTools.py</code>.</p>
<p>The functions in this module capture special versions of DICOM with unique parameters/attributes/values.</p>
<p><strong>How to use:</strong> provide the parametric_map in the functions mentioned previously as a string. This string is the name of one of the functions in the ParametricClass (eg. parametric_map="RGB" or parametric_map="SEG")</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is used in `SaveDICOM_Image.py` and used as the optional argument `parametric_map` in write functions of `Classes.py` and in &#34;writeNewPixelArray&#34; of `DeveloperTools.py`.

The functions in this module capture special versions of DICOM with unique parameters/attributes/values.

**How to use:** provide the parametric_map in the functions mentioned previously as a string. This string is the name of one of the functions in the ParametricClass (eg. parametric_map=&#34;RGB&#34; or parametric_map=&#34;SEG&#34;)
&#34;&#34;&#34;

import pydicom
from pydicom.dataset import Dataset
from pydicom.sequence import Sequence
import numpy as np
import datetime
import struct

def editDicom(newDicom, imageArray, parametricMap):

    callCase = ParametricClass()
    callCase.selectParametricMap(newDicom, imageArray, parametricMap)

    dt = datetime.datetime.now()
    timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds
    newDicom.PerformedProcedureStepStartDate = dt.strftime(&#39;%Y%m%d&#39;)
    newDicom.PerformedProcedureStepStartTime = timeStr
    newDicom.PerformedProcedureStepDescription = &#34;Post-processing application&#34;

    return newDicom
  
class ParametricClass(object):
    def selectParametricMap(self, dicom, imageArray, argument):
        methodName = argument
        method = getattr(self, methodName, lambda: &#34;No valid Parametric Map chosen&#34;)
        return method(dicom, imageArray)

    def RGB(self, dicom, imageArray):
        dicom.PhotometricInterpretation = &#39;RGB&#39;
        dicom.SamplesPerPixel = 3
        dicom.BitsAllocated = 8
        dicom.BitsStored = 8
        dicom.HighBit = 7
        dicom.add_new(0x00280006, &#39;US&#39;, 0) # Planar Configuration
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        pixelArray = imageArray.astype(np.uint8) # Should we multiply by 255?
        dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
        dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
        dicom.PixelData = pixelArray.tobytes()
        return

    def ADC(self, dicom, imageArray):
        # The commented parts are to apply when we decide to include Parametric Map IOD. No readers can deal with this yet
        # dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.67&#39;
        dicom.SeriesDescription = &#34;Apparent Diffusion Coefficient (um2/s)&#34;
        dicom.Modality = &#34;RWV&#34;
        dicom.FrameLaterality = &#34;U&#34;
        dicom.DerivedPixelContrast = &#34;ADC&#34;
        dicom.BitsAllocated = 32
        dicom.PixelRepresentation = 1
        dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
        dicom.PixelAspectRatio = [&#34;1&#34;, &#34;1&#34;] # Need to have a better look at this
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        # Rotate the image back to the original orientation
        imageArray = np.transpose(imageArray)
        dicom.Rows = np.shape(imageArray)[-2]
        dicom.Columns = np.shape(imageArray)[-1]
        dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
        dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
        dicom.FloatPixelData = bytes(imageArray.astype(np.float32).flatten())
        del dicom.PixelData, dicom.BitsStored, dicom.HighBit

        dicom.RealWorldValueMappingSequence = [Dataset(), Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence = [Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[0].ValueType = &#34;CODE&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence = [Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[0].CodeValue = &#34;113041&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[1].CodingSchemeDesignator = &#34;DCM&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[2].CodeMeaning = &#34;Apparent Diffusion Coefficient&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence = [Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[0].CodeValue = &#34;um2/s&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[1].CodingSchemeDesignator = &#34;UCUM&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[2].CodeMeaning = &#34;um2/s&#34;
        dicom.RealWorldValueMappingSequence[2].RealWorldValueSlope = 1
        
        anatomyString = dicom.BodyPartExamined
        saveAnatomicalInfo(anatomyString, dicom.RealWorldValueMappingSequence[3])

        return

    def T2Star(self, dicom, imageArray):
        dicom.PixelSpacing = [3, 3] # find a mechanism to pass reconstruct pixel here
        return

    def SEG(self, dicom, imageArray):
        #dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.66.4&#39; # WILL NOT BE USED HERE - This is for PACS. There will be another one for DICOM Standard
        # The commented parts are to apply when we decide to include SEG IOD. No readers can deal with this yet
        dicom.BitsAllocated = 8 # According to Federov DICOM Standard this should be 1-bit
        dicom.BitsStored = 8
        dicom.HighBit = 7
        #dicom.SmallestImagePixelValue = 0
        #dicom.LargestImagePixelValue = int(np.amax(imageArray)) # max 255
        dicom.add_new(&#39;0x00280106&#39;, &#39;US&#39;, 0) # Minimum
        dicom.add_new(&#39;0x00280107&#39;, &#39;US&#39;, int(np.amax(imageArray))) # Maximum
        dicom.PixelRepresentation = 0
        dicom.SamplesPerPixel = 1
        #dicom.WindowCenter = 0.5
        #dicom.WindowWidth = 1.1
        dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, 0.5) # WindowCenter
        dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, 1.1) # WindowWidth
        #dicom.RescaleIntercept = 0
        #dicom.RescaleSlope = 1
        dicom.add_new(&#39;0x00281052&#39;, &#39;DS&#39;, 0) # RescaleIntercept
        dicom.add_new(&#39;0x00281053&#39;, &#39;DS&#39;, 1) # RescaleSlope
        dicom.LossyImageCompression = &#39;00&#39;
        pixelArray = np.transpose(imageArray.astype(np.uint8)) # Should we multiply by 255?
        dicom.PixelData = pixelArray.tobytes()

        dicom.Modality = &#39;SEG&#39;
        dicom.SegmentationType = &#39;FRACTIONAL&#39;
        dicom.MaximumFractionalValue = int(np.amax(imageArray)) # max 255
        dicom.SegmentationFractionalType = &#39;OCCUPANCY&#39;

        # Segment Labels
        if hasattr(dicom, &#34;ImageComments&#34;):
            dicom.ContentDescription = dicom.ImageComments.split(&#39;_&#39;)[-1] # &#39;Image segmentation&#39;
            segment_numbers = np.unique(pixelArray)
            segment_dictionary = dict(list(enumerate(segment_numbers)))
            segment_label = dicom.ImageComments.split(&#39;_&#39;)[-1]
            segment_dictionary[0] = &#39;Background&#39;
            segment_dictionary[1] = segment_label
            for key in segment_dictionary:
                dicom.SegmentSequence = [Dataset(), Dataset(), Dataset(), Dataset(), Dataset(), Dataset()]
                dicom.SegmentSequence[0].SegmentAlgorithmType = &#39;MANUAL&#39;
                dicom.SegmentSequence[1].SegmentNumber = key
                dicom.SegmentSequence[2].SegmentDescription = str(segment_dictionary[key])
                dicom.SegmentSequence[3].SegmentLabel = str(segment_dictionary[key])
                dicom.SegmentSequence[4].SegmentAlgorithmName = &#34;Weasel&#34;
                if hasattr(dicom, &#34;BodyPartExamined&#34;):
                    anatomyString = dicom.BodyPartExamined
                    saveAnatomicalInfo(anatomyString, dicom.SegmentSequence[5])
        else:
            dicom.ContentDescription = &#34;Mask with no label&#34;

        return

    def Registration(self, dicom, imageArray):
        dicom.Modality = &#34;REG&#34;
        return

    def Signal(self, dicom, imageArray):
        dicom.Modality = &#34;RWV&#34;
        dicom.DerivedPixelContrast = &#34;GraphPlot&#34;
        dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        imageArray = np.transpose(imageArray.astype(np.float32))
        center = (np.amax(imageArray) + np.amin(imageArray)) / 2
        width = np.amax(imageArray) - np.amin(imageArray)
        dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
        dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
        dicom.BitsAllocated = 32
        dicom.Rows = np.shape(imageArray)[0]
        dicom.Columns = np.shape(imageArray)[1]
        dicom.FloatPixelData = bytes(imageArray.flatten())
        del dicom.PixelData, dicom.BitsStored, dicom.HighBit
        return

# Could insert a method regarding ROI colours, like in ITK-SNAP???
def saveAnatomicalInfo(anatomyString, dicom):
    try:
        # FOR NOW, THE PRIORITY WILL BE ON KIDNEY
        if &#34;KIDNEY&#34; or &#34;ABDOMEN&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-71000&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Kidney&#34;
        elif &#34;LIVER&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-62000&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Liver&#34;
        elif &#34;PROSTATE&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-9200B&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Prostate&#34;      
        elif &#34;BODY&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;P5-0905E&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;LN&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;MRI whole body&#34;
    except:
        pass
    return

    # Series, Instance and Class for Reference
    #newDicom.ReferencedSeriesSequence = [Dataset(), Dataset()]
    #newDicom.ReferencedSeriesSequence[0].SeriesInstanceUID = dicom_data.SeriesInstanceUID
    #newDicom.ReferencedSeriesSequence[1].ReferencedInstanceSequence = [Dataset(), Dataset()]
    #newDicom.ReferencedSeriesSequence[1].ReferencedInstanceSequence[0].ReferencedSOPClassUID = dicom_data.SOPClassUID
    #newDicom.ReferencedSeriesSequence[1].ReferencedInstanceSequence[1].ReferencedSOPInstanceUID = dicom_data.SOPInstanceUID

# rwv_sequence = Sequence()
        # dicom.RealWorldValueMappingSequence = rwv_sequence
        # rwv_slope = Dataset()
        # rwv_slope.RealWorldValueSlope = 1
        # rwv_sequence.append(rwv_slope)

        # quantity_def = Dataset()
        # quantity_def_sequence = Sequence()
        # quantity_def.QuantityDefinitionSequence = quantity_def_sequence
        # value_type = Dataset()
        # value_type.ValueType = &#34;CODE&#34;
        # quantity_def_sequence.append(value_type)
        # concept_code = Dataset()
        # concept_code_sequence = Sequence()
        # concept_code.ConceptCodeSequence = concept_code_sequence
        # code_code = Dataset()
        # code_code.CodeValue = &#34;113041&#34;
        # code_code.CodingSchemeDesignator = &#34;DCM&#34;
        # code_code.CodeMeaning = &#34;Apparent Diffusion Coefficient&#34;
        # concept_code_sequence.append(code_code)
        # rwv_sequence.append(quantity_def)

        # measure_units = Dataset()
        # measure_units_sequence = Sequence()
        # measure_units.MeasurementUnitsCodeSequence = measure_units_sequence
        # measure_code = Dataset()
        # measure_code.CodeValue = &#34;um2/s&#34;
        # measure_code.CodingSchemeDesignator = &#34;UCUM&#34;
        # measure_code.CodeMeaning = &#34;um2/s&#34;
        # measure_units_sequence.append(measure_code)
        # rwv_sequence.append(measure_units)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.editDicom"><code class="name flex">
<span>def <span class="ident">editDicom</span></span>(<span>newDicom, imageArray, parametricMap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editDicom(newDicom, imageArray, parametricMap):

    callCase = ParametricClass()
    callCase.selectParametricMap(newDicom, imageArray, parametricMap)

    dt = datetime.datetime.now()
    timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds
    newDicom.PerformedProcedureStepStartDate = dt.strftime(&#39;%Y%m%d&#39;)
    newDicom.PerformedProcedureStepStartTime = timeStr
    newDicom.PerformedProcedureStepDescription = &#34;Post-processing application&#34;

    return newDicom</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.saveAnatomicalInfo"><code class="name flex">
<span>def <span class="ident">saveAnatomicalInfo</span></span>(<span>anatomyString, dicom)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveAnatomicalInfo(anatomyString, dicom):
    try:
        # FOR NOW, THE PRIORITY WILL BE ON KIDNEY
        if &#34;KIDNEY&#34; or &#34;ABDOMEN&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-71000&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Kidney&#34;
        elif &#34;LIVER&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-62000&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Liver&#34;
        elif &#34;PROSTATE&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;T-9200B&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;SRT&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;Prostate&#34;      
        elif &#34;BODY&#34; in anatomyString.upper():
            dicom.AnatomicRegionSequence = [Dataset(), Dataset(), Dataset()]
            dicom.AnatomicRegionSequence[0].CodeValue = &#34;P5-0905E&#34;
            dicom.AnatomicRegionSequence[1].CodingSchemeDesignator = &#34;LN&#34;
            dicom.AnatomicRegionSequence[2].CodeMeaning = &#34;MRI whole body&#34;
    except:
        pass
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass"><code class="flex name class">
<span>class <span class="ident">ParametricClass</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParametricClass(object):
    def selectParametricMap(self, dicom, imageArray, argument):
        methodName = argument
        method = getattr(self, methodName, lambda: &#34;No valid Parametric Map chosen&#34;)
        return method(dicom, imageArray)

    def RGB(self, dicom, imageArray):
        dicom.PhotometricInterpretation = &#39;RGB&#39;
        dicom.SamplesPerPixel = 3
        dicom.BitsAllocated = 8
        dicom.BitsStored = 8
        dicom.HighBit = 7
        dicom.add_new(0x00280006, &#39;US&#39;, 0) # Planar Configuration
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        pixelArray = imageArray.astype(np.uint8) # Should we multiply by 255?
        dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
        dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
        dicom.PixelData = pixelArray.tobytes()
        return

    def ADC(self, dicom, imageArray):
        # The commented parts are to apply when we decide to include Parametric Map IOD. No readers can deal with this yet
        # dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.67&#39;
        dicom.SeriesDescription = &#34;Apparent Diffusion Coefficient (um2/s)&#34;
        dicom.Modality = &#34;RWV&#34;
        dicom.FrameLaterality = &#34;U&#34;
        dicom.DerivedPixelContrast = &#34;ADC&#34;
        dicom.BitsAllocated = 32
        dicom.PixelRepresentation = 1
        dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
        dicom.PixelAspectRatio = [&#34;1&#34;, &#34;1&#34;] # Need to have a better look at this
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        # Rotate the image back to the original orientation
        imageArray = np.transpose(imageArray)
        dicom.Rows = np.shape(imageArray)[-2]
        dicom.Columns = np.shape(imageArray)[-1]
        dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
        dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
        dicom.FloatPixelData = bytes(imageArray.astype(np.float32).flatten())
        del dicom.PixelData, dicom.BitsStored, dicom.HighBit

        dicom.RealWorldValueMappingSequence = [Dataset(), Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence = [Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[0].ValueType = &#34;CODE&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence = [Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[0].CodeValue = &#34;113041&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[1].CodingSchemeDesignator = &#34;DCM&#34;
        dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[2].CodeMeaning = &#34;Apparent Diffusion Coefficient&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence = [Dataset(), Dataset(), Dataset()]
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[0].CodeValue = &#34;um2/s&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[1].CodingSchemeDesignator = &#34;UCUM&#34;
        dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[2].CodeMeaning = &#34;um2/s&#34;
        dicom.RealWorldValueMappingSequence[2].RealWorldValueSlope = 1
        
        anatomyString = dicom.BodyPartExamined
        saveAnatomicalInfo(anatomyString, dicom.RealWorldValueMappingSequence[3])

        return

    def T2Star(self, dicom, imageArray):
        dicom.PixelSpacing = [3, 3] # find a mechanism to pass reconstruct pixel here
        return

    def SEG(self, dicom, imageArray):
        #dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.66.4&#39; # WILL NOT BE USED HERE - This is for PACS. There will be another one for DICOM Standard
        # The commented parts are to apply when we decide to include SEG IOD. No readers can deal with this yet
        dicom.BitsAllocated = 8 # According to Federov DICOM Standard this should be 1-bit
        dicom.BitsStored = 8
        dicom.HighBit = 7
        #dicom.SmallestImagePixelValue = 0
        #dicom.LargestImagePixelValue = int(np.amax(imageArray)) # max 255
        dicom.add_new(&#39;0x00280106&#39;, &#39;US&#39;, 0) # Minimum
        dicom.add_new(&#39;0x00280107&#39;, &#39;US&#39;, int(np.amax(imageArray))) # Maximum
        dicom.PixelRepresentation = 0
        dicom.SamplesPerPixel = 1
        #dicom.WindowCenter = 0.5
        #dicom.WindowWidth = 1.1
        dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, 0.5) # WindowCenter
        dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, 1.1) # WindowWidth
        #dicom.RescaleIntercept = 0
        #dicom.RescaleSlope = 1
        dicom.add_new(&#39;0x00281052&#39;, &#39;DS&#39;, 0) # RescaleIntercept
        dicom.add_new(&#39;0x00281053&#39;, &#39;DS&#39;, 1) # RescaleSlope
        dicom.LossyImageCompression = &#39;00&#39;
        pixelArray = np.transpose(imageArray.astype(np.uint8)) # Should we multiply by 255?
        dicom.PixelData = pixelArray.tobytes()

        dicom.Modality = &#39;SEG&#39;
        dicom.SegmentationType = &#39;FRACTIONAL&#39;
        dicom.MaximumFractionalValue = int(np.amax(imageArray)) # max 255
        dicom.SegmentationFractionalType = &#39;OCCUPANCY&#39;

        # Segment Labels
        if hasattr(dicom, &#34;ImageComments&#34;):
            dicom.ContentDescription = dicom.ImageComments.split(&#39;_&#39;)[-1] # &#39;Image segmentation&#39;
            segment_numbers = np.unique(pixelArray)
            segment_dictionary = dict(list(enumerate(segment_numbers)))
            segment_label = dicom.ImageComments.split(&#39;_&#39;)[-1]
            segment_dictionary[0] = &#39;Background&#39;
            segment_dictionary[1] = segment_label
            for key in segment_dictionary:
                dicom.SegmentSequence = [Dataset(), Dataset(), Dataset(), Dataset(), Dataset(), Dataset()]
                dicom.SegmentSequence[0].SegmentAlgorithmType = &#39;MANUAL&#39;
                dicom.SegmentSequence[1].SegmentNumber = key
                dicom.SegmentSequence[2].SegmentDescription = str(segment_dictionary[key])
                dicom.SegmentSequence[3].SegmentLabel = str(segment_dictionary[key])
                dicom.SegmentSequence[4].SegmentAlgorithmName = &#34;Weasel&#34;
                if hasattr(dicom, &#34;BodyPartExamined&#34;):
                    anatomyString = dicom.BodyPartExamined
                    saveAnatomicalInfo(anatomyString, dicom.SegmentSequence[5])
        else:
            dicom.ContentDescription = &#34;Mask with no label&#34;

        return

    def Registration(self, dicom, imageArray):
        dicom.Modality = &#34;REG&#34;
        return

    def Signal(self, dicom, imageArray):
        dicom.Modality = &#34;RWV&#34;
        dicom.DerivedPixelContrast = &#34;GraphPlot&#34;
        dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
        dicom.RescaleSlope = 1
        dicom.RescaleIntercept = 0
        imageArray = np.transpose(imageArray.astype(np.float32))
        center = (np.amax(imageArray) + np.amin(imageArray)) / 2
        width = np.amax(imageArray) - np.amin(imageArray)
        dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
        dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
        dicom.BitsAllocated = 32
        dicom.Rows = np.shape(imageArray)[0]
        dicom.Columns = np.shape(imageArray)[1]
        dicom.FloatPixelData = bytes(imageArray.flatten())
        del dicom.PixelData, dicom.BitsStored, dicom.HighBit
        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.ADC"><code class="name flex">
<span>def <span class="ident">ADC</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ADC(self, dicom, imageArray):
    # The commented parts are to apply when we decide to include Parametric Map IOD. No readers can deal with this yet
    # dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.67&#39;
    dicom.SeriesDescription = &#34;Apparent Diffusion Coefficient (um2/s)&#34;
    dicom.Modality = &#34;RWV&#34;
    dicom.FrameLaterality = &#34;U&#34;
    dicom.DerivedPixelContrast = &#34;ADC&#34;
    dicom.BitsAllocated = 32
    dicom.PixelRepresentation = 1
    dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
    dicom.PixelAspectRatio = [&#34;1&#34;, &#34;1&#34;] # Need to have a better look at this
    dicom.RescaleSlope = 1
    dicom.RescaleIntercept = 0
    # Rotate the image back to the original orientation
    imageArray = np.transpose(imageArray)
    dicom.Rows = np.shape(imageArray)[-2]
    dicom.Columns = np.shape(imageArray)[-1]
    dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
    dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
    dicom.FloatPixelData = bytes(imageArray.astype(np.float32).flatten())
    del dicom.PixelData, dicom.BitsStored, dicom.HighBit

    dicom.RealWorldValueMappingSequence = [Dataset(), Dataset(), Dataset(), Dataset()]
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence = [Dataset(), Dataset()]
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[0].ValueType = &#34;CODE&#34;
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence = [Dataset(), Dataset(), Dataset()]
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[0].CodeValue = &#34;113041&#34;
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[1].CodingSchemeDesignator = &#34;DCM&#34;
    dicom.RealWorldValueMappingSequence[0].QuantityDefinitionSequence[1].ConceptCodeSequence[2].CodeMeaning = &#34;Apparent Diffusion Coefficient&#34;
    dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence = [Dataset(), Dataset(), Dataset()]
    dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[0].CodeValue = &#34;um2/s&#34;
    dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[1].CodingSchemeDesignator = &#34;UCUM&#34;
    dicom.RealWorldValueMappingSequence[1].MeasurementUnitsCodeSequence[2].CodeMeaning = &#34;um2/s&#34;
    dicom.RealWorldValueMappingSequence[2].RealWorldValueSlope = 1
    
    anatomyString = dicom.BodyPartExamined
    saveAnatomicalInfo(anatomyString, dicom.RealWorldValueMappingSequence[3])

    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.RGB"><code class="name flex">
<span>def <span class="ident">RGB</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RGB(self, dicom, imageArray):
    dicom.PhotometricInterpretation = &#39;RGB&#39;
    dicom.SamplesPerPixel = 3
    dicom.BitsAllocated = 8
    dicom.BitsStored = 8
    dicom.HighBit = 7
    dicom.add_new(0x00280006, &#39;US&#39;, 0) # Planar Configuration
    dicom.RescaleSlope = 1
    dicom.RescaleIntercept = 0
    pixelArray = imageArray.astype(np.uint8) # Should we multiply by 255?
    dicom.WindowCenter = int((np.amax(imageArray) - np.amin(imageArray)) / 2)
    dicom.WindowWidth = np.absolute(int(np.amax(imageArray) - np.amin(imageArray)))
    dicom.PixelData = pixelArray.tobytes()
    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Registration"><code class="name flex">
<span>def <span class="ident">Registration</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Registration(self, dicom, imageArray):
    dicom.Modality = &#34;REG&#34;
    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.SEG"><code class="name flex">
<span>def <span class="ident">SEG</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SEG(self, dicom, imageArray):
    #dicom.SOPClassUID = &#39;1.2.840.10008.5.1.4.1.1.66.4&#39; # WILL NOT BE USED HERE - This is for PACS. There will be another one for DICOM Standard
    # The commented parts are to apply when we decide to include SEG IOD. No readers can deal with this yet
    dicom.BitsAllocated = 8 # According to Federov DICOM Standard this should be 1-bit
    dicom.BitsStored = 8
    dicom.HighBit = 7
    #dicom.SmallestImagePixelValue = 0
    #dicom.LargestImagePixelValue = int(np.amax(imageArray)) # max 255
    dicom.add_new(&#39;0x00280106&#39;, &#39;US&#39;, 0) # Minimum
    dicom.add_new(&#39;0x00280107&#39;, &#39;US&#39;, int(np.amax(imageArray))) # Maximum
    dicom.PixelRepresentation = 0
    dicom.SamplesPerPixel = 1
    #dicom.WindowCenter = 0.5
    #dicom.WindowWidth = 1.1
    dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, 0.5) # WindowCenter
    dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, 1.1) # WindowWidth
    #dicom.RescaleIntercept = 0
    #dicom.RescaleSlope = 1
    dicom.add_new(&#39;0x00281052&#39;, &#39;DS&#39;, 0) # RescaleIntercept
    dicom.add_new(&#39;0x00281053&#39;, &#39;DS&#39;, 1) # RescaleSlope
    dicom.LossyImageCompression = &#39;00&#39;
    pixelArray = np.transpose(imageArray.astype(np.uint8)) # Should we multiply by 255?
    dicom.PixelData = pixelArray.tobytes()

    dicom.Modality = &#39;SEG&#39;
    dicom.SegmentationType = &#39;FRACTIONAL&#39;
    dicom.MaximumFractionalValue = int(np.amax(imageArray)) # max 255
    dicom.SegmentationFractionalType = &#39;OCCUPANCY&#39;

    # Segment Labels
    if hasattr(dicom, &#34;ImageComments&#34;):
        dicom.ContentDescription = dicom.ImageComments.split(&#39;_&#39;)[-1] # &#39;Image segmentation&#39;
        segment_numbers = np.unique(pixelArray)
        segment_dictionary = dict(list(enumerate(segment_numbers)))
        segment_label = dicom.ImageComments.split(&#39;_&#39;)[-1]
        segment_dictionary[0] = &#39;Background&#39;
        segment_dictionary[1] = segment_label
        for key in segment_dictionary:
            dicom.SegmentSequence = [Dataset(), Dataset(), Dataset(), Dataset(), Dataset(), Dataset()]
            dicom.SegmentSequence[0].SegmentAlgorithmType = &#39;MANUAL&#39;
            dicom.SegmentSequence[1].SegmentNumber = key
            dicom.SegmentSequence[2].SegmentDescription = str(segment_dictionary[key])
            dicom.SegmentSequence[3].SegmentLabel = str(segment_dictionary[key])
            dicom.SegmentSequence[4].SegmentAlgorithmName = &#34;Weasel&#34;
            if hasattr(dicom, &#34;BodyPartExamined&#34;):
                anatomyString = dicom.BodyPartExamined
                saveAnatomicalInfo(anatomyString, dicom.SegmentSequence[5])
    else:
        dicom.ContentDescription = &#34;Mask with no label&#34;

    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Signal"><code class="name flex">
<span>def <span class="ident">Signal</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Signal(self, dicom, imageArray):
    dicom.Modality = &#34;RWV&#34;
    dicom.DerivedPixelContrast = &#34;GraphPlot&#34;
    dicom.PhotometricInterpretation = &#34;MONOCHROME2&#34;
    dicom.RescaleSlope = 1
    dicom.RescaleIntercept = 0
    imageArray = np.transpose(imageArray.astype(np.float32))
    center = (np.amax(imageArray) + np.amin(imageArray)) / 2
    width = np.amax(imageArray) - np.amin(imageArray)
    dicom.add_new(&#39;0x00281050&#39;, &#39;DS&#39;, center)
    dicom.add_new(&#39;0x00281051&#39;, &#39;DS&#39;, width)
    dicom.BitsAllocated = 32
    dicom.Rows = np.shape(imageArray)[0]
    dicom.Columns = np.shape(imageArray)[1]
    dicom.FloatPixelData = bytes(imageArray.flatten())
    del dicom.PixelData, dicom.BitsStored, dicom.HighBit
    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.T2Star"><code class="name flex">
<span>def <span class="ident">T2Star</span></span>(<span>self, dicom, imageArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def T2Star(self, dicom, imageArray):
    dicom.PixelSpacing = [3, 3] # find a mechanism to pass reconstruct pixel here
    return</code></pre>
</details>
</dd>
<dt id="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.selectParametricMap"><code class="name flex">
<span>def <span class="ident">selectParametricMap</span></span>(<span>self, dicom, imageArray, argument)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectParametricMap(self, dicom, imageArray, argument):
    methodName = argument
    method = getattr(self, methodName, lambda: &#34;No valid Parametric Map chosen&#34;)
    return method(dicom, imageArray)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="WEASEL.DICOM" href="index.html">WEASEL.DICOM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.editDicom" href="#WEASEL.DICOM.ParametricMapsDictionary.editDicom">editDicom</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.saveAnatomicalInfo" href="#WEASEL.DICOM.ParametricMapsDictionary.saveAnatomicalInfo">saveAnatomicalInfo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass">ParametricClass</a></code></h4>
<ul class="two-column">
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.ADC" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.ADC">ADC</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.RGB" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.RGB">RGB</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Registration" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Registration">Registration</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.SEG" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.SEG">SEG</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Signal" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.Signal">Signal</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.T2Star" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.T2Star">T2Star</a></code></li>
<li><code><a title="WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.selectParametricMap" href="#WEASEL.DICOM.ParametricMapsDictionary.ParametricClass.selectParametricMap">selectParametricMap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>