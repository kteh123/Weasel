<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>WEASEL.Displays.ImageViewers.ImageViewer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>WEASEL.Displays.ImageViewers.ImageViewer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PyQt5 import QtCore 
from PyQt5.QtCore import  Qt
from PyQt5.QtGui import QPixmap, QIcon,  QCursor
from PyQt5.QtWidgets import (QFileDialog, QApplication,                           
                            QMessageBox, 
                            QWidget,
                            QHBoxLayout,
                            QVBoxLayout, 
                            QMdiSubWindow, 
                            QGroupBox, 
                            QDoubleSpinBox,
                            QPushButton,  
                            QLabel, 
                            QComboBox,
                            QSlider, 
                            QComboBox,
                            QListWidget,
                            QListWidgetItem,
                            QListView)

import os
import matplotlib.pyplot as plt
from matplotlib import cm
import numpy as np
import math
import copy
from scipy.stats import iqr
import External.pyqtgraph as pg 
import DICOM.ReadDICOM_Image as ReadDICOM_Image
import DICOM.SaveDICOM_Image as SaveDICOM_Image


from Displays.ImageViewers.DataStructures.UserImageColourSelection import UserSelection
from Displays.ImageViewers.ComponentsUI.ImageSliders import ImageSliders as imageSliders
from Displays.ImageViewers.ComponentsUI.PixelValueLabel import PixelValueComponent 
from Displays.ImageViewers.ComponentsUI.ImageLevelsSpinBoxes import ImageLevelsSpinBoxes as imageLevelsSpinBoxes
from Displays.ImageViewers.ComponentsUI.FreeHandROI.Resources import * 

import time
import logging
logger = logging.getLogger(__name__)

__author__ = &#34;Steve Shillitoe&#34;
#September 2021

#List of colour tables supported by matplotlib
listColours = [&#39;gray&#39;, &#39;cividis&#39;,  &#39;magma&#39;, &#39;plasma&#39;, &#39;viridis&#39;, 
            &#39;Greys&#39;, &#39;Purples&#39;, &#39;Blues&#39;, &#39;Greens&#39;, &#39;Oranges&#39;, &#39;Reds&#39;,
            &#39;YlOrBr&#39;, &#39;YlOrRd&#39;, &#39;OrRd&#39;, &#39;PuRd&#39;, &#39;RdPu&#39;, &#39;BuPu&#39;,
            &#39;GnBu&#39;, &#39;PuBu&#39;, &#39;YlGnBu&#39;, &#39;PuBuGn&#39;, &#39;BuGn&#39;, &#39;YlGn&#39;,
            &#39;binary&#39;, &#39;gist_yarg&#39;, &#39;gist_gray&#39;, &#39;bone&#39;, &#39;pink&#39;,
            &#39;spring&#39;, &#39;summer&#39;, &#39;autumn&#39;, &#39;winter&#39;, &#39;cool&#39;, &#39;Wistia&#39;,
            &#39;hot&#39;, &#39;afmhot&#39;, &#39;gist_heat&#39;, &#39;copper&#39;,
            &#39;PiYG&#39;, &#39;PRGn&#39;, &#39;BrBG&#39;, &#39;PuOr&#39;, &#39;RdGy&#39;, &#39;RdBu&#39;,
            &#39;RdYlBu&#39;, &#39;RdYlGn&#39;, &#39;Spectral&#39;, &#39;coolwarm&#39;, &#39;bwr&#39;, &#39;seismic&#39;,
            &#39;twilight&#39;, &#39;twilight_shifted&#39;, &#39;hsv&#39;,
            &#39;flag&#39;, &#39;prism&#39;, &#39;ocean&#39;, &#39;gist_earth&#39;, &#39;terrain&#39;, &#39;gist_stern&#39;,
            &#39;gnuplot&#39;, &#39;gnuplot2&#39;, &#39;CMRmap&#39;, &#39;cubehelix&#39;, &#39;brg&#39;, &#39;turbo&#39;,
            &#39;gist_rainbow&#39;, &#39;rainbow&#39;, &#39;jet&#39;, &#39;nipy_spectral&#39;, &#39;gist_ncar&#39;, &#39;custom&#39;]


class ImageViewer(QMdiSubWindow):
    &#34;&#34;&#34;This class creates a subwindow for viewing an image or series of images with
    the facility to change the colour table applied to the image.  It also has multiple
    sliders for browsing series of images.&#34;&#34;&#34;

    def __init__(self, weasel, dcm): 
        try:
            super().__init__()

            self.subjectID = dcm.subjectID
            self.studyID = dcm.studyID
            self.seriesID = dcm.seriesID
            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.imagePathList = dcm.path
            elif dcm.__class__.__name__ == &#34;Series&#34;:
                self.imagePathList = dcm.images

            self.selectedImagePath = &#34;&#34;
            self.imageNumber = -1
            self.colourTable = &#34;&#34;
            self.cmbColours = QComboBox()  
            self.lut = &#34;&#34;
            self.weasel = weasel

            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.isSeries = False
                self.isImage = True
                self.selectedImagePath = dcm.path
            else:
                self.isSeries = True
                self.isImage = False

            self.setWindowFlags(Qt.CustomizeWindowHint | 
                                          Qt.WindowCloseButtonHint | 
                                          Qt.WindowMinimizeButtonHint |
                                          Qt.WindowMaximizeButtonHint)
        
            height, width = self.weasel.getMDIAreaDimensions()
            self.subWindowWidth = width
            #Set dimensions of the subwindow to fit the MDI area
            self.setGeometry(0, 0, width, height)
            #Add subwindow to MDI
            self.weasel.mdiArea.addSubWindow(self)
             
            if self.isSeries: #DICOM series selected.
                #Create data structure for storing user selected
                #colour table and levels data
                self.userSelection = UserSelection(self.imagePathList)
                
            self.setUpMainLayout()

            self.setUpTopRowLayout()

            self.setUpGraphicsView()

            self.setUpLevelsSpinBoxes()
    
            self.setUpHistogram() #At the right-hand side of the image, adjusts levels
        
            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.displayPixelArrayOfSingleImage(self.imagePathList) 
            else:
                #DICOM series selected
                self.setUpImageSliders()

            self.show()
        except Exception as e:
            print(&#39;Error in ImageViewer.__init__: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.__init__: &#39; + str(e))


    def setUpMainLayout(self):
        try:
            self.mainVerticalLayout = QVBoxLayout()
            self.widget = QWidget()
            self.widget.setLayout(self.mainVerticalLayout)
            self.setWidget(self.widget)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))


    def setUpImageSliders(self):
        try:
            logger.info(&#34;ImageViewer.setpUpImageSliders called.&#34;)
            start = time.perf_counter()
            #create an instance of the ImageSliders class
            self.slidersWidget = imageSliders(self.weasel, 
                                             self.subjectID, 
                                             self.studyID, 
                                             self.seriesID, 
                                             self.imagePathList)

            self.mainVerticalLayout.addLayout(
                    self.slidersWidget.getCustomSliderWidget())

            self.mainImageSlider = self.slidersWidget.getMainSlider()

            #This is how an object created from the ImageSliders class communicates
            #with an object created from the ImageViewer class via the former&#39;s
            #sliderMoved event, which passes the image path of the image being viewed
            #to ImageViewer&#39;s displayPixelArrayOfSingleImage function for display.
            self.slidersWidget.sliderMoved.connect(lambda imagePath: 
                                                   self.displayPixelArrayOfSingleImage(imagePath))
            #Display the first image in the viewer
            #self.displayPixelArrayOfSingleImage(self.imagePathList[0])
            self.slidersWidget.displayFirstImage()
            #print(&#34;ImageViewer.setUpImageSliders time = {} seconds&#34;.format(time.perf_counter()-start))
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))


    def setUpColourTableDropDown(self):                                                  
        self.cmbColours.blockSignals(True)
        self.cmbColours.addItems(listColours)
        self.cmbColours.setCurrentIndex(0)
        self.cmbColours.blockSignals(False)
        self.cmbColours.setToolTip(&#39;Select a colour table to apply to the image&#39;)
        if self.isImage:
            self.cmbColours.currentIndexChanged.connect(self.applyColourTableToAnImage)
        elif self.isSeries:
            self.cmbColours.currentIndexChanged.connect(self.applyColourTableToSeries)

        self.colourTableLayout.addWidget(self.cmbColours)


    def setUpApplyUserSelectionButton(self):
        self.btnApply = QPushButton() 
        self.btnApply.setCheckable(True)
        self.btnApply.setIcon(QIcon(QPixmap(APPLY_SERIES_ICON)))
        self.btnApply.setToolTip(
                    &#34;Click to apply colour table and levels selected by the user to the whole series&#34;)
        self.btnApply.clicked.connect(self.applyColourTableToSeries)


    def setUpUpdateUserSelectionToDICOMButton(self):
        self.btnUpdate = QPushButton() 
        self.btnUpdate.setIcon(QIcon(QPixmap(SAVE_ICON)))
        self.btnUpdate.setToolTip(&#39;Update DICOM with the new colour table, contrast &amp; intensity levels&#39;)
        if self.isImage:
            self.btnUpdate.clicked.connect(self.updateSingleDicomImage)
        elif self.isSeries:
            self.btnUpdate.clicked.connect(self.updateDicomSeries)


    def setUpExportImageButton(self):
        self.btnExport = QPushButton() 
        self.btnExport.setIcon(QIcon(QPixmap(EXPORT_ICON)))
        self.btnExport.setToolTip(&#39;Exports the image to an external graphic file.&#39;)
        self.btnExport.clicked.connect(self.exportImage)


    def setUpResetButton(self):
        self.btnReset = QPushButton() 
        self.btnReset.setIcon(QIcon(QPixmap(RESET_ICON)))
        self.btnReset.setToolTip(&#39;Return to colour tables and levels in the DICOM file&#39;)


    def setUpColourTableGroupBox(self):
        self.colourTableLayout = QHBoxLayout()
        self.colourTableLayout.setContentsMargins(0, 2, 0, 0)
        self.colourTableLayout.setSpacing(5)
        self.colourTableGroupBox = QGroupBox()
        #self.colourTableGroupBox.setFixedWidth(300)
        self.colourTableGroupBox.setFixedHeight(50)
        self.colourTableGroupBox.setLayout(self.colourTableLayout)

        self.setUpColourTableDropDown()

        self.setUpApplyUserSelectionButton()

        self.setUpUpdateUserSelectionToDICOMButton()  #To Do
  
        self.setUpExportImageButton()

        self.setUpResetButton()

        self.setUpDeleteImageButton()

        if self.isImage: 
            self.colourTableLayout.addWidget(self.btnReset)
            self.colourTableLayout.addWidget(self.btnUpdate)
            self.colourTableLayout.addWidget(self.btnExport)
            self.colourTableLayout.addWidget(self.deleteButton)
            self.btnReset.clicked.connect(lambda: self.displayPixelArrayOfSingleImage(self.imagePathList))                                                     
        elif self.isSeries:
            #Viewing a DICOM series, so show the Reset button
            #and Apply to Series checkbox
            self.colourTableLayout.addWidget(self.btnApply)  
            #Clicking Reset button deletes user selected colour table and contrast 
            #and intensity levelts and returns images to values in the original DICOM file.
            self.btnReset.clicked.connect(self.clearUserSelection)
            self.colourTableLayout.addWidget(self.btnReset)
            self.colourTableLayout.addWidget(self.btnUpdate)
            self.colourTableLayout.addWidget(self.btnExport)
            self.colourTableLayout.addWidget(self.deleteButton)
            self.cmbColours.activated.connect(self.updateImageUserSelection)


    def setUpImageLevelsGroupBox(self):
        self.levelsCompositeComponentLayout = imageLevelsSpinBoxes()
        self.imageLevelsGroupBox = QGroupBox()
        self.imageLevelsGroupBox.setFixedWidth(200)
        self.imageLevelsGroupBox.setFixedHeight(50)
        self.imageLevelsGroupBox.setLayout(
            self.levelsCompositeComponentLayout.getCompositeComponent())


    def setUpTopRowLayout(self):
        try:
            self.topRowMainLayout = QHBoxLayout()

            self.setUpColourTableGroupBox()
            self.setUpImageLevelsGroupBox()
            self.setUpPixelValueGroupBox()

            self.topRowMainLayout.addWidget(self.colourTableGroupBox)
            self.topRowMainLayout.addWidget(self.imageLevelsGroupBox) 
            self.topRowMainLayout.addWidget(self.pixelValueGroupBox)

            self.mainVerticalLayout.addLayout(self.topRowMainLayout)

            self.lblImageMissing = QLabel(&#34;&lt;h4&gt;Image Missing&lt;/h4&gt;&#34;)
            self.lblImageMissing.hide()
            self.mainVerticalLayout.addWidget(self.lblImageMissing)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))


    def setUpGraphicsView(self):
        try:
            self.graphicsView = pg.ImageView(view=pg.PlotItem()) #view=pg.PlotItem() adds axes to image
            self.mainVerticalLayout.addWidget(self.graphicsView, stretch=1)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))


    def setUpDeleteImageButton(self):
        try:
            self.deleteButton = QPushButton()
            self.deleteButton.setToolTip(
                &#39;Deletes the DICOM image being viewed&#39;)
            self.deleteButton.setIcon(QIcon(QPixmap(DELETE_ICON)))
            self.deleteButton.clicked.connect(self.deleteImageInMultiImageViewer)
            #self.imageLayout.addWidget(self.deleteButton)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))
 

    def setUpPixelValueGroupBox(self):
        pixelValueComponent = PixelValueComponent()
        self.lblPixelValue = pixelValueComponent.getLabel()
        self.pixelValueGroupBox = QGroupBox(&#34;Pixel Value&#34;)
        self.pixelValueGroupBox.setFixedHeight(50)
        self.pixelValueGroupBox.setLayout(pixelValueComponent.getLayout())  

  
    def getPixelValue(self, pos, imageNumber=1):
        &#34;&#34;&#34;
        This function checks that the mouse pointer is over the
        image and when it is, it determines the value of the pixel
        under the mouse pointer and displays this in the label
        lblPixelValue.
        &#34;&#34;&#34;
        try:
            container =  self.graphicsView.getView()
            if container.sceneBoundingRect().contains(pos): 
                mousePoint = container.getViewBox().mapSceneToView(pos) 
                x_i = math.floor(mousePoint.x())
                y_i = math.floor(mousePoint.y()) 
                #correct the y coordinate value so that it has a value
                #of 0 at the bottom left corner of the image rather than
                #at the top left corner of the image
                _, nY = self.pixelArray.shape
                correctedYCoord = nY -  y_i
                z_i =  imageNumber
                if ((len(np.shape(self.pixelArray)) == 2) 
                    and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 1 ] 
                    and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 0 ]): 
                        self.lblPixelValue.setText(
                        &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
                elif ((len(np.shape(self.pixelArray)) == 3) 
                        and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 1 ] 
                        and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 2 ]):
                            z_i = math.floor(self.graphicsView.timeIndex(self.graphicsView.timeLine)[1])
                            self.lblPixelValue.setText(
                                &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
                else:
                    self.lblPixelValue.setText(&#34;&#34;)
            else:
                self.lblPixelValue.setText(&#34;&#34;)
                   
        except Exception as e:
            print(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))


    def setUpLevelsSpinBoxes(self):
        try:
            self.spinBoxIntensity, self.spinBoxContrast = self.levelsCompositeComponentLayout.getSpinBoxes()
            self.spinBoxIntensity.valueChanged.connect(self.updateImageLevels)
            self.spinBoxContrast.valueChanged.connect(self.updateImageLevels)
            if self.isSeries: 
                self.spinBoxIntensity.valueChanged.connect(self.updateImageUserSelection)
                self.spinBoxContrast.valueChanged.connect(self.updateImageUserSelection)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))


    def setUpHistogram(self):
        self.histogramObject = self.graphicsView.getHistogramWidget().getHistogram()
        self.histogramObject.sigLevelsChanged.connect(self.getHistogramLevels)
        self.graphicsView.ui.roiBtn.hide()
        self.graphicsView.ui.menuBtn.hide()

    
    def deleteImageInMultiImageViewer(self):
        &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
        this function deletes the physical image, removes the 
        reference to it in the XML file and removes it from the image viewer.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
            imageName = os.path.basename(self.selectedImagePath)
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

            if buttonReply == QMessageBox.Ok:
                #Advance the image sliders by one image unless we are
                #deleting the last image, then move the slider to the
                #first image in the list.
                

                #Delete physical file
                if os.path.exists(self.selectedImagePath):
                    os.remove(self.selectedImagePath)

                #Remove deleted image from the list
                self.imagePathList.remove(self.selectedImagePath)

                #Pass the new imagePathList to the sliders widget and
                #display the next image
                self.slidersWidget.imageDeleted(self.imagePathList)

                #Remove deleted image from the user selection 
                #data structure
                self.userSelection.deleteOneImageInUserSelection(os.path.basename(self.selectedImagePath))

                #Update the XML file
                #Get the series containing this image and count the images it contains
                #If it is the last image in a series then remove the
                #whole series from XML file
                #If it is not the last image in a series
                #just remove the image from the XML file 
                if len(self.imagePathList) == 0:
                    #no images left in the series, so remove it from the xml file
                    self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                               self.studyID, 
                                                                               self.seriesID)
                elif len(self.imagePathList) &gt; 0:
                    #1 or more images in the series, 
                    #so just remove the image from its series in the xml file
                    self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                        self.studyID, self.seriesID, self.selectedImagePath)

                #Update tree view with xml file modified above
                treeView.refreshDICOMStudiesTreeView(self.weasel)

        except Exception as e:
            print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))


    def deleteImageInMultiImageViewer_old(self):
        &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
        this function deletes the physical image, removes the 
        reference to it in the XML file and removes it from the image viewer.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
            lastSliderPosition = self.mainImageSlider.value()
            #currentImagePath = self.imagePathList[self.mainImageSlider.value()-1]
            imageName = os.path.basename(self.selectedImagePath)
            #print (&#39;study id {} series id {}&#39;.format(studyName, seriesName))
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

            if buttonReply == QMessageBox.Ok:
                #Delete physical file
                if os.path.exists(self.selectedImagePath):
                    os.remove(self.selectedImagePath)
                #Remove deleted image from the list
                self.imagePathList.remove(self.selectedImagePath)

                if len(self.imagePathList) == 0:
                    #Only redisplay the multi-image viewer if there
                    #are still images in the series to display
                    #The image list is empty, so do not redisplay
                    #multi image viewer 
                    pass   
                elif len(self.imagePathList) == 1:
                    #There is only one image left in the display
                    self.mainImageSlider.setValue(1)
                    #displayMultiImageSubWindow(self, imageList, subjectID, studyName, seriesName)
                elif len(self.imagePathList) + 1 == lastSliderPosition:    
                        #we are deleting the last image in the series of images
                        #so move the slider back to the penultimate image in list 
                    self.mainImageSlider.setValue(len(self.imagePathList))
                    #displayMultiImageSubWindow(self, imageList, subjectID,
                                        #studyName, seriesName, len(imageList))
                else:
                    #We are deleting an image at the start of the list
                    #or in the body of the list. Move slider forwards to 
                    #the next image in the list.
                    self.mainImageSlider.setValue(lastSliderPosition)
                    #displayMultiImageSubWindow(self, imageList, subjectID,
                    #                    studyName, seriesName, lastSliderPosition)
     
                #Now update XML file
                #Get the series containing this image and count the images it contains
                #If it is the last image in a series then remove the
                #whole series from XML file
                #If it is not the last image in a series
                #just remove the image from the XML file 
                if len(self.imagePathList) == 0:
                    #no images left in the series, so remove it from the xml file
                    self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                               self.studyID, 
                                                                               self.seriesID)
                elif len(self.imagePathList) &gt; 0:
                    #1 or more images in the series, 
                    #so just remove the image from its series in the xml file
                    self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                        self.studyID, self.seriesID, self.selectedImagePath)
                #Update tree view with xml file modified above
                treeView.refreshDICOMStudiesTreeView(self.weasel)
        except Exception as e:
            print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))


    def exportImage(self):
        &#34;&#34;&#34;Function executed when the Export button is clicked.  
        It exports the DICOM image and its colour table to a png graphics file.
        It launches a file dialog, so that the user can select the file path to 
        the png file in which the exported file will be stored. It also collects 
        the name of the image colour table and the image levels.
        &#34;&#34;&#34;
        try:
            self.colourTable = self.cmbColours.currentText()
            #Default file name is derived from the DICOM image name
            defaultImageName = os.path.basename(self.selectedImagePath) 
            #remove .dcm extension
            defaultImageName = os.path.splitext(defaultImageName)[0] + &#39;.png&#39;
            #Display a save file dialog to get the full file path and name of
            #where to export the DICOM image &amp; its colour table to a png file
            fileName, _ = QFileDialog.getSaveFileName(caption=&#34;Enter a file name&#34;, 
                                                        directory=defaultImageName, 
                                                        filter=&#34;*.png&#34;)

            #Test if the user has selected a file name
            if fileName:
                self.exportImageViaMatplotlib(fileName)
        except Exception as e:
            print(&#39;Error in ImageViewer.exportImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.exportImage: &#39; + str(e))


    def exportImageViaMatplotlib(self, fileName):
        &#34;&#34;&#34;This function uses matplotlib.pyplot to save the DICOM image being viewed 
        and its colour table in a png file with the path+filename in fileName. 
    
        Input Parmeters
        ***************
            fileName - file path to the png file in which the exported file will be stored.
        &#34;&#34;&#34; 
        try:
            #axisOrder = pg.getConfigOption(&#39;imageAxisOrder&#39;) 
            #if axisOrder ==&#39;row-major&#39;:
            #Transpose the array so as to match the screen image 
            # (a transpose is already applied when reading DICOM image)
            pixelArray = np.transpose(self.pixelArray)
            cmap = plt.get_cmap(self.colourTable)
            pos = plt.imshow(pixelArray, cmap=cmap)
            minValue, maxValue = self.graphicsView.getLevels()
            plt.clim(int(minValue), int(maxValue))
            cBar = plt.colorbar()
            cBar.minorticks_on()
            plt.savefig(fname=fileName)
            plt.close()
            QMessageBox.information(self, &#34;Export Image&#34;, &#34;Image Saved&#34;)
        except Exception as e:
            print(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))

    
    def updateImageLevels(self):
        &#34;&#34;&#34;When the contrast and intensity values are adjusted using the spinboxes, 
        this function sets the corresponding values in the image being viewed. 
        &#34;&#34;&#34;
        try:
            centre = self.spinBoxIntensity.value()
            width = self.spinBoxContrast.value()
            halfWidth = width/2
            minimumValue = centre - halfWidth
            maximumValue = centre + halfWidth
            self.graphicsView.setLevels(minimumValue, maximumValue)
            self.graphicsView.show()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))


    def getHistogramLevels(self):
        &#34;&#34;&#34;
        This function ensures that the intensity and contrast spinboxes
        show the correct values when the histogram on the right of the
        image is manually adjusted.
        
        The max and min levels of the image are retrieved from the 
        graphicsView object in pyqtGraph and used to calculate
        the intensity (centre) and contrast (width) values of the image.
        Then the contrast &amp; intensity spinboxes are set to these values.
        &#34;&#34;&#34;
        minLevel, maxLevel =  self.graphicsView.getLevels()
        width = maxLevel - minLevel
        centre = minLevel + (width/2)
        self.spinBoxIntensity.setValue(centre)
        self.spinBoxContrast.setValue(width)


    def getColourTableForThisImage(self):
        try:
            logger.info(&#34;ImageViewer.getColourTableForThisImage called&#34;)
            if self.isSeries:
                if self.userSelection.getSeriesUpdateStatus():
                    self.colourTable = self.cmbColours.currentText()
                elif self.userSelection.getImageUpdateStatus():
                    imageName = os.path.basename(self.selectedImagePath)
                    self.colourTable, _, _ = self.userSelection.returnUserSelection(imageName)  
                    if self.colourTable == &#39;default&#39;:
                        self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
                else:  #no user selection, so get colour table saved to DICOM
                    self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
            elif self.isImage: 
                self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
        except Exception as e:
                print(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))
                logger.error(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))


    def getAndSetLevels(self):
        try:
            success = False
            if self.isSeries: 
                success, minimumValue, maximumValue = self.returnUserSelectedLevels()
            if not success or self.isImage:
                centre, width, maximumValue, minimumValue = self.readLevelsFromDICOMImage()

            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
            self.spinBoxIntensity.setValue(centre)
            self.spinBoxContrast.setValue(width)
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
            return maximumValue, minimumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))  


    def getAndSetLevelsSpinBoxStepSize(self, maximumValue, minimumValue):
        try:
            if (minimumValue &lt; 1 and minimumValue &gt; -1) and (maximumValue &lt; 1 and maximumValue &gt; -1):
                spinBoxStep = float((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
            else:
                spinBoxStep = int((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
        
            self.spinBoxIntensity.setSingleStep(spinBoxStep)
            self.spinBoxContrast.setSingleStep(spinBoxStep)
        except Exception as e:
            print(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))

    
    def displayPixelArrayOfSingleImage(self, imagePath):
        &#34;&#34;&#34;Displays an image&#39;s pixel array in a pyqtGraph imageView widget 
        &amp; sets its colour table, contrast and intensity levels. 
        Also, sets the contrast and intensity in the associated histogram.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.displayPixelArrayOfSingleImage called&#34;)
            start = time.perf_counter()
            self.selectedImagePath = imagePath
            imageName = os.path.basename(self.selectedImagePath)
            self.pixelArray = ReadDICOM_Image.returnPixelArray(self.selectedImagePath)

            imageNumber = 1
                
            self.lut = None

            #Get colour table of the image to be displayed
            self.getColourTableForThisImage()

            #display above colour table in colour table dropdown list
            self.displayColourTableInComboBox()

            self.setWindowTitle(self.subjectID + &#39; - &#39; + self.studyID + &#39; - &#39;+ self.seriesID + &#39; - &#39; 
                        + imageName)

            #Check that pixel array holds an image &amp; display it
            if self.pixelArray is None:
                #the image is missing, so show a black screen
                self.lblImageMissing.show()
                self.deleteButton.hide()
                self.graphicsView.setImage(np.array([[0,0,0],[0,0,0]]))  
            else:
                self.lblImageMissing.hide() 
                maximumValue, minimumValue = self.getAndSetLevels()
                
                if len(np.shape(self.pixelArray)) &lt; 3:
                        self.graphicsView.setImage(self.pixelArray, 
                                                autoHistogramRange=True, 
                                                levels=(minimumValue, maximumValue))
                else:
                        self.graphicsView.setImage(self.pixelArray, 
                                                autoHistogramRange=True, 
                                                xvals=np.arange(np.shape(self.pixelArray)[0] + 1), 
                                                levels=(minimumValue, maximumValue))
                
                self.getAndSetLevelsSpinBoxStepSize(maximumValue, minimumValue)
        
                #Add Colour Table or look up table To Image
                self.setPgColourMap()  
  
                self.graphicsView.getView().scene().sigMouseMoved.connect(
                        lambda pos: self.getPixelValue(pos))
                self.graphicsView.getView().scene().sigMouseDragged.connect(
                        lambda ev: self.adjustLevelsByRightButtonDrag(ev))
        except Exception as e:
            print(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))


    def adjustLevelsByRightButtonDrag(self, ev):
        try:
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
            centre = self.spinBoxIntensity.value()
            width = self.spinBoxContrast.value()
            delta = ev.screenPos() - ev.lastScreenPos()
            if float(centre / np.shape(self.pixelArray)[1]) &gt; 0.01:
                step_y = float(centre / np.shape(self.pixelArray)[1])
            else:
                step_y = 0.01
            if float(width / np.shape(self.pixelArray)[0]) &gt; 0.01:
                step_x = float(width/ np.shape(self.pixelArray)[0])
            else:
                step_x = 0.01
            horizontalDiff = step_y * delta.y()
            verticalDiff = step_x * delta.x() # Maybe put a minus sign here
            newCentre = centre + horizontalDiff
            newWidth = width + verticalDiff
            self.spinBoxIntensity.setValue(newCentre)
            self.spinBoxContrast.setValue(newWidth)
            self.updateImageLevels()
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
        except Exception as e:
            print(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))


    def updateImageUserSelection(self):
        &#34;&#34;&#34;
            &#34;&#34;&#34;
        try:
            logger.info(&#39;updateImageUserSelection called&#39;)
            if not self.btnApply.isChecked():
                #The apply user selection to whole series checkbox 
                #is not checked
                self.colourTable = self.cmbColours.currentText()
                intensity = self.spinBoxIntensity.value()
                contrast = self.spinBoxContrast.value()

                if self.selectedImagePath:
                    self.selectedImageName = os.path.basename(self.selectedImagePath)
                else:
                    #Workaround for the fact that when the first image is displayed,
                    #somehow self.selectedImageName looses its value.
                    self.selectedImageName = os.path.basename(self.imagePathList[0])
            
                #print(&#34;self.selectedImageName ={}&#34;.format(self.selectedImageName))
                #print(&#34;colourTable = {}&#34;.format(self.colourTable))
                self.userSelection.updateUserSelection(self.selectedImageName, self.colourTable, intensity, contrast)
        except Exception as e:
            print(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))


    def applyColourTableToAnImage(self):
        self.colourTable = self.cmbColours.currentText()
        if self.colourTable.lower() == &#39;custom&#39;:
            self.colourTable = &#39;gray&#39;                
            self.displayColourTableInComboBox()   
        self.setPgColourMap()


    def applyColourTableToSeries(self): 
        &#34;&#34;&#34;This function applies a user selected colour map to the current image.
        If the Apply checkbox is checked then the new colour map is also applied to 
        the whole series of DICOM images by setting a boolean flag to True.
        &#34;&#34;&#34;
        try:
            self.applyColourTableToAnImage()
        
            if self.btnApply.isChecked():
                self.btnApply.setStyleSheet(&#34;background-color: red&#34;)
                self.userSelection.setSeriesUpdateStatus(True)
                self.userSelection.setImageUpdateStatus(False)
            else:
                self.userSelection.setSeriesUpdateStatus(False)
                self.btnApply.setStyleSheet(
                &#34;background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)&#34;
                )     
        except Exception as e:
            print(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))


    def clearUserSelection(self):
        &#34;&#34;&#34;This function removes the user selected colour tables, contrast &amp; intensity values from
        the list of image lists that hold these values.  They are reset to the default values of
        &#39;default&#39; for the colour table and -1 for the contrast &amp; intensity values
        &#34;&#34;&#34;
        self.userSelection.clearUserSelection()

        #reload current image to display it without user selected 
        #colour table and levels.
        #This is done by advancing the slider and then moving it  
        #back to the original image
        imageNumber = self.slidersWidget.getMainSlider().value() #self.mainImageSlider.value()
        if imageNumber == 1:
            tempNumber = imageNumber + 1
        else:
            tempNumber = imageNumber - 1

        self.slidersWidget.getMainSlider().setValue(tempNumber)
        self.slidersWidget.getMainSlider().setValue(imageNumber)
    

    def returnUserSelectedLevels(self):
        &#34;&#34;&#34;
        When the user has selected new image levels that must override the 
        levels saved in the DICOM series/image, this function returns those selected levels
        Output parameters
        *****************
        success - boolean, set to true if level values are successfully retrieved
        maximumValue - Maximum pixel value in the image
        minimumValue - Minimum pixel value in the image
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.returnUserSelectedLevels called&#34;)
      
            minimumValue = -1
            maximumValue = -1
            success = False
            
            if self.userSelection.getSeriesUpdateStatus():
                #Get the ordinal number of the image being viewed in the image list
                currentImageNumber = self.slidersWidget.getMainSlider().value() - 1
                centre = self.spinBoxIntensity.value()
                width = self.spinBoxContrast.value()
                #apply contrast and intensity values
                #selected in the GUI spinboxes
                #for the whole series to this image
                minimumValue = centre - (width/2)
                maximumValue = centre + (width/2)
                success = True
            elif self.userSelection.getImageUpdateStatus():
                #the user has opted to change the levels of individual images
                #in a series.
                #if user selected levels exist for this image, retrieve them
                imageName = os.path.basename(self.selectedImagePath)
                _, centre, width = self.userSelection.returnUserSelection(imageName) 
                if centre != -1:
                    #saved values exist, so use them
                    minimumValue = centre - (width/2)
                    maximumValue = centre + (width/2)
                    success = True

            return success, minimumValue, maximumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))

    def setPgColourMap(self):
        &#34;&#34;&#34;This function converts a matplotlib colour map into
        a colour map that can be used by the pyqtGraph imageView widget.
        &#34;&#34;&#34;
        try:
            if self.colourTable == None or self.colourTable == &#34;&#34;:
                self.colourTable = &#39;gray&#39;

            if self.cmbColours is not None:
                self.displayColourTableInComboBox()   
        
            if self.colourTable == &#39;custom&#39;:
                colors = self.lut
            elif self.colourTable == &#39;gray&#39;:
                colors = [[0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]]
            else:
                cmMap = cm.get_cmap(self.colourTable)
                colourClassName = cmMap.__class__.__name__
                if colourClassName == &#39;ListedColormap&#39;:
                    colors = cmMap.colors
                elif colourClassName == &#39;LinearSegmentedColormap&#39;:
                    colors = cmMap(np.linspace(0, 1))
          
            positions = np.linspace(0, 1, len(colors))
            pgMap = pg.ColorMap(positions, colors)
            self.graphicsView.setColorMap(pgMap)        
        except Exception as e:
            print(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))


    def readLevelsFromDICOMImage(self): 
        &#34;&#34;&#34;Reads levels directly from the DICOM image
        Output Parameters
        *****************
        centre - Image intensity
        width - Image contrast
        maximumValue - Maximum pixel value in the image
        minimumValue - Minimum pixel value in the image
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.readLevelsFromDICOMImage called&#34;)
            #set default values
            centre = -1 
            width = -1 
            maximumValue = -1  
            minimumValue = -1 
            dataset = ReadDICOM_Image.getDicomDataset(self.selectedImagePath)
            if dataset and hasattr(dataset, &#39;WindowCenter&#39;) and hasattr(dataset, &#39;WindowWidth&#39;):
                slope = float(getattr(dataset, &#39;RescaleSlope&#39;, 1))
                intercept = float(getattr(dataset, &#39;RescaleIntercept&#39;, 0))
                centre = dataset.WindowCenter # * slope + intercept
                width = dataset.WindowWidth # * slope
                if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                    centre = centre / dataset[(0x2005, 0x100E)].value
                    width = width / dataset[(0x2005, 0x100E)].value
                maximumValue = centre + width/2
                minimumValue = centre - width/2
            elif dataset and hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
                # In Enhanced MRIs, this display will retrieve the centre and width values of the first slice
                slope = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleSlope
                intercept = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleIntercept
                centre = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowCenter # * slope + intercept
                width = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowWidth # * slope
                if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                    centre = centre / dataset[(0x2005, 0x100E)].value
                    width = width / dataset[(0x2005, 0x100E)].value
                maximumValue = centre + width/2
                minimumValue = centre - width/2 
            else:
                minimumValue = np.amin(self.pixelArray) if (np.median(self.pixelArray) - iqr(self.pixelArray, 
                rng=(1, 99))/2) &lt; np.amin(self.pixelArray) else np.median(self.pixelArray) - iqr(self.pixelArray, rng=(1, 99))/2
                maximumValue = np.amax(self.pixelArray) if (np.median(self.pixelArray) + iqr(self.pixelArray, rng=(
                1, 99))/2) &gt; np.amax(self.pixelArray) else np.median(self.pixelArray) + iqr(self.pixelArray, rng=(1, 99))/2
                centre = minimumValue + (abs(maximumValue) - abs(minimumValue))/2
                width = maximumValue - abs(minimumValue)

            return centre, width, maximumValue, minimumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))


    def updateSingleDicomImage(self):
        &#34;&#34;&#34;
        This function is executed when the Update button 
        is clicked and the user is viewing a singe DICOM image.
        &#34;&#34;&#34;
        try:
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Update DICOM&#39;, &#34;You are about to overwrite this DICOM File. Please click OK to proceed.&#34;, 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
            if buttonReply == QMessageBox.Ok:
                SaveDICOM_Image.updateSingleDicomImage(self.weasel, 
                                                    self.spinBoxIntensity,
                                                    self.spinBoxContrast,
                                                    self.imagePathList,
                                                    self.seriesID,
                                                    self.studyID,
                                                    self.colourTable,
                                                    lut=None)
        except Exception as e:
            print(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))


    def updateDicomSeries(self):
        &#34;&#34;&#34;
        This function is executed when the Update button 
        is clicked and the user is viewing a series of DICOM images.
        It coordinates the calling of the functions, 
        updateWholeDicomSeries &amp; updateDicomSeriesImageByImage.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.updateDICOM called&#34;)
            buttonReply = QMessageBox.question(self.weasel, 
                          &#39;Update DICOM&#39;, &#34;You are about to overwrite this series of DICOM Files. Please click OK to proceed.&#34;, 
                          QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
            if buttonReply == QMessageBox.Ok:
                colourTable = self.cmbColours.currentText()
                if self.userSelection.getSeriesUpdateStatus():
                    levels = [self.spinBoxIntensity.value(), self.spinBoxContrast.value()]
                    self.updateWholeDicomSeries(levels)
                if self.userSelection.getImageUpdateStatus():
                    self.updateDicomSeriesImageByImage() 
        except Exception as e:
            print(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))


    def updateWholeDicomSeries(self, levels):
        &#34;&#34;&#34;
        Updates every image in a DICOM series with one colour table and
                one set of levels
            
          Input Parmeters
          ***************
            levels  - 2 item list containing the image contrast and intensity values as integers, 
                        [contrast, intensity]
            &#34;&#34;&#34;
        try:
            logger.info(&#34;In ImageViewer.updateWholeDicomSeries&#34;)

            #Iterate through list of images and update each image
            numImages = len(self.imagePathList)
            self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
            self.weasel.progressBar.set_maximum(numImages)
            imageCounter = 0
            for imagePath in self.imagePathList:
                dataset = ReadDICOM_Image.getDicomDataset(imagePath) 
                # Update every DICOM file in the series                                     
                updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=self.colourTable, 
                                                                   levels=levels, lut=self.lut)
                SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
                imageCounter += 1
                self.weasel.progressBar.set_value(imageCounter)
            self.weasel.progressBar.close()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateWholeDicomSeries: &#39; + str(e))


    def updateDicomSeriesImageByImage(self):
        &#34;&#34;&#34;Updates one or more images in a DICOM series each with potentially
        a different table and set of levels
        &#34;&#34;&#34;
        try:
            logger.info(&#34;In ImageViewer.updateDicomSeriesImageByImage&#34;)
       
            #Iterate through list of images and update each image
            numImages = len(self.imagePathList)
            self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
            self.weasel.progressBar.set_maximum(numImages)
            imageCounter = 0
       
            for imageCounter, imagePath in enumerate(self.imagePathList, 0):
                #print(&#39;In updateDicomSeriesImageByImage, series name={}&#39;.format(seriesName))
                # Apply user selected colour table &amp; levels to individual images in the series
                imageName = os.path.basename(imagePath)
                selectedColourMap, center, width = self.userSelection.returnUserSelection(imageName)
                #print(&#39;selectedColourMap, center, width = {}, {}, {}&#39;.format(selectedColourMap, center, width))
                if selectedColourMap != &#39;default&#39; and center != -1 and width != -1:
                    # Update an individual DICOM file in the series
                    #print(&#39;In If, imageCounter = {}, imagePath={}&#39;.format(imageCounter, imagePath))
                    levels = [center, width]  
                    dataset = ReadDICOM_Image.getDicomDataset(imagePath)
                    updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=selectedColourMap, 
                                                        levels=levels, lut=None)
                    SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
                self.weasel.progressBar.set_value(imageCounter)
            self.weasel.progressBar.close()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateDicomSeriesImageByImage: &#39; + str(e))


    def displayColourTableInComboBox(self):
        &#34;&#34;&#34;
        This function causes the combobox widget cmbColours to 
        display the name of the colour table stored in the string
        variable colourTable. 
        &#34;&#34;&#34;
        try:
            self.cmbColours.blockSignals(True)
            self.cmbColours.setCurrentText(self.colourTable)
            self.cmbColours.blockSignals(False)
        except Exception as e:
                print(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))
                logger.error(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer"><code class="flex name class">
<span>class <span class="ident">ImageViewer</span></span>
<span>(</span><span>weasel, dcm)</span>
</code></dt>
<dd>
<div class="desc"><p>This class creates a subwindow for viewing an image or series of images with
the facility to change the colour table applied to the image.
It also has multiple
sliders for browsing series of images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageViewer(QMdiSubWindow):
    &#34;&#34;&#34;This class creates a subwindow for viewing an image or series of images with
    the facility to change the colour table applied to the image.  It also has multiple
    sliders for browsing series of images.&#34;&#34;&#34;

    def __init__(self, weasel, dcm): 
        try:
            super().__init__()

            self.subjectID = dcm.subjectID
            self.studyID = dcm.studyID
            self.seriesID = dcm.seriesID
            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.imagePathList = dcm.path
            elif dcm.__class__.__name__ == &#34;Series&#34;:
                self.imagePathList = dcm.images

            self.selectedImagePath = &#34;&#34;
            self.imageNumber = -1
            self.colourTable = &#34;&#34;
            self.cmbColours = QComboBox()  
            self.lut = &#34;&#34;
            self.weasel = weasel

            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.isSeries = False
                self.isImage = True
                self.selectedImagePath = dcm.path
            else:
                self.isSeries = True
                self.isImage = False

            self.setWindowFlags(Qt.CustomizeWindowHint | 
                                          Qt.WindowCloseButtonHint | 
                                          Qt.WindowMinimizeButtonHint |
                                          Qt.WindowMaximizeButtonHint)
        
            height, width = self.weasel.getMDIAreaDimensions()
            self.subWindowWidth = width
            #Set dimensions of the subwindow to fit the MDI area
            self.setGeometry(0, 0, width, height)
            #Add subwindow to MDI
            self.weasel.mdiArea.addSubWindow(self)
             
            if self.isSeries: #DICOM series selected.
                #Create data structure for storing user selected
                #colour table and levels data
                self.userSelection = UserSelection(self.imagePathList)
                
            self.setUpMainLayout()

            self.setUpTopRowLayout()

            self.setUpGraphicsView()

            self.setUpLevelsSpinBoxes()
    
            self.setUpHistogram() #At the right-hand side of the image, adjusts levels
        
            if dcm.__class__.__name__ == &#34;Image&#34;:
                self.displayPixelArrayOfSingleImage(self.imagePathList) 
            else:
                #DICOM series selected
                self.setUpImageSliders()

            self.show()
        except Exception as e:
            print(&#39;Error in ImageViewer.__init__: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.__init__: &#39; + str(e))


    def setUpMainLayout(self):
        try:
            self.mainVerticalLayout = QVBoxLayout()
            self.widget = QWidget()
            self.widget.setLayout(self.mainVerticalLayout)
            self.setWidget(self.widget)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))


    def setUpImageSliders(self):
        try:
            logger.info(&#34;ImageViewer.setpUpImageSliders called.&#34;)
            start = time.perf_counter()
            #create an instance of the ImageSliders class
            self.slidersWidget = imageSliders(self.weasel, 
                                             self.subjectID, 
                                             self.studyID, 
                                             self.seriesID, 
                                             self.imagePathList)

            self.mainVerticalLayout.addLayout(
                    self.slidersWidget.getCustomSliderWidget())

            self.mainImageSlider = self.slidersWidget.getMainSlider()

            #This is how an object created from the ImageSliders class communicates
            #with an object created from the ImageViewer class via the former&#39;s
            #sliderMoved event, which passes the image path of the image being viewed
            #to ImageViewer&#39;s displayPixelArrayOfSingleImage function for display.
            self.slidersWidget.sliderMoved.connect(lambda imagePath: 
                                                   self.displayPixelArrayOfSingleImage(imagePath))
            #Display the first image in the viewer
            #self.displayPixelArrayOfSingleImage(self.imagePathList[0])
            self.slidersWidget.displayFirstImage()
            #print(&#34;ImageViewer.setUpImageSliders time = {} seconds&#34;.format(time.perf_counter()-start))
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))


    def setUpColourTableDropDown(self):                                                  
        self.cmbColours.blockSignals(True)
        self.cmbColours.addItems(listColours)
        self.cmbColours.setCurrentIndex(0)
        self.cmbColours.blockSignals(False)
        self.cmbColours.setToolTip(&#39;Select a colour table to apply to the image&#39;)
        if self.isImage:
            self.cmbColours.currentIndexChanged.connect(self.applyColourTableToAnImage)
        elif self.isSeries:
            self.cmbColours.currentIndexChanged.connect(self.applyColourTableToSeries)

        self.colourTableLayout.addWidget(self.cmbColours)


    def setUpApplyUserSelectionButton(self):
        self.btnApply = QPushButton() 
        self.btnApply.setCheckable(True)
        self.btnApply.setIcon(QIcon(QPixmap(APPLY_SERIES_ICON)))
        self.btnApply.setToolTip(
                    &#34;Click to apply colour table and levels selected by the user to the whole series&#34;)
        self.btnApply.clicked.connect(self.applyColourTableToSeries)


    def setUpUpdateUserSelectionToDICOMButton(self):
        self.btnUpdate = QPushButton() 
        self.btnUpdate.setIcon(QIcon(QPixmap(SAVE_ICON)))
        self.btnUpdate.setToolTip(&#39;Update DICOM with the new colour table, contrast &amp; intensity levels&#39;)
        if self.isImage:
            self.btnUpdate.clicked.connect(self.updateSingleDicomImage)
        elif self.isSeries:
            self.btnUpdate.clicked.connect(self.updateDicomSeries)


    def setUpExportImageButton(self):
        self.btnExport = QPushButton() 
        self.btnExport.setIcon(QIcon(QPixmap(EXPORT_ICON)))
        self.btnExport.setToolTip(&#39;Exports the image to an external graphic file.&#39;)
        self.btnExport.clicked.connect(self.exportImage)


    def setUpResetButton(self):
        self.btnReset = QPushButton() 
        self.btnReset.setIcon(QIcon(QPixmap(RESET_ICON)))
        self.btnReset.setToolTip(&#39;Return to colour tables and levels in the DICOM file&#39;)


    def setUpColourTableGroupBox(self):
        self.colourTableLayout = QHBoxLayout()
        self.colourTableLayout.setContentsMargins(0, 2, 0, 0)
        self.colourTableLayout.setSpacing(5)
        self.colourTableGroupBox = QGroupBox()
        #self.colourTableGroupBox.setFixedWidth(300)
        self.colourTableGroupBox.setFixedHeight(50)
        self.colourTableGroupBox.setLayout(self.colourTableLayout)

        self.setUpColourTableDropDown()

        self.setUpApplyUserSelectionButton()

        self.setUpUpdateUserSelectionToDICOMButton()  #To Do
  
        self.setUpExportImageButton()

        self.setUpResetButton()

        self.setUpDeleteImageButton()

        if self.isImage: 
            self.colourTableLayout.addWidget(self.btnReset)
            self.colourTableLayout.addWidget(self.btnUpdate)
            self.colourTableLayout.addWidget(self.btnExport)
            self.colourTableLayout.addWidget(self.deleteButton)
            self.btnReset.clicked.connect(lambda: self.displayPixelArrayOfSingleImage(self.imagePathList))                                                     
        elif self.isSeries:
            #Viewing a DICOM series, so show the Reset button
            #and Apply to Series checkbox
            self.colourTableLayout.addWidget(self.btnApply)  
            #Clicking Reset button deletes user selected colour table and contrast 
            #and intensity levelts and returns images to values in the original DICOM file.
            self.btnReset.clicked.connect(self.clearUserSelection)
            self.colourTableLayout.addWidget(self.btnReset)
            self.colourTableLayout.addWidget(self.btnUpdate)
            self.colourTableLayout.addWidget(self.btnExport)
            self.colourTableLayout.addWidget(self.deleteButton)
            self.cmbColours.activated.connect(self.updateImageUserSelection)


    def setUpImageLevelsGroupBox(self):
        self.levelsCompositeComponentLayout = imageLevelsSpinBoxes()
        self.imageLevelsGroupBox = QGroupBox()
        self.imageLevelsGroupBox.setFixedWidth(200)
        self.imageLevelsGroupBox.setFixedHeight(50)
        self.imageLevelsGroupBox.setLayout(
            self.levelsCompositeComponentLayout.getCompositeComponent())


    def setUpTopRowLayout(self):
        try:
            self.topRowMainLayout = QHBoxLayout()

            self.setUpColourTableGroupBox()
            self.setUpImageLevelsGroupBox()
            self.setUpPixelValueGroupBox()

            self.topRowMainLayout.addWidget(self.colourTableGroupBox)
            self.topRowMainLayout.addWidget(self.imageLevelsGroupBox) 
            self.topRowMainLayout.addWidget(self.pixelValueGroupBox)

            self.mainVerticalLayout.addLayout(self.topRowMainLayout)

            self.lblImageMissing = QLabel(&#34;&lt;h4&gt;Image Missing&lt;/h4&gt;&#34;)
            self.lblImageMissing.hide()
            self.mainVerticalLayout.addWidget(self.lblImageMissing)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))


    def setUpGraphicsView(self):
        try:
            self.graphicsView = pg.ImageView(view=pg.PlotItem()) #view=pg.PlotItem() adds axes to image
            self.mainVerticalLayout.addWidget(self.graphicsView, stretch=1)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))


    def setUpDeleteImageButton(self):
        try:
            self.deleteButton = QPushButton()
            self.deleteButton.setToolTip(
                &#39;Deletes the DICOM image being viewed&#39;)
            self.deleteButton.setIcon(QIcon(QPixmap(DELETE_ICON)))
            self.deleteButton.clicked.connect(self.deleteImageInMultiImageViewer)
            #self.imageLayout.addWidget(self.deleteButton)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))
 

    def setUpPixelValueGroupBox(self):
        pixelValueComponent = PixelValueComponent()
        self.lblPixelValue = pixelValueComponent.getLabel()
        self.pixelValueGroupBox = QGroupBox(&#34;Pixel Value&#34;)
        self.pixelValueGroupBox.setFixedHeight(50)
        self.pixelValueGroupBox.setLayout(pixelValueComponent.getLayout())  

  
    def getPixelValue(self, pos, imageNumber=1):
        &#34;&#34;&#34;
        This function checks that the mouse pointer is over the
        image and when it is, it determines the value of the pixel
        under the mouse pointer and displays this in the label
        lblPixelValue.
        &#34;&#34;&#34;
        try:
            container =  self.graphicsView.getView()
            if container.sceneBoundingRect().contains(pos): 
                mousePoint = container.getViewBox().mapSceneToView(pos) 
                x_i = math.floor(mousePoint.x())
                y_i = math.floor(mousePoint.y()) 
                #correct the y coordinate value so that it has a value
                #of 0 at the bottom left corner of the image rather than
                #at the top left corner of the image
                _, nY = self.pixelArray.shape
                correctedYCoord = nY -  y_i
                z_i =  imageNumber
                if ((len(np.shape(self.pixelArray)) == 2) 
                    and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 1 ] 
                    and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 0 ]): 
                        self.lblPixelValue.setText(
                        &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
                elif ((len(np.shape(self.pixelArray)) == 3) 
                        and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 1 ] 
                        and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 2 ]):
                            z_i = math.floor(self.graphicsView.timeIndex(self.graphicsView.timeLine)[1])
                            self.lblPixelValue.setText(
                                &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
                else:
                    self.lblPixelValue.setText(&#34;&#34;)
            else:
                self.lblPixelValue.setText(&#34;&#34;)
                   
        except Exception as e:
            print(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))


    def setUpLevelsSpinBoxes(self):
        try:
            self.spinBoxIntensity, self.spinBoxContrast = self.levelsCompositeComponentLayout.getSpinBoxes()
            self.spinBoxIntensity.valueChanged.connect(self.updateImageLevels)
            self.spinBoxContrast.valueChanged.connect(self.updateImageLevels)
            if self.isSeries: 
                self.spinBoxIntensity.valueChanged.connect(self.updateImageUserSelection)
                self.spinBoxContrast.valueChanged.connect(self.updateImageUserSelection)
        except Exception as e:
            print(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))


    def setUpHistogram(self):
        self.histogramObject = self.graphicsView.getHistogramWidget().getHistogram()
        self.histogramObject.sigLevelsChanged.connect(self.getHistogramLevels)
        self.graphicsView.ui.roiBtn.hide()
        self.graphicsView.ui.menuBtn.hide()

    
    def deleteImageInMultiImageViewer(self):
        &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
        this function deletes the physical image, removes the 
        reference to it in the XML file and removes it from the image viewer.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
            imageName = os.path.basename(self.selectedImagePath)
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

            if buttonReply == QMessageBox.Ok:
                #Advance the image sliders by one image unless we are
                #deleting the last image, then move the slider to the
                #first image in the list.
                

                #Delete physical file
                if os.path.exists(self.selectedImagePath):
                    os.remove(self.selectedImagePath)

                #Remove deleted image from the list
                self.imagePathList.remove(self.selectedImagePath)

                #Pass the new imagePathList to the sliders widget and
                #display the next image
                self.slidersWidget.imageDeleted(self.imagePathList)

                #Remove deleted image from the user selection 
                #data structure
                self.userSelection.deleteOneImageInUserSelection(os.path.basename(self.selectedImagePath))

                #Update the XML file
                #Get the series containing this image and count the images it contains
                #If it is the last image in a series then remove the
                #whole series from XML file
                #If it is not the last image in a series
                #just remove the image from the XML file 
                if len(self.imagePathList) == 0:
                    #no images left in the series, so remove it from the xml file
                    self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                               self.studyID, 
                                                                               self.seriesID)
                elif len(self.imagePathList) &gt; 0:
                    #1 or more images in the series, 
                    #so just remove the image from its series in the xml file
                    self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                        self.studyID, self.seriesID, self.selectedImagePath)

                #Update tree view with xml file modified above
                treeView.refreshDICOMStudiesTreeView(self.weasel)

        except Exception as e:
            print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))


    def deleteImageInMultiImageViewer_old(self):
        &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
        this function deletes the physical image, removes the 
        reference to it in the XML file and removes it from the image viewer.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
            lastSliderPosition = self.mainImageSlider.value()
            #currentImagePath = self.imagePathList[self.mainImageSlider.value()-1]
            imageName = os.path.basename(self.selectedImagePath)
            #print (&#39;study id {} series id {}&#39;.format(studyName, seriesName))
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

            if buttonReply == QMessageBox.Ok:
                #Delete physical file
                if os.path.exists(self.selectedImagePath):
                    os.remove(self.selectedImagePath)
                #Remove deleted image from the list
                self.imagePathList.remove(self.selectedImagePath)

                if len(self.imagePathList) == 0:
                    #Only redisplay the multi-image viewer if there
                    #are still images in the series to display
                    #The image list is empty, so do not redisplay
                    #multi image viewer 
                    pass   
                elif len(self.imagePathList) == 1:
                    #There is only one image left in the display
                    self.mainImageSlider.setValue(1)
                    #displayMultiImageSubWindow(self, imageList, subjectID, studyName, seriesName)
                elif len(self.imagePathList) + 1 == lastSliderPosition:    
                        #we are deleting the last image in the series of images
                        #so move the slider back to the penultimate image in list 
                    self.mainImageSlider.setValue(len(self.imagePathList))
                    #displayMultiImageSubWindow(self, imageList, subjectID,
                                        #studyName, seriesName, len(imageList))
                else:
                    #We are deleting an image at the start of the list
                    #or in the body of the list. Move slider forwards to 
                    #the next image in the list.
                    self.mainImageSlider.setValue(lastSliderPosition)
                    #displayMultiImageSubWindow(self, imageList, subjectID,
                    #                    studyName, seriesName, lastSliderPosition)
     
                #Now update XML file
                #Get the series containing this image and count the images it contains
                #If it is the last image in a series then remove the
                #whole series from XML file
                #If it is not the last image in a series
                #just remove the image from the XML file 
                if len(self.imagePathList) == 0:
                    #no images left in the series, so remove it from the xml file
                    self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                               self.studyID, 
                                                                               self.seriesID)
                elif len(self.imagePathList) &gt; 0:
                    #1 or more images in the series, 
                    #so just remove the image from its series in the xml file
                    self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                        self.studyID, self.seriesID, self.selectedImagePath)
                #Update tree view with xml file modified above
                treeView.refreshDICOMStudiesTreeView(self.weasel)
        except Exception as e:
            print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))


    def exportImage(self):
        &#34;&#34;&#34;Function executed when the Export button is clicked.  
        It exports the DICOM image and its colour table to a png graphics file.
        It launches a file dialog, so that the user can select the file path to 
        the png file in which the exported file will be stored. It also collects 
        the name of the image colour table and the image levels.
        &#34;&#34;&#34;
        try:
            self.colourTable = self.cmbColours.currentText()
            #Default file name is derived from the DICOM image name
            defaultImageName = os.path.basename(self.selectedImagePath) 
            #remove .dcm extension
            defaultImageName = os.path.splitext(defaultImageName)[0] + &#39;.png&#39;
            #Display a save file dialog to get the full file path and name of
            #where to export the DICOM image &amp; its colour table to a png file
            fileName, _ = QFileDialog.getSaveFileName(caption=&#34;Enter a file name&#34;, 
                                                        directory=defaultImageName, 
                                                        filter=&#34;*.png&#34;)

            #Test if the user has selected a file name
            if fileName:
                self.exportImageViaMatplotlib(fileName)
        except Exception as e:
            print(&#39;Error in ImageViewer.exportImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.exportImage: &#39; + str(e))


    def exportImageViaMatplotlib(self, fileName):
        &#34;&#34;&#34;This function uses matplotlib.pyplot to save the DICOM image being viewed 
        and its colour table in a png file with the path+filename in fileName. 
    
        Input Parmeters
        ***************
            fileName - file path to the png file in which the exported file will be stored.
        &#34;&#34;&#34; 
        try:
            #axisOrder = pg.getConfigOption(&#39;imageAxisOrder&#39;) 
            #if axisOrder ==&#39;row-major&#39;:
            #Transpose the array so as to match the screen image 
            # (a transpose is already applied when reading DICOM image)
            pixelArray = np.transpose(self.pixelArray)
            cmap = plt.get_cmap(self.colourTable)
            pos = plt.imshow(pixelArray, cmap=cmap)
            minValue, maxValue = self.graphicsView.getLevels()
            plt.clim(int(minValue), int(maxValue))
            cBar = plt.colorbar()
            cBar.minorticks_on()
            plt.savefig(fname=fileName)
            plt.close()
            QMessageBox.information(self, &#34;Export Image&#34;, &#34;Image Saved&#34;)
        except Exception as e:
            print(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))

    
    def updateImageLevels(self):
        &#34;&#34;&#34;When the contrast and intensity values are adjusted using the spinboxes, 
        this function sets the corresponding values in the image being viewed. 
        &#34;&#34;&#34;
        try:
            centre = self.spinBoxIntensity.value()
            width = self.spinBoxContrast.value()
            halfWidth = width/2
            minimumValue = centre - halfWidth
            maximumValue = centre + halfWidth
            self.graphicsView.setLevels(minimumValue, maximumValue)
            self.graphicsView.show()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))


    def getHistogramLevels(self):
        &#34;&#34;&#34;
        This function ensures that the intensity and contrast spinboxes
        show the correct values when the histogram on the right of the
        image is manually adjusted.
        
        The max and min levels of the image are retrieved from the 
        graphicsView object in pyqtGraph and used to calculate
        the intensity (centre) and contrast (width) values of the image.
        Then the contrast &amp; intensity spinboxes are set to these values.
        &#34;&#34;&#34;
        minLevel, maxLevel =  self.graphicsView.getLevels()
        width = maxLevel - minLevel
        centre = minLevel + (width/2)
        self.spinBoxIntensity.setValue(centre)
        self.spinBoxContrast.setValue(width)


    def getColourTableForThisImage(self):
        try:
            logger.info(&#34;ImageViewer.getColourTableForThisImage called&#34;)
            if self.isSeries:
                if self.userSelection.getSeriesUpdateStatus():
                    self.colourTable = self.cmbColours.currentText()
                elif self.userSelection.getImageUpdateStatus():
                    imageName = os.path.basename(self.selectedImagePath)
                    self.colourTable, _, _ = self.userSelection.returnUserSelection(imageName)  
                    if self.colourTable == &#39;default&#39;:
                        self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
                else:  #no user selection, so get colour table saved to DICOM
                    self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
            elif self.isImage: 
                self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
        except Exception as e:
                print(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))
                logger.error(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))


    def getAndSetLevels(self):
        try:
            success = False
            if self.isSeries: 
                success, minimumValue, maximumValue = self.returnUserSelectedLevels()
            if not success or self.isImage:
                centre, width, maximumValue, minimumValue = self.readLevelsFromDICOMImage()

            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
            self.spinBoxIntensity.setValue(centre)
            self.spinBoxContrast.setValue(width)
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
            return maximumValue, minimumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))  


    def getAndSetLevelsSpinBoxStepSize(self, maximumValue, minimumValue):
        try:
            if (minimumValue &lt; 1 and minimumValue &gt; -1) and (maximumValue &lt; 1 and maximumValue &gt; -1):
                spinBoxStep = float((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
            else:
                spinBoxStep = int((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
        
            self.spinBoxIntensity.setSingleStep(spinBoxStep)
            self.spinBoxContrast.setSingleStep(spinBoxStep)
        except Exception as e:
            print(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))

    
    def displayPixelArrayOfSingleImage(self, imagePath):
        &#34;&#34;&#34;Displays an image&#39;s pixel array in a pyqtGraph imageView widget 
        &amp; sets its colour table, contrast and intensity levels. 
        Also, sets the contrast and intensity in the associated histogram.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.displayPixelArrayOfSingleImage called&#34;)
            start = time.perf_counter()
            self.selectedImagePath = imagePath
            imageName = os.path.basename(self.selectedImagePath)
            self.pixelArray = ReadDICOM_Image.returnPixelArray(self.selectedImagePath)

            imageNumber = 1
                
            self.lut = None

            #Get colour table of the image to be displayed
            self.getColourTableForThisImage()

            #display above colour table in colour table dropdown list
            self.displayColourTableInComboBox()

            self.setWindowTitle(self.subjectID + &#39; - &#39; + self.studyID + &#39; - &#39;+ self.seriesID + &#39; - &#39; 
                        + imageName)

            #Check that pixel array holds an image &amp; display it
            if self.pixelArray is None:
                #the image is missing, so show a black screen
                self.lblImageMissing.show()
                self.deleteButton.hide()
                self.graphicsView.setImage(np.array([[0,0,0],[0,0,0]]))  
            else:
                self.lblImageMissing.hide() 
                maximumValue, minimumValue = self.getAndSetLevels()
                
                if len(np.shape(self.pixelArray)) &lt; 3:
                        self.graphicsView.setImage(self.pixelArray, 
                                                autoHistogramRange=True, 
                                                levels=(minimumValue, maximumValue))
                else:
                        self.graphicsView.setImage(self.pixelArray, 
                                                autoHistogramRange=True, 
                                                xvals=np.arange(np.shape(self.pixelArray)[0] + 1), 
                                                levels=(minimumValue, maximumValue))
                
                self.getAndSetLevelsSpinBoxStepSize(maximumValue, minimumValue)
        
                #Add Colour Table or look up table To Image
                self.setPgColourMap()  
  
                self.graphicsView.getView().scene().sigMouseMoved.connect(
                        lambda pos: self.getPixelValue(pos))
                self.graphicsView.getView().scene().sigMouseDragged.connect(
                        lambda ev: self.adjustLevelsByRightButtonDrag(ev))
        except Exception as e:
            print(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))


    def adjustLevelsByRightButtonDrag(self, ev):
        try:
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
            centre = self.spinBoxIntensity.value()
            width = self.spinBoxContrast.value()
            delta = ev.screenPos() - ev.lastScreenPos()
            if float(centre / np.shape(self.pixelArray)[1]) &gt; 0.01:
                step_y = float(centre / np.shape(self.pixelArray)[1])
            else:
                step_y = 0.01
            if float(width / np.shape(self.pixelArray)[0]) &gt; 0.01:
                step_x = float(width/ np.shape(self.pixelArray)[0])
            else:
                step_x = 0.01
            horizontalDiff = step_y * delta.y()
            verticalDiff = step_x * delta.x() # Maybe put a minus sign here
            newCentre = centre + horizontalDiff
            newWidth = width + verticalDiff
            self.spinBoxIntensity.setValue(newCentre)
            self.spinBoxContrast.setValue(newWidth)
            self.updateImageLevels()
            self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
        except Exception as e:
            print(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))
            logger.exception(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))


    def updateImageUserSelection(self):
        &#34;&#34;&#34;
            &#34;&#34;&#34;
        try:
            logger.info(&#39;updateImageUserSelection called&#39;)
            if not self.btnApply.isChecked():
                #The apply user selection to whole series checkbox 
                #is not checked
                self.colourTable = self.cmbColours.currentText()
                intensity = self.spinBoxIntensity.value()
                contrast = self.spinBoxContrast.value()

                if self.selectedImagePath:
                    self.selectedImageName = os.path.basename(self.selectedImagePath)
                else:
                    #Workaround for the fact that when the first image is displayed,
                    #somehow self.selectedImageName looses its value.
                    self.selectedImageName = os.path.basename(self.imagePathList[0])
            
                #print(&#34;self.selectedImageName ={}&#34;.format(self.selectedImageName))
                #print(&#34;colourTable = {}&#34;.format(self.colourTable))
                self.userSelection.updateUserSelection(self.selectedImageName, self.colourTable, intensity, contrast)
        except Exception as e:
            print(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))


    def applyColourTableToAnImage(self):
        self.colourTable = self.cmbColours.currentText()
        if self.colourTable.lower() == &#39;custom&#39;:
            self.colourTable = &#39;gray&#39;                
            self.displayColourTableInComboBox()   
        self.setPgColourMap()


    def applyColourTableToSeries(self): 
        &#34;&#34;&#34;This function applies a user selected colour map to the current image.
        If the Apply checkbox is checked then the new colour map is also applied to 
        the whole series of DICOM images by setting a boolean flag to True.
        &#34;&#34;&#34;
        try:
            self.applyColourTableToAnImage()
        
            if self.btnApply.isChecked():
                self.btnApply.setStyleSheet(&#34;background-color: red&#34;)
                self.userSelection.setSeriesUpdateStatus(True)
                self.userSelection.setImageUpdateStatus(False)
            else:
                self.userSelection.setSeriesUpdateStatus(False)
                self.btnApply.setStyleSheet(
                &#34;background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)&#34;
                )     
        except Exception as e:
            print(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))


    def clearUserSelection(self):
        &#34;&#34;&#34;This function removes the user selected colour tables, contrast &amp; intensity values from
        the list of image lists that hold these values.  They are reset to the default values of
        &#39;default&#39; for the colour table and -1 for the contrast &amp; intensity values
        &#34;&#34;&#34;
        self.userSelection.clearUserSelection()

        #reload current image to display it without user selected 
        #colour table and levels.
        #This is done by advancing the slider and then moving it  
        #back to the original image
        imageNumber = self.slidersWidget.getMainSlider().value() #self.mainImageSlider.value()
        if imageNumber == 1:
            tempNumber = imageNumber + 1
        else:
            tempNumber = imageNumber - 1

        self.slidersWidget.getMainSlider().setValue(tempNumber)
        self.slidersWidget.getMainSlider().setValue(imageNumber)
    

    def returnUserSelectedLevels(self):
        &#34;&#34;&#34;
        When the user has selected new image levels that must override the 
        levels saved in the DICOM series/image, this function returns those selected levels
        Output parameters
        *****************
        success - boolean, set to true if level values are successfully retrieved
        maximumValue - Maximum pixel value in the image
        minimumValue - Minimum pixel value in the image
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.returnUserSelectedLevels called&#34;)
      
            minimumValue = -1
            maximumValue = -1
            success = False
            
            if self.userSelection.getSeriesUpdateStatus():
                #Get the ordinal number of the image being viewed in the image list
                currentImageNumber = self.slidersWidget.getMainSlider().value() - 1
                centre = self.spinBoxIntensity.value()
                width = self.spinBoxContrast.value()
                #apply contrast and intensity values
                #selected in the GUI spinboxes
                #for the whole series to this image
                minimumValue = centre - (width/2)
                maximumValue = centre + (width/2)
                success = True
            elif self.userSelection.getImageUpdateStatus():
                #the user has opted to change the levels of individual images
                #in a series.
                #if user selected levels exist for this image, retrieve them
                imageName = os.path.basename(self.selectedImagePath)
                _, centre, width = self.userSelection.returnUserSelection(imageName) 
                if centre != -1:
                    #saved values exist, so use them
                    minimumValue = centre - (width/2)
                    maximumValue = centre + (width/2)
                    success = True

            return success, minimumValue, maximumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))

    def setPgColourMap(self):
        &#34;&#34;&#34;This function converts a matplotlib colour map into
        a colour map that can be used by the pyqtGraph imageView widget.
        &#34;&#34;&#34;
        try:
            if self.colourTable == None or self.colourTable == &#34;&#34;:
                self.colourTable = &#39;gray&#39;

            if self.cmbColours is not None:
                self.displayColourTableInComboBox()   
        
            if self.colourTable == &#39;custom&#39;:
                colors = self.lut
            elif self.colourTable == &#39;gray&#39;:
                colors = [[0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]]
            else:
                cmMap = cm.get_cmap(self.colourTable)
                colourClassName = cmMap.__class__.__name__
                if colourClassName == &#39;ListedColormap&#39;:
                    colors = cmMap.colors
                elif colourClassName == &#39;LinearSegmentedColormap&#39;:
                    colors = cmMap(np.linspace(0, 1))
          
            positions = np.linspace(0, 1, len(colors))
            pgMap = pg.ColorMap(positions, colors)
            self.graphicsView.setColorMap(pgMap)        
        except Exception as e:
            print(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))


    def readLevelsFromDICOMImage(self): 
        &#34;&#34;&#34;Reads levels directly from the DICOM image
        Output Parameters
        *****************
        centre - Image intensity
        width - Image contrast
        maximumValue - Maximum pixel value in the image
        minimumValue - Minimum pixel value in the image
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.readLevelsFromDICOMImage called&#34;)
            #set default values
            centre = -1 
            width = -1 
            maximumValue = -1  
            minimumValue = -1 
            dataset = ReadDICOM_Image.getDicomDataset(self.selectedImagePath)
            if dataset and hasattr(dataset, &#39;WindowCenter&#39;) and hasattr(dataset, &#39;WindowWidth&#39;):
                slope = float(getattr(dataset, &#39;RescaleSlope&#39;, 1))
                intercept = float(getattr(dataset, &#39;RescaleIntercept&#39;, 0))
                centre = dataset.WindowCenter # * slope + intercept
                width = dataset.WindowWidth # * slope
                if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                    centre = centre / dataset[(0x2005, 0x100E)].value
                    width = width / dataset[(0x2005, 0x100E)].value
                maximumValue = centre + width/2
                minimumValue = centre - width/2
            elif dataset and hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
                # In Enhanced MRIs, this display will retrieve the centre and width values of the first slice
                slope = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleSlope
                intercept = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleIntercept
                centre = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowCenter # * slope + intercept
                width = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowWidth # * slope
                if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                    centre = centre / dataset[(0x2005, 0x100E)].value
                    width = width / dataset[(0x2005, 0x100E)].value
                maximumValue = centre + width/2
                minimumValue = centre - width/2 
            else:
                minimumValue = np.amin(self.pixelArray) if (np.median(self.pixelArray) - iqr(self.pixelArray, 
                rng=(1, 99))/2) &lt; np.amin(self.pixelArray) else np.median(self.pixelArray) - iqr(self.pixelArray, rng=(1, 99))/2
                maximumValue = np.amax(self.pixelArray) if (np.median(self.pixelArray) + iqr(self.pixelArray, rng=(
                1, 99))/2) &gt; np.amax(self.pixelArray) else np.median(self.pixelArray) + iqr(self.pixelArray, rng=(1, 99))/2
                centre = minimumValue + (abs(maximumValue) - abs(minimumValue))/2
                width = maximumValue - abs(minimumValue)

            return centre, width, maximumValue, minimumValue
        except Exception as e:
            print(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))


    def updateSingleDicomImage(self):
        &#34;&#34;&#34;
        This function is executed when the Update button 
        is clicked and the user is viewing a singe DICOM image.
        &#34;&#34;&#34;
        try:
            buttonReply = QMessageBox.question(self.weasel, 
                &#39;Update DICOM&#39;, &#34;You are about to overwrite this DICOM File. Please click OK to proceed.&#34;, 
                QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
            if buttonReply == QMessageBox.Ok:
                SaveDICOM_Image.updateSingleDicomImage(self.weasel, 
                                                    self.spinBoxIntensity,
                                                    self.spinBoxContrast,
                                                    self.imagePathList,
                                                    self.seriesID,
                                                    self.studyID,
                                                    self.colourTable,
                                                    lut=None)
        except Exception as e:
            print(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))


    def updateDicomSeries(self):
        &#34;&#34;&#34;
        This function is executed when the Update button 
        is clicked and the user is viewing a series of DICOM images.
        It coordinates the calling of the functions, 
        updateWholeDicomSeries &amp; updateDicomSeriesImageByImage.
        &#34;&#34;&#34;
        try:
            logger.info(&#34;ImageViewer.updateDICOM called&#34;)
            buttonReply = QMessageBox.question(self.weasel, 
                          &#39;Update DICOM&#39;, &#34;You are about to overwrite this series of DICOM Files. Please click OK to proceed.&#34;, 
                          QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
            if buttonReply == QMessageBox.Ok:
                colourTable = self.cmbColours.currentText()
                if self.userSelection.getSeriesUpdateStatus():
                    levels = [self.spinBoxIntensity.value(), self.spinBoxContrast.value()]
                    self.updateWholeDicomSeries(levels)
                if self.userSelection.getImageUpdateStatus():
                    self.updateDicomSeriesImageByImage() 
        except Exception as e:
            print(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))


    def updateWholeDicomSeries(self, levels):
        &#34;&#34;&#34;
        Updates every image in a DICOM series with one colour table and
                one set of levels
            
          Input Parmeters
          ***************
            levels  - 2 item list containing the image contrast and intensity values as integers, 
                        [contrast, intensity]
            &#34;&#34;&#34;
        try:
            logger.info(&#34;In ImageViewer.updateWholeDicomSeries&#34;)

            #Iterate through list of images and update each image
            numImages = len(self.imagePathList)
            self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
            self.weasel.progressBar.set_maximum(numImages)
            imageCounter = 0
            for imagePath in self.imagePathList:
                dataset = ReadDICOM_Image.getDicomDataset(imagePath) 
                # Update every DICOM file in the series                                     
                updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=self.colourTable, 
                                                                   levels=levels, lut=self.lut)
                SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
                imageCounter += 1
                self.weasel.progressBar.set_value(imageCounter)
            self.weasel.progressBar.close()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateWholeDicomSeries: &#39; + str(e))


    def updateDicomSeriesImageByImage(self):
        &#34;&#34;&#34;Updates one or more images in a DICOM series each with potentially
        a different table and set of levels
        &#34;&#34;&#34;
        try:
            logger.info(&#34;In ImageViewer.updateDicomSeriesImageByImage&#34;)
       
            #Iterate through list of images and update each image
            numImages = len(self.imagePathList)
            self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
            self.weasel.progressBar.set_maximum(numImages)
            imageCounter = 0
       
            for imageCounter, imagePath in enumerate(self.imagePathList, 0):
                #print(&#39;In updateDicomSeriesImageByImage, series name={}&#39;.format(seriesName))
                # Apply user selected colour table &amp; levels to individual images in the series
                imageName = os.path.basename(imagePath)
                selectedColourMap, center, width = self.userSelection.returnUserSelection(imageName)
                #print(&#39;selectedColourMap, center, width = {}, {}, {}&#39;.format(selectedColourMap, center, width))
                if selectedColourMap != &#39;default&#39; and center != -1 and width != -1:
                    # Update an individual DICOM file in the series
                    #print(&#39;In If, imageCounter = {}, imagePath={}&#39;.format(imageCounter, imagePath))
                    levels = [center, width]  
                    dataset = ReadDICOM_Image.getDicomDataset(imagePath)
                    updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=selectedColourMap, 
                                                        levels=levels, lut=None)
                    SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
                self.weasel.progressBar.set_value(imageCounter)
            self.weasel.progressBar.close()
        except Exception as e:
            print(&#39;Error in ImageViewer.updateDicomSeriesImageByImage: &#39; + str(e))


    def displayColourTableInComboBox(self):
        &#34;&#34;&#34;
        This function causes the combobox widget cmbColours to 
        display the name of the colour table stored in the string
        variable colourTable. 
        &#34;&#34;&#34;
        try:
            self.cmbColours.blockSignals(True)
            self.cmbColours.setCurrentText(self.colourTable)
            self.cmbColours.blockSignals(False)
        except Exception as e:
                print(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))
                logger.error(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMdiSubWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.adjustLevelsByRightButtonDrag"><code class="name flex">
<span>def <span class="ident">adjustLevelsByRightButtonDrag</span></span>(<span>self, ev)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjustLevelsByRightButtonDrag(self, ev):
    try:
        self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
        centre = self.spinBoxIntensity.value()
        width = self.spinBoxContrast.value()
        delta = ev.screenPos() - ev.lastScreenPos()
        if float(centre / np.shape(self.pixelArray)[1]) &gt; 0.01:
            step_y = float(centre / np.shape(self.pixelArray)[1])
        else:
            step_y = 0.01
        if float(width / np.shape(self.pixelArray)[0]) &gt; 0.01:
            step_x = float(width/ np.shape(self.pixelArray)[0])
        else:
            step_x = 0.01
        horizontalDiff = step_y * delta.y()
        verticalDiff = step_x * delta.x() # Maybe put a minus sign here
        newCentre = centre + horizontalDiff
        newWidth = width + verticalDiff
        self.spinBoxIntensity.setValue(newCentre)
        self.spinBoxContrast.setValue(newWidth)
        self.updateImageLevels()
        self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
    except Exception as e:
        print(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))
        logger.exception(&#39;Error in ImageViewer.adjustLevelsByRightButtonDrag: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToAnImage"><code class="name flex">
<span>def <span class="ident">applyColourTableToAnImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applyColourTableToAnImage(self):
    self.colourTable = self.cmbColours.currentText()
    if self.colourTable.lower() == &#39;custom&#39;:
        self.colourTable = &#39;gray&#39;                
        self.displayColourTableInComboBox()   
    self.setPgColourMap()</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToSeries"><code class="name flex">
<span>def <span class="ident">applyColourTableToSeries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function applies a user selected colour map to the current image.
If the Apply checkbox is checked then the new colour map is also applied to
the whole series of DICOM images by setting a boolean flag to True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applyColourTableToSeries(self): 
    &#34;&#34;&#34;This function applies a user selected colour map to the current image.
    If the Apply checkbox is checked then the new colour map is also applied to 
    the whole series of DICOM images by setting a boolean flag to True.
    &#34;&#34;&#34;
    try:
        self.applyColourTableToAnImage()
    
        if self.btnApply.isChecked():
            self.btnApply.setStyleSheet(&#34;background-color: red&#34;)
            self.userSelection.setSeriesUpdateStatus(True)
            self.userSelection.setImageUpdateStatus(False)
        else:
            self.userSelection.setSeriesUpdateStatus(False)
            self.btnApply.setStyleSheet(
            &#34;background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)&#34;
            )     
    except Exception as e:
        print(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.applyColourTableToSeries: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.clearUserSelection"><code class="name flex">
<span>def <span class="ident">clearUserSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function removes the user selected colour tables, contrast &amp; intensity values from
the list of image lists that hold these values.
They are reset to the default values of
'default' for the colour table and -1 for the contrast &amp; intensity values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearUserSelection(self):
    &#34;&#34;&#34;This function removes the user selected colour tables, contrast &amp; intensity values from
    the list of image lists that hold these values.  They are reset to the default values of
    &#39;default&#39; for the colour table and -1 for the contrast &amp; intensity values
    &#34;&#34;&#34;
    self.userSelection.clearUserSelection()

    #reload current image to display it without user selected 
    #colour table and levels.
    #This is done by advancing the slider and then moving it  
    #back to the original image
    imageNumber = self.slidersWidget.getMainSlider().value() #self.mainImageSlider.value()
    if imageNumber == 1:
        tempNumber = imageNumber + 1
    else:
        tempNumber = imageNumber - 1

    self.slidersWidget.getMainSlider().setValue(tempNumber)
    self.slidersWidget.getMainSlider().setValue(imageNumber)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer"><code class="name flex">
<span>def <span class="ident">deleteImageInMultiImageViewer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the Delete button is clicked on the multi image viewer,
this function deletes the physical image, removes the
reference to it in the XML file and removes it from the image viewer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteImageInMultiImageViewer(self):
    &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
    this function deletes the physical image, removes the 
    reference to it in the XML file and removes it from the image viewer.
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
        imageName = os.path.basename(self.selectedImagePath)
        buttonReply = QMessageBox.question(self.weasel, 
            &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
            QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

        if buttonReply == QMessageBox.Ok:
            #Advance the image sliders by one image unless we are
            #deleting the last image, then move the slider to the
            #first image in the list.
            

            #Delete physical file
            if os.path.exists(self.selectedImagePath):
                os.remove(self.selectedImagePath)

            #Remove deleted image from the list
            self.imagePathList.remove(self.selectedImagePath)

            #Pass the new imagePathList to the sliders widget and
            #display the next image
            self.slidersWidget.imageDeleted(self.imagePathList)

            #Remove deleted image from the user selection 
            #data structure
            self.userSelection.deleteOneImageInUserSelection(os.path.basename(self.selectedImagePath))

            #Update the XML file
            #Get the series containing this image and count the images it contains
            #If it is the last image in a series then remove the
            #whole series from XML file
            #If it is not the last image in a series
            #just remove the image from the XML file 
            if len(self.imagePathList) == 0:
                #no images left in the series, so remove it from the xml file
                self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                           self.studyID, 
                                                                           self.seriesID)
            elif len(self.imagePathList) &gt; 0:
                #1 or more images in the series, 
                #so just remove the image from its series in the xml file
                self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                    self.studyID, self.seriesID, self.selectedImagePath)

            #Update tree view with xml file modified above
            treeView.refreshDICOMStudiesTreeView(self.weasel)

    except Exception as e:
        print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer_old"><code class="name flex">
<span>def <span class="ident">deleteImageInMultiImageViewer_old</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the Delete button is clicked on the multi image viewer,
this function deletes the physical image, removes the
reference to it in the XML file and removes it from the image viewer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteImageInMultiImageViewer_old(self):
    &#34;&#34;&#34;When the Delete button is clicked on the multi image viewer,
    this function deletes the physical image, removes the 
    reference to it in the XML file and removes it from the image viewer.
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.deleteImageInMultiImageViewer called&#34;)
        lastSliderPosition = self.mainImageSlider.value()
        #currentImagePath = self.imagePathList[self.mainImageSlider.value()-1]
        imageName = os.path.basename(self.selectedImagePath)
        #print (&#39;study id {} series id {}&#39;.format(studyName, seriesName))
        buttonReply = QMessageBox.question(self.weasel, 
            &#39;Delete DICOM image&#39;, &#34;You are about to delete image {}&#34;.format(imageName), 
            QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)

        if buttonReply == QMessageBox.Ok:
            #Delete physical file
            if os.path.exists(self.selectedImagePath):
                os.remove(self.selectedImagePath)
            #Remove deleted image from the list
            self.imagePathList.remove(self.selectedImagePath)

            if len(self.imagePathList) == 0:
                #Only redisplay the multi-image viewer if there
                #are still images in the series to display
                #The image list is empty, so do not redisplay
                #multi image viewer 
                pass   
            elif len(self.imagePathList) == 1:
                #There is only one image left in the display
                self.mainImageSlider.setValue(1)
                #displayMultiImageSubWindow(self, imageList, subjectID, studyName, seriesName)
            elif len(self.imagePathList) + 1 == lastSliderPosition:    
                    #we are deleting the last image in the series of images
                    #so move the slider back to the penultimate image in list 
                self.mainImageSlider.setValue(len(self.imagePathList))
                #displayMultiImageSubWindow(self, imageList, subjectID,
                                    #studyName, seriesName, len(imageList))
            else:
                #We are deleting an image at the start of the list
                #or in the body of the list. Move slider forwards to 
                #the next image in the list.
                self.mainImageSlider.setValue(lastSliderPosition)
                #displayMultiImageSubWindow(self, imageList, subjectID,
                #                    studyName, seriesName, lastSliderPosition)
 
            #Now update XML file
            #Get the series containing this image and count the images it contains
            #If it is the last image in a series then remove the
            #whole series from XML file
            #If it is not the last image in a series
            #just remove the image from the XML file 
            if len(self.imagePathList) == 0:
                #no images left in the series, so remove it from the xml file
                self.weasel.objXMLReader.removeOneSeriesFromStudy(self.subjectID, 
                                                                           self.studyID, 
                                                                           self.seriesID)
            elif len(self.imagePathList) &gt; 0:
                #1 or more images in the series, 
                #so just remove the image from its series in the xml file
                self.weasel.objXMLReader.removeOneImageFromSeries(self.subjectID, 
                    self.studyID, self.seriesID, self.selectedImagePath)
            #Update tree view with xml file modified above
            treeView.refreshDICOMStudiesTreeView(self.weasel)
    except Exception as e:
        print(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.deleteImageInMultiImageViewer: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayColourTableInComboBox"><code class="name flex">
<span>def <span class="ident">displayColourTableInComboBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function causes the combobox widget cmbColours to
display the name of the colour table stored in the string
variable colourTable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayColourTableInComboBox(self):
    &#34;&#34;&#34;
    This function causes the combobox widget cmbColours to 
    display the name of the colour table stored in the string
    variable colourTable. 
    &#34;&#34;&#34;
    try:
        self.cmbColours.blockSignals(True)
        self.cmbColours.setCurrentText(self.colourTable)
        self.cmbColours.blockSignals(False)
    except Exception as e:
            print(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.displayColourTableInComboBox: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayPixelArrayOfSingleImage"><code class="name flex">
<span>def <span class="ident">displayPixelArrayOfSingleImage</span></span>(<span>self, imagePath)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays an image's pixel array in a pyqtGraph imageView widget
&amp; sets its colour table, contrast and intensity levels.
Also, sets the contrast and intensity in the associated histogram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayPixelArrayOfSingleImage(self, imagePath):
    &#34;&#34;&#34;Displays an image&#39;s pixel array in a pyqtGraph imageView widget 
    &amp; sets its colour table, contrast and intensity levels. 
    Also, sets the contrast and intensity in the associated histogram.
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.displayPixelArrayOfSingleImage called&#34;)
        start = time.perf_counter()
        self.selectedImagePath = imagePath
        imageName = os.path.basename(self.selectedImagePath)
        self.pixelArray = ReadDICOM_Image.returnPixelArray(self.selectedImagePath)

        imageNumber = 1
            
        self.lut = None

        #Get colour table of the image to be displayed
        self.getColourTableForThisImage()

        #display above colour table in colour table dropdown list
        self.displayColourTableInComboBox()

        self.setWindowTitle(self.subjectID + &#39; - &#39; + self.studyID + &#39; - &#39;+ self.seriesID + &#39; - &#39; 
                    + imageName)

        #Check that pixel array holds an image &amp; display it
        if self.pixelArray is None:
            #the image is missing, so show a black screen
            self.lblImageMissing.show()
            self.deleteButton.hide()
            self.graphicsView.setImage(np.array([[0,0,0],[0,0,0]]))  
        else:
            self.lblImageMissing.hide() 
            maximumValue, minimumValue = self.getAndSetLevels()
            
            if len(np.shape(self.pixelArray)) &lt; 3:
                    self.graphicsView.setImage(self.pixelArray, 
                                            autoHistogramRange=True, 
                                            levels=(minimumValue, maximumValue))
            else:
                    self.graphicsView.setImage(self.pixelArray, 
                                            autoHistogramRange=True, 
                                            xvals=np.arange(np.shape(self.pixelArray)[0] + 1), 
                                            levels=(minimumValue, maximumValue))
            
            self.getAndSetLevelsSpinBoxStepSize(maximumValue, minimumValue)
    
            #Add Colour Table or look up table To Image
            self.setPgColourMap()  

            self.graphicsView.getView().scene().sigMouseMoved.connect(
                    lambda pos: self.getPixelValue(pos))
            self.graphicsView.getView().scene().sigMouseDragged.connect(
                    lambda ev: self.adjustLevelsByRightButtonDrag(ev))
    except Exception as e:
        print(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))
        logger.exception(&#39;Error in ImageViewer.displayPixelArrayOfSingleImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImage"><code class="name flex">
<span>def <span class="ident">exportImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function executed when the Export button is clicked.<br>
It exports the DICOM image and its colour table to a png graphics file.
It launches a file dialog, so that the user can select the file path to
the png file in which the exported file will be stored. It also collects
the name of the image colour table and the image levels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportImage(self):
    &#34;&#34;&#34;Function executed when the Export button is clicked.  
    It exports the DICOM image and its colour table to a png graphics file.
    It launches a file dialog, so that the user can select the file path to 
    the png file in which the exported file will be stored. It also collects 
    the name of the image colour table and the image levels.
    &#34;&#34;&#34;
    try:
        self.colourTable = self.cmbColours.currentText()
        #Default file name is derived from the DICOM image name
        defaultImageName = os.path.basename(self.selectedImagePath) 
        #remove .dcm extension
        defaultImageName = os.path.splitext(defaultImageName)[0] + &#39;.png&#39;
        #Display a save file dialog to get the full file path and name of
        #where to export the DICOM image &amp; its colour table to a png file
        fileName, _ = QFileDialog.getSaveFileName(caption=&#34;Enter a file name&#34;, 
                                                    directory=defaultImageName, 
                                                    filter=&#34;*.png&#34;)

        #Test if the user has selected a file name
        if fileName:
            self.exportImageViaMatplotlib(fileName)
    except Exception as e:
        print(&#39;Error in ImageViewer.exportImage: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.exportImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImageViaMatplotlib"><code class="name flex">
<span>def <span class="ident">exportImageViaMatplotlib</span></span>(<span>self, fileName)</span>
</code></dt>
<dd>
<div class="desc"><p>This function uses matplotlib.pyplot to save the DICOM image being viewed
and its colour table in a png file with the path+filename in fileName. </p>
<p>Input Parmeters</p>
<hr>
<pre><code>fileName - file path to the png file in which the exported file will be stored.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportImageViaMatplotlib(self, fileName):
    &#34;&#34;&#34;This function uses matplotlib.pyplot to save the DICOM image being viewed 
    and its colour table in a png file with the path+filename in fileName. 

    Input Parmeters
    ***************
        fileName - file path to the png file in which the exported file will be stored.
    &#34;&#34;&#34; 
    try:
        #axisOrder = pg.getConfigOption(&#39;imageAxisOrder&#39;) 
        #if axisOrder ==&#39;row-major&#39;:
        #Transpose the array so as to match the screen image 
        # (a transpose is already applied when reading DICOM image)
        pixelArray = np.transpose(self.pixelArray)
        cmap = plt.get_cmap(self.colourTable)
        pos = plt.imshow(pixelArray, cmap=cmap)
        minValue, maxValue = self.graphicsView.getLevels()
        plt.clim(int(minValue), int(maxValue))
        cBar = plt.colorbar()
        cBar.minorticks_on()
        plt.savefig(fname=fileName)
        plt.close()
        QMessageBox.information(self, &#34;Export Image&#34;, &#34;Image Saved&#34;)
    except Exception as e:
        print(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.exportImageViaMatplotlib: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevels"><code class="name flex">
<span>def <span class="ident">getAndSetLevels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAndSetLevels(self):
    try:
        success = False
        if self.isSeries: 
            success, minimumValue, maximumValue = self.returnUserSelectedLevels()
        if not success or self.isImage:
            centre, width, maximumValue, minimumValue = self.readLevelsFromDICOMImage()

        self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(True)
        self.spinBoxIntensity.setValue(centre)
        self.spinBoxContrast.setValue(width)
        self.levelsCompositeComponentLayout.blockLevelsSpinBoxSignals(False)
        return maximumValue, minimumValue
    except Exception as e:
        print(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))
        logger.exception(&#39;Error in ImageViewer.getAndSetLevels: &#39; + str(e))  </code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevelsSpinBoxStepSize"><code class="name flex">
<span>def <span class="ident">getAndSetLevelsSpinBoxStepSize</span></span>(<span>self, maximumValue, minimumValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAndSetLevelsSpinBoxStepSize(self, maximumValue, minimumValue):
    try:
        if (minimumValue &lt; 1 and minimumValue &gt; -1) and (maximumValue &lt; 1 and maximumValue &gt; -1):
            spinBoxStep = float((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
        else:
            spinBoxStep = int((maximumValue - minimumValue) / 200) # It takes 100 clicks to walk through the middle 50% of the signal range
    
        self.spinBoxIntensity.setSingleStep(spinBoxStep)
        self.spinBoxContrast.setSingleStep(spinBoxStep)
    except Exception as e:
        print(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))
        logger.exception(&#39;Error in ImageViewer.getAndSetLevelsSpinBoxStepSize: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getColourTableForThisImage"><code class="name flex">
<span>def <span class="ident">getColourTableForThisImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getColourTableForThisImage(self):
    try:
        logger.info(&#34;ImageViewer.getColourTableForThisImage called&#34;)
        if self.isSeries:
            if self.userSelection.getSeriesUpdateStatus():
                self.colourTable = self.cmbColours.currentText()
            elif self.userSelection.getImageUpdateStatus():
                imageName = os.path.basename(self.selectedImagePath)
                self.colourTable, _, _ = self.userSelection.returnUserSelection(imageName)  
                if self.colourTable == &#39;default&#39;:
                    self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
            else:  #no user selection, so get colour table saved to DICOM
                self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
        elif self.isImage: 
            self.colourTable, self.lut = ReadDICOM_Image.getColourmap(self.selectedImagePath)
    except Exception as e:
            print(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))
            logger.error(&#39;Error in ImageViewer.getColourTableForThisImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getHistogramLevels"><code class="name flex">
<span>def <span class="ident">getHistogramLevels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function ensures that the intensity and contrast spinboxes
show the correct values when the histogram on the right of the
image is manually adjusted.</p>
<p>The max and min levels of the image are retrieved from the
graphicsView object in pyqtGraph and used to calculate
the intensity (centre) and contrast (width) values of the image.
Then the contrast &amp; intensity spinboxes are set to these values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHistogramLevels(self):
    &#34;&#34;&#34;
    This function ensures that the intensity and contrast spinboxes
    show the correct values when the histogram on the right of the
    image is manually adjusted.
    
    The max and min levels of the image are retrieved from the 
    graphicsView object in pyqtGraph and used to calculate
    the intensity (centre) and contrast (width) values of the image.
    Then the contrast &amp; intensity spinboxes are set to these values.
    &#34;&#34;&#34;
    minLevel, maxLevel =  self.graphicsView.getLevels()
    width = maxLevel - minLevel
    centre = minLevel + (width/2)
    self.spinBoxIntensity.setValue(centre)
    self.spinBoxContrast.setValue(width)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getPixelValue"><code class="name flex">
<span>def <span class="ident">getPixelValue</span></span>(<span>self, pos, imageNumber=1)</span>
</code></dt>
<dd>
<div class="desc"><p>This function checks that the mouse pointer is over the
image and when it is, it determines the value of the pixel
under the mouse pointer and displays this in the label
lblPixelValue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPixelValue(self, pos, imageNumber=1):
    &#34;&#34;&#34;
    This function checks that the mouse pointer is over the
    image and when it is, it determines the value of the pixel
    under the mouse pointer and displays this in the label
    lblPixelValue.
    &#34;&#34;&#34;
    try:
        container =  self.graphicsView.getView()
        if container.sceneBoundingRect().contains(pos): 
            mousePoint = container.getViewBox().mapSceneToView(pos) 
            x_i = math.floor(mousePoint.x())
            y_i = math.floor(mousePoint.y()) 
            #correct the y coordinate value so that it has a value
            #of 0 at the bottom left corner of the image rather than
            #at the top left corner of the image
            _, nY = self.pixelArray.shape
            correctedYCoord = nY -  y_i
            z_i =  imageNumber
            if ((len(np.shape(self.pixelArray)) == 2) 
                and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 1 ] 
                and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 0 ]): 
                    self.lblPixelValue.setText(
                    &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
            elif ((len(np.shape(self.pixelArray)) == 3) 
                    and x_i &gt;= 0 and x_i &lt; self.pixelArray.shape [ 1 ] 
                    and y_i &gt;= 0 and y_i &lt; self.pixelArray.shape [ 2 ]):
                        z_i = math.floor(self.graphicsView.timeIndex(self.graphicsView.timeLine)[1])
                        self.lblPixelValue.setText(
                            &#34;&lt;h4&gt; {} @ X: {}, Y: {}, Z: {} ({})&lt;/h4&gt;&#34;.format (self.pixelArray[ x_i, y_i ],x_i, correctedYCoord, z_i, ReadDICOM_Image.getImageTagValue(self.selectedImagePath, &#34;SliceLocation&#34;)))
            else:
                self.lblPixelValue.setText(&#34;&#34;)
        else:
            self.lblPixelValue.setText(&#34;&#34;)
               
    except Exception as e:
        print(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.getPixelValue: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.readLevelsFromDICOMImage"><code class="name flex">
<span>def <span class="ident">readLevelsFromDICOMImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads levels directly from the DICOM image
Output Parameters</p>
<hr>
<p>centre - Image intensity
width - Image contrast
maximumValue - Maximum pixel value in the image
minimumValue - Minimum pixel value in the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readLevelsFromDICOMImage(self): 
    &#34;&#34;&#34;Reads levels directly from the DICOM image
    Output Parameters
    *****************
    centre - Image intensity
    width - Image contrast
    maximumValue - Maximum pixel value in the image
    minimumValue - Minimum pixel value in the image
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.readLevelsFromDICOMImage called&#34;)
        #set default values
        centre = -1 
        width = -1 
        maximumValue = -1  
        minimumValue = -1 
        dataset = ReadDICOM_Image.getDicomDataset(self.selectedImagePath)
        if dataset and hasattr(dataset, &#39;WindowCenter&#39;) and hasattr(dataset, &#39;WindowWidth&#39;):
            slope = float(getattr(dataset, &#39;RescaleSlope&#39;, 1))
            intercept = float(getattr(dataset, &#39;RescaleIntercept&#39;, 0))
            centre = dataset.WindowCenter # * slope + intercept
            width = dataset.WindowWidth # * slope
            if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                centre = centre / dataset[(0x2005, 0x100E)].value
                width = width / dataset[(0x2005, 0x100E)].value
            maximumValue = centre + width/2
            minimumValue = centre - width/2
        elif dataset and hasattr(dataset, &#39;PerFrameFunctionalGroupsSequence&#39;):
            # In Enhanced MRIs, this display will retrieve the centre and width values of the first slice
            slope = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleSlope
            intercept = dataset.PerFrameFunctionalGroupsSequence[0].PixelValueTransformationSequence[0].RescaleIntercept
            centre = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowCenter # * slope + intercept
            width = dataset.PerFrameFunctionalGroupsSequence[0].FrameVOILUTSequence[0].WindowWidth # * slope
            if [0x2005, 0x100E] in dataset: # &#39;Philips Rescale Slope&#39;
                centre = centre / dataset[(0x2005, 0x100E)].value
                width = width / dataset[(0x2005, 0x100E)].value
            maximumValue = centre + width/2
            minimumValue = centre - width/2 
        else:
            minimumValue = np.amin(self.pixelArray) if (np.median(self.pixelArray) - iqr(self.pixelArray, 
            rng=(1, 99))/2) &lt; np.amin(self.pixelArray) else np.median(self.pixelArray) - iqr(self.pixelArray, rng=(1, 99))/2
            maximumValue = np.amax(self.pixelArray) if (np.median(self.pixelArray) + iqr(self.pixelArray, rng=(
            1, 99))/2) &gt; np.amax(self.pixelArray) else np.median(self.pixelArray) + iqr(self.pixelArray, rng=(1, 99))/2
            centre = minimumValue + (abs(maximumValue) - abs(minimumValue))/2
            width = maximumValue - abs(minimumValue)

        return centre, width, maximumValue, minimumValue
    except Exception as e:
        print(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.readLevelsFromDICOMImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.returnUserSelectedLevels"><code class="name flex">
<span>def <span class="ident">returnUserSelectedLevels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the user has selected new image levels that must override the
levels saved in the DICOM series/image, this function returns those selected levels
Output parameters</p>
<hr>
<p>success - boolean, set to true if level values are successfully retrieved
maximumValue - Maximum pixel value in the image
minimumValue - Minimum pixel value in the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returnUserSelectedLevels(self):
    &#34;&#34;&#34;
    When the user has selected new image levels that must override the 
    levels saved in the DICOM series/image, this function returns those selected levels
    Output parameters
    *****************
    success - boolean, set to true if level values are successfully retrieved
    maximumValue - Maximum pixel value in the image
    minimumValue - Minimum pixel value in the image
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.returnUserSelectedLevels called&#34;)
  
        minimumValue = -1
        maximumValue = -1
        success = False
        
        if self.userSelection.getSeriesUpdateStatus():
            #Get the ordinal number of the image being viewed in the image list
            currentImageNumber = self.slidersWidget.getMainSlider().value() - 1
            centre = self.spinBoxIntensity.value()
            width = self.spinBoxContrast.value()
            #apply contrast and intensity values
            #selected in the GUI spinboxes
            #for the whole series to this image
            minimumValue = centre - (width/2)
            maximumValue = centre + (width/2)
            success = True
        elif self.userSelection.getImageUpdateStatus():
            #the user has opted to change the levels of individual images
            #in a series.
            #if user selected levels exist for this image, retrieve them
            imageName = os.path.basename(self.selectedImagePath)
            _, centre, width = self.userSelection.returnUserSelection(imageName) 
            if centre != -1:
                #saved values exist, so use them
                minimumValue = centre - (width/2)
                maximumValue = centre + (width/2)
                success = True

        return success, minimumValue, maximumValue
    except Exception as e:
        print(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.returnUserSelectedLevels: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setPgColourMap"><code class="name flex">
<span>def <span class="ident">setPgColourMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts a matplotlib colour map into
a colour map that can be used by the pyqtGraph imageView widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPgColourMap(self):
    &#34;&#34;&#34;This function converts a matplotlib colour map into
    a colour map that can be used by the pyqtGraph imageView widget.
    &#34;&#34;&#34;
    try:
        if self.colourTable == None or self.colourTable == &#34;&#34;:
            self.colourTable = &#39;gray&#39;

        if self.cmbColours is not None:
            self.displayColourTableInComboBox()   
    
        if self.colourTable == &#39;custom&#39;:
            colors = self.lut
        elif self.colourTable == &#39;gray&#39;:
            colors = [[0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]]
        else:
            cmMap = cm.get_cmap(self.colourTable)
            colourClassName = cmMap.__class__.__name__
            if colourClassName == &#39;ListedColormap&#39;:
                colors = cmMap.colors
            elif colourClassName == &#39;LinearSegmentedColormap&#39;:
                colors = cmMap(np.linspace(0, 1))
      
        positions = np.linspace(0, 1, len(colors))
        pgMap = pg.ColorMap(positions, colors)
        self.graphicsView.setColorMap(pgMap)        
    except Exception as e:
        print(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setPgColourMap: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpApplyUserSelectionButton"><code class="name flex">
<span>def <span class="ident">setUpApplyUserSelectionButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpApplyUserSelectionButton(self):
    self.btnApply = QPushButton() 
    self.btnApply.setCheckable(True)
    self.btnApply.setIcon(QIcon(QPixmap(APPLY_SERIES_ICON)))
    self.btnApply.setToolTip(
                &#34;Click to apply colour table and levels selected by the user to the whole series&#34;)
    self.btnApply.clicked.connect(self.applyColourTableToSeries)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableDropDown"><code class="name flex">
<span>def <span class="ident">setUpColourTableDropDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpColourTableDropDown(self):                                                  
    self.cmbColours.blockSignals(True)
    self.cmbColours.addItems(listColours)
    self.cmbColours.setCurrentIndex(0)
    self.cmbColours.blockSignals(False)
    self.cmbColours.setToolTip(&#39;Select a colour table to apply to the image&#39;)
    if self.isImage:
        self.cmbColours.currentIndexChanged.connect(self.applyColourTableToAnImage)
    elif self.isSeries:
        self.cmbColours.currentIndexChanged.connect(self.applyColourTableToSeries)

    self.colourTableLayout.addWidget(self.cmbColours)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableGroupBox"><code class="name flex">
<span>def <span class="ident">setUpColourTableGroupBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpColourTableGroupBox(self):
    self.colourTableLayout = QHBoxLayout()
    self.colourTableLayout.setContentsMargins(0, 2, 0, 0)
    self.colourTableLayout.setSpacing(5)
    self.colourTableGroupBox = QGroupBox()
    #self.colourTableGroupBox.setFixedWidth(300)
    self.colourTableGroupBox.setFixedHeight(50)
    self.colourTableGroupBox.setLayout(self.colourTableLayout)

    self.setUpColourTableDropDown()

    self.setUpApplyUserSelectionButton()

    self.setUpUpdateUserSelectionToDICOMButton()  #To Do

    self.setUpExportImageButton()

    self.setUpResetButton()

    self.setUpDeleteImageButton()

    if self.isImage: 
        self.colourTableLayout.addWidget(self.btnReset)
        self.colourTableLayout.addWidget(self.btnUpdate)
        self.colourTableLayout.addWidget(self.btnExport)
        self.colourTableLayout.addWidget(self.deleteButton)
        self.btnReset.clicked.connect(lambda: self.displayPixelArrayOfSingleImage(self.imagePathList))                                                     
    elif self.isSeries:
        #Viewing a DICOM series, so show the Reset button
        #and Apply to Series checkbox
        self.colourTableLayout.addWidget(self.btnApply)  
        #Clicking Reset button deletes user selected colour table and contrast 
        #and intensity levelts and returns images to values in the original DICOM file.
        self.btnReset.clicked.connect(self.clearUserSelection)
        self.colourTableLayout.addWidget(self.btnReset)
        self.colourTableLayout.addWidget(self.btnUpdate)
        self.colourTableLayout.addWidget(self.btnExport)
        self.colourTableLayout.addWidget(self.deleteButton)
        self.cmbColours.activated.connect(self.updateImageUserSelection)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpDeleteImageButton"><code class="name flex">
<span>def <span class="ident">setUpDeleteImageButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpDeleteImageButton(self):
    try:
        self.deleteButton = QPushButton()
        self.deleteButton.setToolTip(
            &#39;Deletes the DICOM image being viewed&#39;)
        self.deleteButton.setIcon(QIcon(QPixmap(DELETE_ICON)))
        self.deleteButton.clicked.connect(self.deleteImageInMultiImageViewer)
        #self.imageLayout.addWidget(self.deleteButton)
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpDeleteImageButton: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpExportImageButton"><code class="name flex">
<span>def <span class="ident">setUpExportImageButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpExportImageButton(self):
    self.btnExport = QPushButton() 
    self.btnExport.setIcon(QIcon(QPixmap(EXPORT_ICON)))
    self.btnExport.setToolTip(&#39;Exports the image to an external graphic file.&#39;)
    self.btnExport.clicked.connect(self.exportImage)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpGraphicsView"><code class="name flex">
<span>def <span class="ident">setUpGraphicsView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpGraphicsView(self):
    try:
        self.graphicsView = pg.ImageView(view=pg.PlotItem()) #view=pg.PlotItem() adds axes to image
        self.mainVerticalLayout.addWidget(self.graphicsView, stretch=1)
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpGraphicsView: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpHistogram"><code class="name flex">
<span>def <span class="ident">setUpHistogram</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpHistogram(self):
    self.histogramObject = self.graphicsView.getHistogramWidget().getHistogram()
    self.histogramObject.sigLevelsChanged.connect(self.getHistogramLevels)
    self.graphicsView.ui.roiBtn.hide()
    self.graphicsView.ui.menuBtn.hide()</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageLevelsGroupBox"><code class="name flex">
<span>def <span class="ident">setUpImageLevelsGroupBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpImageLevelsGroupBox(self):
    self.levelsCompositeComponentLayout = imageLevelsSpinBoxes()
    self.imageLevelsGroupBox = QGroupBox()
    self.imageLevelsGroupBox.setFixedWidth(200)
    self.imageLevelsGroupBox.setFixedHeight(50)
    self.imageLevelsGroupBox.setLayout(
        self.levelsCompositeComponentLayout.getCompositeComponent())</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageSliders"><code class="name flex">
<span>def <span class="ident">setUpImageSliders</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpImageSliders(self):
    try:
        logger.info(&#34;ImageViewer.setpUpImageSliders called.&#34;)
        start = time.perf_counter()
        #create an instance of the ImageSliders class
        self.slidersWidget = imageSliders(self.weasel, 
                                         self.subjectID, 
                                         self.studyID, 
                                         self.seriesID, 
                                         self.imagePathList)

        self.mainVerticalLayout.addLayout(
                self.slidersWidget.getCustomSliderWidget())

        self.mainImageSlider = self.slidersWidget.getMainSlider()

        #This is how an object created from the ImageSliders class communicates
        #with an object created from the ImageViewer class via the former&#39;s
        #sliderMoved event, which passes the image path of the image being viewed
        #to ImageViewer&#39;s displayPixelArrayOfSingleImage function for display.
        self.slidersWidget.sliderMoved.connect(lambda imagePath: 
                                               self.displayPixelArrayOfSingleImage(imagePath))
        #Display the first image in the viewer
        #self.displayPixelArrayOfSingleImage(self.imagePathList[0])
        self.slidersWidget.displayFirstImage()
        #print(&#34;ImageViewer.setUpImageSliders time = {} seconds&#34;.format(time.perf_counter()-start))
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpImageSliders: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpLevelsSpinBoxes"><code class="name flex">
<span>def <span class="ident">setUpLevelsSpinBoxes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpLevelsSpinBoxes(self):
    try:
        self.spinBoxIntensity, self.spinBoxContrast = self.levelsCompositeComponentLayout.getSpinBoxes()
        self.spinBoxIntensity.valueChanged.connect(self.updateImageLevels)
        self.spinBoxContrast.valueChanged.connect(self.updateImageLevels)
        if self.isSeries: 
            self.spinBoxIntensity.valueChanged.connect(self.updateImageUserSelection)
            self.spinBoxContrast.valueChanged.connect(self.updateImageUserSelection)
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpLevelsSpinBoxes: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpMainLayout"><code class="name flex">
<span>def <span class="ident">setUpMainLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpMainLayout(self):
    try:
        self.mainVerticalLayout = QVBoxLayout()
        self.widget = QWidget()
        self.widget.setLayout(self.mainVerticalLayout)
        self.setWidget(self.widget)
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpMainLayout: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpPixelValueGroupBox"><code class="name flex">
<span>def <span class="ident">setUpPixelValueGroupBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpPixelValueGroupBox(self):
    pixelValueComponent = PixelValueComponent()
    self.lblPixelValue = pixelValueComponent.getLabel()
    self.pixelValueGroupBox = QGroupBox(&#34;Pixel Value&#34;)
    self.pixelValueGroupBox.setFixedHeight(50)
    self.pixelValueGroupBox.setLayout(pixelValueComponent.getLayout())  </code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpResetButton"><code class="name flex">
<span>def <span class="ident">setUpResetButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpResetButton(self):
    self.btnReset = QPushButton() 
    self.btnReset.setIcon(QIcon(QPixmap(RESET_ICON)))
    self.btnReset.setToolTip(&#39;Return to colour tables and levels in the DICOM file&#39;)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpTopRowLayout"><code class="name flex">
<span>def <span class="ident">setUpTopRowLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpTopRowLayout(self):
    try:
        self.topRowMainLayout = QHBoxLayout()

        self.setUpColourTableGroupBox()
        self.setUpImageLevelsGroupBox()
        self.setUpPixelValueGroupBox()

        self.topRowMainLayout.addWidget(self.colourTableGroupBox)
        self.topRowMainLayout.addWidget(self.imageLevelsGroupBox) 
        self.topRowMainLayout.addWidget(self.pixelValueGroupBox)

        self.mainVerticalLayout.addLayout(self.topRowMainLayout)

        self.lblImageMissing = QLabel(&#34;&lt;h4&gt;Image Missing&lt;/h4&gt;&#34;)
        self.lblImageMissing.hide()
        self.mainVerticalLayout.addWidget(self.lblImageMissing)
    except Exception as e:
        print(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.setUpTopRowLayout: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpUpdateUserSelectionToDICOMButton"><code class="name flex">
<span>def <span class="ident">setUpUpdateUserSelectionToDICOMButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpUpdateUserSelectionToDICOMButton(self):
    self.btnUpdate = QPushButton() 
    self.btnUpdate.setIcon(QIcon(QPixmap(SAVE_ICON)))
    self.btnUpdate.setToolTip(&#39;Update DICOM with the new colour table, contrast &amp; intensity levels&#39;)
    if self.isImage:
        self.btnUpdate.clicked.connect(self.updateSingleDicomImage)
    elif self.isSeries:
        self.btnUpdate.clicked.connect(self.updateDicomSeries)</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeries"><code class="name flex">
<span>def <span class="ident">updateDicomSeries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is executed when the Update button
is clicked and the user is viewing a series of DICOM images.
It coordinates the calling of the functions,
updateWholeDicomSeries &amp; updateDicomSeriesImageByImage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateDicomSeries(self):
    &#34;&#34;&#34;
    This function is executed when the Update button 
    is clicked and the user is viewing a series of DICOM images.
    It coordinates the calling of the functions, 
    updateWholeDicomSeries &amp; updateDicomSeriesImageByImage.
    &#34;&#34;&#34;
    try:
        logger.info(&#34;ImageViewer.updateDICOM called&#34;)
        buttonReply = QMessageBox.question(self.weasel, 
                      &#39;Update DICOM&#39;, &#34;You are about to overwrite this series of DICOM Files. Please click OK to proceed.&#34;, 
                      QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
        if buttonReply == QMessageBox.Ok:
            colourTable = self.cmbColours.currentText()
            if self.userSelection.getSeriesUpdateStatus():
                levels = [self.spinBoxIntensity.value(), self.spinBoxContrast.value()]
                self.updateWholeDicomSeries(levels)
            if self.userSelection.getImageUpdateStatus():
                self.updateDicomSeriesImageByImage() 
    except Exception as e:
        print(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.updateDicomSeries: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeriesImageByImage"><code class="name flex">
<span>def <span class="ident">updateDicomSeriesImageByImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates one or more images in a DICOM series each with potentially
a different table and set of levels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateDicomSeriesImageByImage(self):
    &#34;&#34;&#34;Updates one or more images in a DICOM series each with potentially
    a different table and set of levels
    &#34;&#34;&#34;
    try:
        logger.info(&#34;In ImageViewer.updateDicomSeriesImageByImage&#34;)
   
        #Iterate through list of images and update each image
        numImages = len(self.imagePathList)
        self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
        self.weasel.progressBar.set_maximum(numImages)
        imageCounter = 0
   
        for imageCounter, imagePath in enumerate(self.imagePathList, 0):
            #print(&#39;In updateDicomSeriesImageByImage, series name={}&#39;.format(seriesName))
            # Apply user selected colour table &amp; levels to individual images in the series
            imageName = os.path.basename(imagePath)
            selectedColourMap, center, width = self.userSelection.returnUserSelection(imageName)
            #print(&#39;selectedColourMap, center, width = {}, {}, {}&#39;.format(selectedColourMap, center, width))
            if selectedColourMap != &#39;default&#39; and center != -1 and width != -1:
                # Update an individual DICOM file in the series
                #print(&#39;In If, imageCounter = {}, imagePath={}&#39;.format(imageCounter, imagePath))
                levels = [center, width]  
                dataset = ReadDICOM_Image.getDicomDataset(imagePath)
                updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=selectedColourMap, 
                                                    levels=levels, lut=None)
                SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
            self.weasel.progressBar.set_value(imageCounter)
        self.weasel.progressBar.close()
    except Exception as e:
        print(&#39;Error in ImageViewer.updateDicomSeriesImageByImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageLevels"><code class="name flex">
<span>def <span class="ident">updateImageLevels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the contrast and intensity values are adjusted using the spinboxes,
this function sets the corresponding values in the image being viewed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateImageLevels(self):
    &#34;&#34;&#34;When the contrast and intensity values are adjusted using the spinboxes, 
    this function sets the corresponding values in the image being viewed. 
    &#34;&#34;&#34;
    try:
        centre = self.spinBoxIntensity.value()
        width = self.spinBoxContrast.value()
        halfWidth = width/2
        minimumValue = centre - halfWidth
        maximumValue = centre + halfWidth
        self.graphicsView.setLevels(minimumValue, maximumValue)
        self.graphicsView.show()
    except Exception as e:
        print(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.updateImageLevels: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageUserSelection"><code class="name flex">
<span>def <span class="ident">updateImageUserSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateImageUserSelection(self):
    &#34;&#34;&#34;
        &#34;&#34;&#34;
    try:
        logger.info(&#39;updateImageUserSelection called&#39;)
        if not self.btnApply.isChecked():
            #The apply user selection to whole series checkbox 
            #is not checked
            self.colourTable = self.cmbColours.currentText()
            intensity = self.spinBoxIntensity.value()
            contrast = self.spinBoxContrast.value()

            if self.selectedImagePath:
                self.selectedImageName = os.path.basename(self.selectedImagePath)
            else:
                #Workaround for the fact that when the first image is displayed,
                #somehow self.selectedImageName looses its value.
                self.selectedImageName = os.path.basename(self.imagePathList[0])
        
            #print(&#34;self.selectedImageName ={}&#34;.format(self.selectedImageName))
            #print(&#34;colourTable = {}&#34;.format(self.colourTable))
            self.userSelection.updateUserSelection(self.selectedImageName, self.colourTable, intensity, contrast)
    except Exception as e:
        print(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.updateImageUserSelection: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateSingleDicomImage"><code class="name flex">
<span>def <span class="ident">updateSingleDicomImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is executed when the Update button
is clicked and the user is viewing a singe DICOM image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateSingleDicomImage(self):
    &#34;&#34;&#34;
    This function is executed when the Update button 
    is clicked and the user is viewing a singe DICOM image.
    &#34;&#34;&#34;
    try:
        buttonReply = QMessageBox.question(self.weasel, 
            &#39;Update DICOM&#39;, &#34;You are about to overwrite this DICOM File. Please click OK to proceed.&#34;, 
            QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
        if buttonReply == QMessageBox.Ok:
            SaveDICOM_Image.updateSingleDicomImage(self.weasel, 
                                                self.spinBoxIntensity,
                                                self.spinBoxContrast,
                                                self.imagePathList,
                                                self.seriesID,
                                                self.studyID,
                                                self.colourTable,
                                                lut=None)
    except Exception as e:
        print(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))
        logger.error(&#39;Error in ImageViewer.updateSingleDicomImage: &#39; + str(e))</code></pre>
</details>
</dd>
<dt id="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateWholeDicomSeries"><code class="name flex">
<span>def <span class="ident">updateWholeDicomSeries</span></span>(<span>self, levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates every image in a DICOM series with one colour table and
one set of levels</p>
<p>Input Parmeters</p>
<hr>
<pre><code>levels  - 2 item list containing the image contrast and intensity values as integers, 
            [contrast, intensity]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateWholeDicomSeries(self, levels):
    &#34;&#34;&#34;
    Updates every image in a DICOM series with one colour table and
            one set of levels
        
      Input Parmeters
      ***************
        levels  - 2 item list containing the image contrast and intensity values as integers, 
                    [contrast, intensity]
        &#34;&#34;&#34;
    try:
        logger.info(&#34;In ImageViewer.updateWholeDicomSeries&#34;)

        #Iterate through list of images and update each image
        numImages = len(self.imagePathList)
        self.weasel.progress_bar(msg=&#34;&lt;H4&gt;Updating {} DICOM files&lt;/H4&gt;&#34;.format(numImages))
        self.weasel.progressBar.set_maximum(numImages)
        imageCounter = 0
        for imagePath in self.imagePathList:
            dataset = ReadDICOM_Image.getDicomDataset(imagePath) 
            # Update every DICOM file in the series                                     
            updatedDataset = SaveDICOM_Image.updateSingleDicom(dataset, colourmap=self.colourTable, 
                                                               levels=levels, lut=self.lut)
            SaveDICOM_Image.saveDicomToFile(updatedDataset, output_path=imagePath)
            imageCounter += 1
            self.weasel.progressBar.set_value(imageCounter)
        self.weasel.progressBar.close()
    except Exception as e:
        print(&#39;Error in ImageViewer.updateWholeDicomSeries: &#39; + str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="WEASEL.Displays.ImageViewers" href="index.html">WEASEL.Displays.ImageViewers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer">ImageViewer</a></code></h4>
<ul class="">
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.adjustLevelsByRightButtonDrag" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.adjustLevelsByRightButtonDrag">adjustLevelsByRightButtonDrag</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToAnImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToAnImage">applyColourTableToAnImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToSeries" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.applyColourTableToSeries">applyColourTableToSeries</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.clearUserSelection" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.clearUserSelection">clearUserSelection</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer">deleteImageInMultiImageViewer</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer_old" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.deleteImageInMultiImageViewer_old">deleteImageInMultiImageViewer_old</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayColourTableInComboBox" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayColourTableInComboBox">displayColourTableInComboBox</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayPixelArrayOfSingleImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.displayPixelArrayOfSingleImage">displayPixelArrayOfSingleImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImage">exportImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImageViaMatplotlib" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.exportImageViaMatplotlib">exportImageViaMatplotlib</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevels" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevels">getAndSetLevels</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevelsSpinBoxStepSize" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getAndSetLevelsSpinBoxStepSize">getAndSetLevelsSpinBoxStepSize</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getColourTableForThisImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getColourTableForThisImage">getColourTableForThisImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getHistogramLevels" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getHistogramLevels">getHistogramLevels</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getPixelValue" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.getPixelValue">getPixelValue</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.readLevelsFromDICOMImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.readLevelsFromDICOMImage">readLevelsFromDICOMImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.returnUserSelectedLevels" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.returnUserSelectedLevels">returnUserSelectedLevels</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setPgColourMap" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setPgColourMap">setPgColourMap</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpApplyUserSelectionButton" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpApplyUserSelectionButton">setUpApplyUserSelectionButton</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableDropDown" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableDropDown">setUpColourTableDropDown</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableGroupBox" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpColourTableGroupBox">setUpColourTableGroupBox</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpDeleteImageButton" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpDeleteImageButton">setUpDeleteImageButton</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpExportImageButton" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpExportImageButton">setUpExportImageButton</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpGraphicsView" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpGraphicsView">setUpGraphicsView</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpHistogram" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpHistogram">setUpHistogram</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageLevelsGroupBox" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageLevelsGroupBox">setUpImageLevelsGroupBox</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageSliders" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpImageSliders">setUpImageSliders</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpLevelsSpinBoxes" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpLevelsSpinBoxes">setUpLevelsSpinBoxes</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpMainLayout" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpMainLayout">setUpMainLayout</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpPixelValueGroupBox" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpPixelValueGroupBox">setUpPixelValueGroupBox</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpResetButton" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpResetButton">setUpResetButton</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpTopRowLayout" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpTopRowLayout">setUpTopRowLayout</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpUpdateUserSelectionToDICOMButton" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.setUpUpdateUserSelectionToDICOMButton">setUpUpdateUserSelectionToDICOMButton</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeries" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeries">updateDicomSeries</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeriesImageByImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateDicomSeriesImageByImage">updateDicomSeriesImageByImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageLevels" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageLevels">updateImageLevels</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageUserSelection" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateImageUserSelection">updateImageUserSelection</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateSingleDicomImage" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateSingleDicomImage">updateSingleDicomImage</a></code></li>
<li><code><a title="WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateWholeDicomSeries" href="#WEASEL.Displays.ImageViewers.ImageViewer.ImageViewer.updateWholeDicomSeries">updateWholeDicomSeries</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>